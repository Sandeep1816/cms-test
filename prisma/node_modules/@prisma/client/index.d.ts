
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectStats
 * 
 */
export type ProjectStats = $Result.DefaultSelection<Prisma.$ProjectStatsPayload>
/**
 * Model Attendee
 * 
 */
export type Attendee = $Result.DefaultSelection<Prisma.$AttendeePayload>
/**
 * Model Delegate
 * 
 */
export type Delegate = $Result.DefaultSelection<Prisma.$DelegatePayload>
/**
 * Model Speaker
 * 
 */
export type Speaker = $Result.DefaultSelection<Prisma.$SpeakerPayload>
/**
 * Model MarketingCampaign
 * 
 */
export type MarketingCampaign = $Result.DefaultSelection<Prisma.$MarketingCampaignPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Exhibitor
 * 
 */
export type Exhibitor = $Result.DefaultSelection<Prisma.$ExhibitorPayload>
/**
 * Model Sponsor
 * 
 */
export type Sponsor = $Result.DefaultSelection<Prisma.$SponsorPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model MediaPartner
 * 
 */
export type MediaPartner = $Result.DefaultSelection<Prisma.$MediaPartnerPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Enquiry
 * 
 */
export type Enquiry = $Result.DefaultSelection<Prisma.$EnquiryPayload>
/**
 * Model UtmData
 * 
 */
export type UtmData = $Result.DefaultSelection<Prisma.$UtmDataPayload>
/**
 * Model AgendaDay
 * 
 */
export type AgendaDay = $Result.DefaultSelection<Prisma.$AgendaDayPayload>
/**
 * Model AgendaSession
 * 
 */
export type AgendaSession = $Result.DefaultSelection<Prisma.$AgendaSessionPayload>
/**
 * Model AgendaItem
 * 
 */
export type AgendaItem = $Result.DefaultSelection<Prisma.$AgendaItemPayload>
/**
 * Model AgendaItemSpeaker
 * 
 */
export type AgendaItemSpeaker = $Result.DefaultSelection<Prisma.$AgendaItemSpeakerPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Projects
 * const projects = await prisma.project.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Projects
   * const projects = await prisma.project.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStats`: Exposes CRUD operations for the **ProjectStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStats
    * const projectStats = await prisma.projectStats.findMany()
    * ```
    */
  get projectStats(): Prisma.ProjectStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendee`: Exposes CRUD operations for the **Attendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendees
    * const attendees = await prisma.attendee.findMany()
    * ```
    */
  get attendee(): Prisma.AttendeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delegate`: Exposes CRUD operations for the **Delegate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delegates
    * const delegates = await prisma.delegate.findMany()
    * ```
    */
  get delegate(): Prisma.DelegateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speaker`: Exposes CRUD operations for the **Speaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speakers
    * const speakers = await prisma.speaker.findMany()
    * ```
    */
  get speaker(): Prisma.SpeakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingCampaign`: Exposes CRUD operations for the **MarketingCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingCampaigns
    * const marketingCampaigns = await prisma.marketingCampaign.findMany()
    * ```
    */
  get marketingCampaign(): Prisma.MarketingCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exhibitor`: Exposes CRUD operations for the **Exhibitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exhibitors
    * const exhibitors = await prisma.exhibitor.findMany()
    * ```
    */
  get exhibitor(): Prisma.ExhibitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsor`: Exposes CRUD operations for the **Sponsor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsor.findMany()
    * ```
    */
  get sponsor(): Prisma.SponsorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaPartner`: Exposes CRUD operations for the **MediaPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaPartners
    * const mediaPartners = await prisma.mediaPartner.findMany()
    * ```
    */
  get mediaPartner(): Prisma.MediaPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enquiry`: Exposes CRUD operations for the **Enquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enquiries
    * const enquiries = await prisma.enquiry.findMany()
    * ```
    */
  get enquiry(): Prisma.EnquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utmData`: Exposes CRUD operations for the **UtmData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UtmData
    * const utmData = await prisma.utmData.findMany()
    * ```
    */
  get utmData(): Prisma.UtmDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaDay`: Exposes CRUD operations for the **AgendaDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaDays
    * const agendaDays = await prisma.agendaDay.findMany()
    * ```
    */
  get agendaDay(): Prisma.AgendaDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaSession`: Exposes CRUD operations for the **AgendaSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaSessions
    * const agendaSessions = await prisma.agendaSession.findMany()
    * ```
    */
  get agendaSession(): Prisma.AgendaSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaItem`: Exposes CRUD operations for the **AgendaItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaItems
    * const agendaItems = await prisma.agendaItem.findMany()
    * ```
    */
  get agendaItem(): Prisma.AgendaItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaItemSpeaker`: Exposes CRUD operations for the **AgendaItemSpeaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaItemSpeakers
    * const agendaItemSpeakers = await prisma.agendaItemSpeaker.findMany()
    * ```
    */
  get agendaItemSpeaker(): Prisma.AgendaItemSpeakerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Project: 'Project',
    ProjectStats: 'ProjectStats',
    Attendee: 'Attendee',
    Delegate: 'Delegate',
    Speaker: 'Speaker',
    MarketingCampaign: 'MarketingCampaign',
    Lead: 'Lead',
    Session: 'Session',
    Exhibitor: 'Exhibitor',
    Sponsor: 'Sponsor',
    Partner: 'Partner',
    MediaPartner: 'MediaPartner',
    Order: 'Order',
    Enquiry: 'Enquiry',
    UtmData: 'UtmData',
    AgendaDay: 'AgendaDay',
    AgendaSession: 'AgendaSession',
    AgendaItem: 'AgendaItem',
    AgendaItemSpeaker: 'AgendaItemSpeaker'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "project" | "projectStats" | "attendee" | "delegate" | "speaker" | "marketingCampaign" | "lead" | "session" | "exhibitor" | "sponsor" | "partner" | "mediaPartner" | "order" | "enquiry" | "utmData" | "agendaDay" | "agendaSession" | "agendaItem" | "agendaItemSpeaker"
      txIsolationLevel: never
    }
    model: {
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectStats: {
        payload: Prisma.$ProjectStatsPayload<ExtArgs>
        fields: Prisma.ProjectStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          findFirst: {
            args: Prisma.ProjectStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          findMany: {
            args: Prisma.ProjectStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>[]
          }
          create: {
            args: Prisma.ProjectStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          createMany: {
            args: Prisma.ProjectStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          update: {
            args: Prisma.ProjectStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          aggregate: {
            args: Prisma.ProjectStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStats>
          }
          groupBy: {
            args: Prisma.ProjectStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProjectStatsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProjectStatsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProjectStatsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatsCountAggregateOutputType> | number
          }
        }
      }
      Attendee: {
        payload: Prisma.$AttendeePayload<ExtArgs>
        fields: Prisma.AttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          findFirst: {
            args: Prisma.AttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          findMany: {
            args: Prisma.AttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>[]
          }
          create: {
            args: Prisma.AttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          createMany: {
            args: Prisma.AttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          update: {
            args: Prisma.AttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          deleteMany: {
            args: Prisma.AttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          aggregate: {
            args: Prisma.AttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendee>
          }
          groupBy: {
            args: Prisma.AttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendeeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AttendeeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AttendeeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<AttendeeCountAggregateOutputType> | number
          }
        }
      }
      Delegate: {
        payload: Prisma.$DelegatePayload<ExtArgs>
        fields: Prisma.DelegateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DelegateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DelegateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          findFirst: {
            args: Prisma.DelegateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DelegateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          findMany: {
            args: Prisma.DelegateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>[]
          }
          create: {
            args: Prisma.DelegateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          createMany: {
            args: Prisma.DelegateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DelegateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          update: {
            args: Prisma.DelegateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          deleteMany: {
            args: Prisma.DelegateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DelegateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DelegateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          aggregate: {
            args: Prisma.DelegateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelegate>
          }
          groupBy: {
            args: Prisma.DelegateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DelegateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DelegateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DelegateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DelegateCountArgs<ExtArgs>
            result: $Utils.Optional<DelegateCountAggregateOutputType> | number
          }
        }
      }
      Speaker: {
        payload: Prisma.$SpeakerPayload<ExtArgs>
        fields: Prisma.SpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          findFirst: {
            args: Prisma.SpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          findMany: {
            args: Prisma.SpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
          }
          create: {
            args: Prisma.SpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          createMany: {
            args: Prisma.SpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          update: {
            args: Prisma.SpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          deleteMany: {
            args: Prisma.SpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          aggregate: {
            args: Prisma.SpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeaker>
          }
          groupBy: {
            args: Prisma.SpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpeakerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpeakerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakerCountAggregateOutputType> | number
          }
        }
      }
      MarketingCampaign: {
        payload: Prisma.$MarketingCampaignPayload<ExtArgs>
        fields: Prisma.MarketingCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          findFirst: {
            args: Prisma.MarketingCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          findMany: {
            args: Prisma.MarketingCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>[]
          }
          create: {
            args: Prisma.MarketingCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          createMany: {
            args: Prisma.MarketingCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketingCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          update: {
            args: Prisma.MarketingCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          deleteMany: {
            args: Prisma.MarketingCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketingCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          aggregate: {
            args: Prisma.MarketingCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingCampaign>
          }
          groupBy: {
            args: Prisma.MarketingCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingCampaignGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MarketingCampaignFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MarketingCampaignAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MarketingCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingCampaignCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LeadFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LeadAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Exhibitor: {
        payload: Prisma.$ExhibitorPayload<ExtArgs>
        fields: Prisma.ExhibitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExhibitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExhibitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          findFirst: {
            args: Prisma.ExhibitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExhibitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          findMany: {
            args: Prisma.ExhibitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>[]
          }
          create: {
            args: Prisma.ExhibitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          createMany: {
            args: Prisma.ExhibitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExhibitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          update: {
            args: Prisma.ExhibitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          deleteMany: {
            args: Prisma.ExhibitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExhibitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExhibitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          aggregate: {
            args: Prisma.ExhibitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExhibitor>
          }
          groupBy: {
            args: Prisma.ExhibitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExhibitorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExhibitorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExhibitorCountArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorCountAggregateOutputType> | number
          }
        }
      }
      Sponsor: {
        payload: Prisma.$SponsorPayload<ExtArgs>
        fields: Prisma.SponsorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findFirst: {
            args: Prisma.SponsorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findMany: {
            args: Prisma.SponsorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          create: {
            args: Prisma.SponsorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          createMany: {
            args: Prisma.SponsorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SponsorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          update: {
            args: Prisma.SponsorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          deleteMany: {
            args: Prisma.SponsorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SponsorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          aggregate: {
            args: Prisma.SponsorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsor>
          }
          groupBy: {
            args: Prisma.SponsorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SponsorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SponsorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SponsorCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PartnerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PartnerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      MediaPartner: {
        payload: Prisma.$MediaPartnerPayload<ExtArgs>
        fields: Prisma.MediaPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          findFirst: {
            args: Prisma.MediaPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          findMany: {
            args: Prisma.MediaPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>[]
          }
          create: {
            args: Prisma.MediaPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          createMany: {
            args: Prisma.MediaPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          update: {
            args: Prisma.MediaPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          deleteMany: {
            args: Prisma.MediaPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          aggregate: {
            args: Prisma.MediaPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaPartner>
          }
          groupBy: {
            args: Prisma.MediaPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaPartnerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MediaPartnerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MediaPartnerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MediaPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<MediaPartnerCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Enquiry: {
        payload: Prisma.$EnquiryPayload<ExtArgs>
        fields: Prisma.EnquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findFirst: {
            args: Prisma.EnquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findMany: {
            args: Prisma.EnquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          create: {
            args: Prisma.EnquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          createMany: {
            args: Prisma.EnquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EnquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          update: {
            args: Prisma.EnquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          deleteMany: {
            args: Prisma.EnquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          aggregate: {
            args: Prisma.EnquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnquiry>
          }
          groupBy: {
            args: Prisma.EnquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnquiryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EnquiryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EnquiryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EnquiryCountArgs<ExtArgs>
            result: $Utils.Optional<EnquiryCountAggregateOutputType> | number
          }
        }
      }
      UtmData: {
        payload: Prisma.$UtmDataPayload<ExtArgs>
        fields: Prisma.UtmDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtmDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtmDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          findFirst: {
            args: Prisma.UtmDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtmDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          findMany: {
            args: Prisma.UtmDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>[]
          }
          create: {
            args: Prisma.UtmDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          createMany: {
            args: Prisma.UtmDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UtmDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          update: {
            args: Prisma.UtmDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          deleteMany: {
            args: Prisma.UtmDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UtmDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UtmDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          aggregate: {
            args: Prisma.UtmDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtmData>
          }
          groupBy: {
            args: Prisma.UtmDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtmDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UtmDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UtmDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UtmDataCountArgs<ExtArgs>
            result: $Utils.Optional<UtmDataCountAggregateOutputType> | number
          }
        }
      }
      AgendaDay: {
        payload: Prisma.$AgendaDayPayload<ExtArgs>
        fields: Prisma.AgendaDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          findFirst: {
            args: Prisma.AgendaDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          findMany: {
            args: Prisma.AgendaDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>[]
          }
          create: {
            args: Prisma.AgendaDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          createMany: {
            args: Prisma.AgendaDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          update: {
            args: Prisma.AgendaDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          deleteMany: {
            args: Prisma.AgendaDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          aggregate: {
            args: Prisma.AgendaDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaDay>
          }
          groupBy: {
            args: Prisma.AgendaDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaDayGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaDayFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaDayAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaDayCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaDayCountAggregateOutputType> | number
          }
        }
      }
      AgendaSession: {
        payload: Prisma.$AgendaSessionPayload<ExtArgs>
        fields: Prisma.AgendaSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          findFirst: {
            args: Prisma.AgendaSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          findMany: {
            args: Prisma.AgendaSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>[]
          }
          create: {
            args: Prisma.AgendaSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          createMany: {
            args: Prisma.AgendaSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          update: {
            args: Prisma.AgendaSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          deleteMany: {
            args: Prisma.AgendaSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          aggregate: {
            args: Prisma.AgendaSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaSession>
          }
          groupBy: {
            args: Prisma.AgendaSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaSessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaSessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaSessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaSessionCountAggregateOutputType> | number
          }
        }
      }
      AgendaItem: {
        payload: Prisma.$AgendaItemPayload<ExtArgs>
        fields: Prisma.AgendaItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          findFirst: {
            args: Prisma.AgendaItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          findMany: {
            args: Prisma.AgendaItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>[]
          }
          create: {
            args: Prisma.AgendaItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          createMany: {
            args: Prisma.AgendaItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          update: {
            args: Prisma.AgendaItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          deleteMany: {
            args: Prisma.AgendaItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          aggregate: {
            args: Prisma.AgendaItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaItem>
          }
          groupBy: {
            args: Prisma.AgendaItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaItemCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemCountAggregateOutputType> | number
          }
        }
      }
      AgendaItemSpeaker: {
        payload: Prisma.$AgendaItemSpeakerPayload<ExtArgs>
        fields: Prisma.AgendaItemSpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaItemSpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaItemSpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          findFirst: {
            args: Prisma.AgendaItemSpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaItemSpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          findMany: {
            args: Prisma.AgendaItemSpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>[]
          }
          create: {
            args: Prisma.AgendaItemSpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          createMany: {
            args: Prisma.AgendaItemSpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaItemSpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          update: {
            args: Prisma.AgendaItemSpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          deleteMany: {
            args: Prisma.AgendaItemSpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaItemSpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaItemSpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          aggregate: {
            args: Prisma.AgendaItemSpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaItemSpeaker>
          }
          groupBy: {
            args: Prisma.AgendaItemSpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemSpeakerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaItemSpeakerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaItemSpeakerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaItemSpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemSpeakerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    project?: ProjectOmit
    projectStats?: ProjectStatsOmit
    attendee?: AttendeeOmit
    delegate?: DelegateOmit
    speaker?: SpeakerOmit
    marketingCampaign?: MarketingCampaignOmit
    lead?: LeadOmit
    session?: SessionOmit
    exhibitor?: ExhibitorOmit
    sponsor?: SponsorOmit
    partner?: PartnerOmit
    mediaPartner?: MediaPartnerOmit
    order?: OrderOmit
    enquiry?: EnquiryOmit
    utmData?: UtmDataOmit
    agendaDay?: AgendaDayOmit
    agendaSession?: AgendaSessionOmit
    agendaItem?: AgendaItemOmit
    agendaItemSpeaker?: AgendaItemSpeakerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    attendees: number
    delegates: number
    speakers: number
    marketingCampaigns: number
    leads: number
    sessions: number
    exhibitors: number
    sponsors: number
    partners: number
    mediaPartners: number
    orders: number
    enquiries: number
    utmData: number
    agendaDays: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendees?: boolean | ProjectCountOutputTypeCountAttendeesArgs
    delegates?: boolean | ProjectCountOutputTypeCountDelegatesArgs
    speakers?: boolean | ProjectCountOutputTypeCountSpeakersArgs
    marketingCampaigns?: boolean | ProjectCountOutputTypeCountMarketingCampaignsArgs
    leads?: boolean | ProjectCountOutputTypeCountLeadsArgs
    sessions?: boolean | ProjectCountOutputTypeCountSessionsArgs
    exhibitors?: boolean | ProjectCountOutputTypeCountExhibitorsArgs
    sponsors?: boolean | ProjectCountOutputTypeCountSponsorsArgs
    partners?: boolean | ProjectCountOutputTypeCountPartnersArgs
    mediaPartners?: boolean | ProjectCountOutputTypeCountMediaPartnersArgs
    orders?: boolean | ProjectCountOutputTypeCountOrdersArgs
    enquiries?: boolean | ProjectCountOutputTypeCountEnquiriesArgs
    utmData?: boolean | ProjectCountOutputTypeCountUtmDataArgs
    agendaDays?: boolean | ProjectCountOutputTypeCountAgendaDaysArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAttendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendeeWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDelegatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelegateWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMarketingCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingCampaignWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountExhibitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExhibitorWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSponsorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMediaPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaPartnerWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEnquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUtmDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtmDataWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAgendaDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaDayWhereInput
  }


  /**
   * Count Type SpeakerCountOutputType
   */

  export type SpeakerCountOutputType = {
    agendaItems: number
  }

  export type SpeakerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agendaItems?: boolean | SpeakerCountOutputTypeCountAgendaItemsArgs
  }

  // Custom InputTypes
  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCountOutputType
     */
    select?: SpeakerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeCountAgendaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemSpeakerWhereInput
  }


  /**
   * Count Type AgendaDayCountOutputType
   */

  export type AgendaDayCountOutputType = {
    sessions: number
  }

  export type AgendaDayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AgendaDayCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * AgendaDayCountOutputType without action
   */
  export type AgendaDayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDayCountOutputType
     */
    select?: AgendaDayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgendaDayCountOutputType without action
   */
  export type AgendaDayCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaSessionWhereInput
  }


  /**
   * Count Type AgendaSessionCountOutputType
   */

  export type AgendaSessionCountOutputType = {
    items: number
  }

  export type AgendaSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AgendaSessionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * AgendaSessionCountOutputType without action
   */
  export type AgendaSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSessionCountOutputType
     */
    select?: AgendaSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgendaSessionCountOutputType without action
   */
  export type AgendaSessionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemWhereInput
  }


  /**
   * Count Type AgendaItemCountOutputType
   */

  export type AgendaItemCountOutputType = {
    speakers: number
  }

  export type AgendaItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speakers?: boolean | AgendaItemCountOutputTypeCountSpeakersArgs
  }

  // Custom InputTypes
  /**
   * AgendaItemCountOutputType without action
   */
  export type AgendaItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemCountOutputType
     */
    select?: AgendaItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgendaItemCountOutputType without action
   */
  export type AgendaItemCountOutputTypeCountSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemSpeakerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    venue: string | null
    website: string | null
    image: string | null
    year: string | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    venue: string | null
    website: string | null
    image: string | null
    year: string | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    venue: number
    website: number
    image: number
    year: number
    currency: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    venue?: true
    website?: true
    image?: true
    year?: true
    currency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    venue?: true
    website?: true
    image?: true
    year?: true
    currency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    venue?: true
    website?: true
    image?: true
    year?: true
    currency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    venue: string | null
    website: string | null
    image: string | null
    year: string
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    venue?: boolean
    website?: boolean
    image?: boolean
    year?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stats?: boolean | Project$statsArgs<ExtArgs>
    attendees?: boolean | Project$attendeesArgs<ExtArgs>
    delegates?: boolean | Project$delegatesArgs<ExtArgs>
    speakers?: boolean | Project$speakersArgs<ExtArgs>
    marketingCampaigns?: boolean | Project$marketingCampaignsArgs<ExtArgs>
    leads?: boolean | Project$leadsArgs<ExtArgs>
    sessions?: boolean | Project$sessionsArgs<ExtArgs>
    exhibitors?: boolean | Project$exhibitorsArgs<ExtArgs>
    sponsors?: boolean | Project$sponsorsArgs<ExtArgs>
    partners?: boolean | Project$partnersArgs<ExtArgs>
    mediaPartners?: boolean | Project$mediaPartnersArgs<ExtArgs>
    orders?: boolean | Project$ordersArgs<ExtArgs>
    enquiries?: boolean | Project$enquiriesArgs<ExtArgs>
    utmData?: boolean | Project$utmDataArgs<ExtArgs>
    agendaDays?: boolean | Project$agendaDaysArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>



  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    venue?: boolean
    website?: boolean
    image?: boolean
    year?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "venue" | "website" | "image" | "year" | "currency" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | Project$statsArgs<ExtArgs>
    attendees?: boolean | Project$attendeesArgs<ExtArgs>
    delegates?: boolean | Project$delegatesArgs<ExtArgs>
    speakers?: boolean | Project$speakersArgs<ExtArgs>
    marketingCampaigns?: boolean | Project$marketingCampaignsArgs<ExtArgs>
    leads?: boolean | Project$leadsArgs<ExtArgs>
    sessions?: boolean | Project$sessionsArgs<ExtArgs>
    exhibitors?: boolean | Project$exhibitorsArgs<ExtArgs>
    sponsors?: boolean | Project$sponsorsArgs<ExtArgs>
    partners?: boolean | Project$partnersArgs<ExtArgs>
    mediaPartners?: boolean | Project$mediaPartnersArgs<ExtArgs>
    orders?: boolean | Project$ordersArgs<ExtArgs>
    enquiries?: boolean | Project$enquiriesArgs<ExtArgs>
    utmData?: boolean | Project$utmDataArgs<ExtArgs>
    agendaDays?: boolean | Project$agendaDaysArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      stats: Prisma.$ProjectStatsPayload<ExtArgs> | null
      attendees: Prisma.$AttendeePayload<ExtArgs>[]
      delegates: Prisma.$DelegatePayload<ExtArgs>[]
      speakers: Prisma.$SpeakerPayload<ExtArgs>[]
      marketingCampaigns: Prisma.$MarketingCampaignPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      exhibitors: Prisma.$ExhibitorPayload<ExtArgs>[]
      sponsors: Prisma.$SponsorPayload<ExtArgs>[]
      partners: Prisma.$PartnerPayload<ExtArgs>[]
      mediaPartners: Prisma.$MediaPartnerPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      enquiries: Prisma.$EnquiryPayload<ExtArgs>[]
      utmData: Prisma.$UtmDataPayload<ExtArgs>[]
      agendaDays: Prisma.$AgendaDayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      venue: string | null
      website: string | null
      image: string | null
      year: string
      currency: string | null
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * @param {ProjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const project = await prisma.project.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Project.
     * @param {ProjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const project = await prisma.project.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stats<T extends Project$statsArgs<ExtArgs> = {}>(args?: Subset<T, Project$statsArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendees<T extends Project$attendeesArgs<ExtArgs> = {}>(args?: Subset<T, Project$attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    delegates<T extends Project$delegatesArgs<ExtArgs> = {}>(args?: Subset<T, Project$delegatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    speakers<T extends Project$speakersArgs<ExtArgs> = {}>(args?: Subset<T, Project$speakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketingCampaigns<T extends Project$marketingCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Project$marketingCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Project$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Project$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends Project$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exhibitors<T extends Project$exhibitorsArgs<ExtArgs> = {}>(args?: Subset<T, Project$exhibitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sponsors<T extends Project$sponsorsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sponsorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partners<T extends Project$partnersArgs<ExtArgs> = {}>(args?: Subset<T, Project$partnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaPartners<T extends Project$mediaPartnersArgs<ExtArgs> = {}>(args?: Subset<T, Project$mediaPartnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Project$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Project$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enquiries<T extends Project$enquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$enquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    utmData<T extends Project$utmDataArgs<ExtArgs> = {}>(args?: Subset<T, Project$utmDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agendaDays<T extends Project$agendaDaysArgs<ExtArgs> = {}>(args?: Subset<T, Project$agendaDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly venue: FieldRef<"Project", 'String'>
    readonly website: FieldRef<"Project", 'String'>
    readonly image: FieldRef<"Project", 'String'>
    readonly year: FieldRef<"Project", 'String'>
    readonly currency: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project findRaw
   */
  export type ProjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Project aggregateRaw
   */
  export type ProjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Project.stats
   */
  export type Project$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    where?: ProjectStatsWhereInput
  }

  /**
   * Project.attendees
   */
  export type Project$attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    where?: AttendeeWhereInput
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    cursor?: AttendeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Project.delegates
   */
  export type Project$delegatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    where?: DelegateWhereInput
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    cursor?: DelegateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Project.speakers
   */
  export type Project$speakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    where?: SpeakerWhereInput
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    cursor?: SpeakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Project.marketingCampaigns
   */
  export type Project$marketingCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    where?: MarketingCampaignWhereInput
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    cursor?: MarketingCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * Project.leads
   */
  export type Project$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Project.sessions
   */
  export type Project$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Project.exhibitors
   */
  export type Project$exhibitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    where?: ExhibitorWhereInput
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    cursor?: ExhibitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Project.sponsors
   */
  export type Project$sponsorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    cursor?: SponsorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Project.partners
   */
  export type Project$partnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    cursor?: PartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Project.mediaPartners
   */
  export type Project$mediaPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    where?: MediaPartnerWhereInput
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    cursor?: MediaPartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * Project.orders
   */
  export type Project$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Project.enquiries
   */
  export type Project$enquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    cursor?: EnquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Project.utmData
   */
  export type Project$utmDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    where?: UtmDataWhereInput
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    cursor?: UtmDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * Project.agendaDays
   */
  export type Project$agendaDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    where?: AgendaDayWhereInput
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    cursor?: AgendaDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectStats
   */

  export type AggregateProjectStats = {
    _count: ProjectStatsCountAggregateOutputType | null
    _avg: ProjectStatsAvgAggregateOutputType | null
    _sum: ProjectStatsSumAggregateOutputType | null
    _min: ProjectStatsMinAggregateOutputType | null
    _max: ProjectStatsMaxAggregateOutputType | null
  }

  export type ProjectStatsAvgAggregateOutputType = {
    speakers: number | null
    partners: number | null
    mediaPartners: number | null
    sponsors: number | null
    exhibitors: number | null
    delegates: number | null
  }

  export type ProjectStatsSumAggregateOutputType = {
    speakers: number | null
    partners: number | null
    mediaPartners: number | null
    sponsors: number | null
    exhibitors: number | null
    delegates: number | null
  }

  export type ProjectStatsMinAggregateOutputType = {
    id: string | null
    speakers: number | null
    partners: number | null
    mediaPartners: number | null
    sponsors: number | null
    exhibitors: number | null
    delegates: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ProjectStatsMaxAggregateOutputType = {
    id: string | null
    speakers: number | null
    partners: number | null
    mediaPartners: number | null
    sponsors: number | null
    exhibitors: number | null
    delegates: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ProjectStatsCountAggregateOutputType = {
    id: number
    speakers: number
    partners: number
    mediaPartners: number
    sponsors: number
    exhibitors: number
    delegates: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ProjectStatsAvgAggregateInputType = {
    speakers?: true
    partners?: true
    mediaPartners?: true
    sponsors?: true
    exhibitors?: true
    delegates?: true
  }

  export type ProjectStatsSumAggregateInputType = {
    speakers?: true
    partners?: true
    mediaPartners?: true
    sponsors?: true
    exhibitors?: true
    delegates?: true
  }

  export type ProjectStatsMinAggregateInputType = {
    id?: true
    speakers?: true
    partners?: true
    mediaPartners?: true
    sponsors?: true
    exhibitors?: true
    delegates?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ProjectStatsMaxAggregateInputType = {
    id?: true
    speakers?: true
    partners?: true
    mediaPartners?: true
    sponsors?: true
    exhibitors?: true
    delegates?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ProjectStatsCountAggregateInputType = {
    id?: true
    speakers?: true
    partners?: true
    mediaPartners?: true
    sponsors?: true
    exhibitors?: true
    delegates?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ProjectStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStats to aggregate.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStats
    **/
    _count?: true | ProjectStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStatsMaxAggregateInputType
  }

  export type GetProjectStatsAggregateType<T extends ProjectStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStats[P]>
      : GetScalarType<T[P], AggregateProjectStats[P]>
  }




  export type ProjectStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStatsWhereInput
    orderBy?: ProjectStatsOrderByWithAggregationInput | ProjectStatsOrderByWithAggregationInput[]
    by: ProjectStatsScalarFieldEnum[] | ProjectStatsScalarFieldEnum
    having?: ProjectStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStatsCountAggregateInputType | true
    _avg?: ProjectStatsAvgAggregateInputType
    _sum?: ProjectStatsSumAggregateInputType
    _min?: ProjectStatsMinAggregateInputType
    _max?: ProjectStatsMaxAggregateInputType
  }

  export type ProjectStatsGroupByOutputType = {
    id: string
    speakers: number
    partners: number
    mediaPartners: number
    sponsors: number
    exhibitors: number
    delegates: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: ProjectStatsCountAggregateOutputType | null
    _avg: ProjectStatsAvgAggregateOutputType | null
    _sum: ProjectStatsSumAggregateOutputType | null
    _min: ProjectStatsMinAggregateOutputType | null
    _max: ProjectStatsMaxAggregateOutputType | null
  }

  type GetProjectStatsGroupByPayload<T extends ProjectStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStatsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStatsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speakers?: boolean
    partners?: boolean
    mediaPartners?: boolean
    sponsors?: boolean
    exhibitors?: boolean
    delegates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStats"]>



  export type ProjectStatsSelectScalar = {
    id?: boolean
    speakers?: boolean
    partners?: boolean
    mediaPartners?: boolean
    sponsors?: boolean
    exhibitors?: boolean
    delegates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ProjectStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "speakers" | "partners" | "mediaPartners" | "sponsors" | "exhibitors" | "delegates" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["projectStats"]>
  export type ProjectStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectStats"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      speakers: number
      partners: number
      mediaPartners: number
      sponsors: number
      exhibitors: number
      delegates: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["projectStats"]>
    composites: {}
  }

  type ProjectStatsGetPayload<S extends boolean | null | undefined | ProjectStatsDefaultArgs> = $Result.GetResult<Prisma.$ProjectStatsPayload, S>

  type ProjectStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStatsCountAggregateInputType | true
    }

  export interface ProjectStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectStats'], meta: { name: 'ProjectStats' } }
    /**
     * Find zero or one ProjectStats that matches the filter.
     * @param {ProjectStatsFindUniqueArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStatsFindUniqueArgs>(args: SelectSubset<T, ProjectStatsFindUniqueArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectStatsFindUniqueOrThrowArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsFindFirstArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStatsFindFirstArgs>(args?: SelectSubset<T, ProjectStatsFindFirstArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsFindFirstOrThrowArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStats
     * const projectStats = await prisma.projectStats.findMany()
     * 
     * // Get first 10 ProjectStats
     * const projectStats = await prisma.projectStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStatsWithIdOnly = await prisma.projectStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectStatsFindManyArgs>(args?: SelectSubset<T, ProjectStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectStats.
     * @param {ProjectStatsCreateArgs} args - Arguments to create a ProjectStats.
     * @example
     * // Create one ProjectStats
     * const ProjectStats = await prisma.projectStats.create({
     *   data: {
     *     // ... data to create a ProjectStats
     *   }
     * })
     * 
     */
    create<T extends ProjectStatsCreateArgs>(args: SelectSubset<T, ProjectStatsCreateArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectStats.
     * @param {ProjectStatsCreateManyArgs} args - Arguments to create many ProjectStats.
     * @example
     * // Create many ProjectStats
     * const projectStats = await prisma.projectStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectStatsCreateManyArgs>(args?: SelectSubset<T, ProjectStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectStats.
     * @param {ProjectStatsDeleteArgs} args - Arguments to delete one ProjectStats.
     * @example
     * // Delete one ProjectStats
     * const ProjectStats = await prisma.projectStats.delete({
     *   where: {
     *     // ... filter to delete one ProjectStats
     *   }
     * })
     * 
     */
    delete<T extends ProjectStatsDeleteArgs>(args: SelectSubset<T, ProjectStatsDeleteArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectStats.
     * @param {ProjectStatsUpdateArgs} args - Arguments to update one ProjectStats.
     * @example
     * // Update one ProjectStats
     * const projectStats = await prisma.projectStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectStatsUpdateArgs>(args: SelectSubset<T, ProjectStatsUpdateArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectStats.
     * @param {ProjectStatsDeleteManyArgs} args - Arguments to filter ProjectStats to delete.
     * @example
     * // Delete a few ProjectStats
     * const { count } = await prisma.projectStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectStatsDeleteManyArgs>(args?: SelectSubset<T, ProjectStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStats
     * const projectStats = await prisma.projectStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectStatsUpdateManyArgs>(args: SelectSubset<T, ProjectStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectStats.
     * @param {ProjectStatsUpsertArgs} args - Arguments to update or create a ProjectStats.
     * @example
     * // Update or create a ProjectStats
     * const projectStats = await prisma.projectStats.upsert({
     *   create: {
     *     // ... data to create a ProjectStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStats we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStatsUpsertArgs>(args: SelectSubset<T, ProjectStatsUpsertArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStats that matches the filter.
     * @param {ProjectStatsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const projectStats = await prisma.projectStats.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProjectStatsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProjectStats.
     * @param {ProjectStatsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const projectStats = await prisma.projectStats.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProjectStatsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsCountArgs} args - Arguments to filter ProjectStats to count.
     * @example
     * // Count the number of ProjectStats
     * const count = await prisma.projectStats.count({
     *   where: {
     *     // ... the filter for the ProjectStats we want to count
     *   }
     * })
    **/
    count<T extends ProjectStatsCountArgs>(
      args?: Subset<T, ProjectStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStatsAggregateArgs>(args: Subset<T, ProjectStatsAggregateArgs>): Prisma.PrismaPromise<GetProjectStatsAggregateType<T>>

    /**
     * Group by ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectStats model
   */
  readonly fields: ProjectStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectStats model
   */
  interface ProjectStatsFieldRefs {
    readonly id: FieldRef<"ProjectStats", 'String'>
    readonly speakers: FieldRef<"ProjectStats", 'Int'>
    readonly partners: FieldRef<"ProjectStats", 'Int'>
    readonly mediaPartners: FieldRef<"ProjectStats", 'Int'>
    readonly sponsors: FieldRef<"ProjectStats", 'Int'>
    readonly exhibitors: FieldRef<"ProjectStats", 'Int'>
    readonly delegates: FieldRef<"ProjectStats", 'Int'>
    readonly createdAt: FieldRef<"ProjectStats", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectStats", 'DateTime'>
    readonly projectId: FieldRef<"ProjectStats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectStats findUnique
   */
  export type ProjectStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats findUniqueOrThrow
   */
  export type ProjectStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats findFirst
   */
  export type ProjectStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStats.
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStats.
     */
    distinct?: ProjectStatsScalarFieldEnum | ProjectStatsScalarFieldEnum[]
  }

  /**
   * ProjectStats findFirstOrThrow
   */
  export type ProjectStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStats.
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStats.
     */
    distinct?: ProjectStatsScalarFieldEnum | ProjectStatsScalarFieldEnum[]
  }

  /**
   * ProjectStats findMany
   */
  export type ProjectStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStats.
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    distinct?: ProjectStatsScalarFieldEnum | ProjectStatsScalarFieldEnum[]
  }

  /**
   * ProjectStats create
   */
  export type ProjectStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectStats.
     */
    data: XOR<ProjectStatsCreateInput, ProjectStatsUncheckedCreateInput>
  }

  /**
   * ProjectStats createMany
   */
  export type ProjectStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectStats.
     */
    data: ProjectStatsCreateManyInput | ProjectStatsCreateManyInput[]
  }

  /**
   * ProjectStats update
   */
  export type ProjectStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectStats.
     */
    data: XOR<ProjectStatsUpdateInput, ProjectStatsUncheckedUpdateInput>
    /**
     * Choose, which ProjectStats to update.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats updateMany
   */
  export type ProjectStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectStats.
     */
    data: XOR<ProjectStatsUpdateManyMutationInput, ProjectStatsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStats to update
     */
    where?: ProjectStatsWhereInput
    /**
     * Limit how many ProjectStats to update.
     */
    limit?: number
  }

  /**
   * ProjectStats upsert
   */
  export type ProjectStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectStats to update in case it exists.
     */
    where: ProjectStatsWhereUniqueInput
    /**
     * In case the ProjectStats found by the `where` argument doesn't exist, create a new ProjectStats with this data.
     */
    create: XOR<ProjectStatsCreateInput, ProjectStatsUncheckedCreateInput>
    /**
     * In case the ProjectStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatsUpdateInput, ProjectStatsUncheckedUpdateInput>
  }

  /**
   * ProjectStats delete
   */
  export type ProjectStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
    /**
     * Filter which ProjectStats to delete.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats deleteMany
   */
  export type ProjectStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStats to delete
     */
    where?: ProjectStatsWhereInput
    /**
     * Limit how many ProjectStats to delete.
     */
    limit?: number
  }

  /**
   * ProjectStats findRaw
   */
  export type ProjectStatsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProjectStats aggregateRaw
   */
  export type ProjectStatsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProjectStats without action
   */
  export type ProjectStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatsInclude<ExtArgs> | null
  }


  /**
   * Model Attendee
   */

  export type AggregateAttendee = {
    _count: AttendeeCountAggregateOutputType | null
    _min: AttendeeMinAggregateOutputType | null
    _max: AttendeeMaxAggregateOutputType | null
  }

  export type AttendeeMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    checkedIn: boolean | null
    checkinTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type AttendeeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    checkedIn: boolean | null
    checkinTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type AttendeeCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    company: number
    jobTitle: number
    checkedIn: number
    checkinTime: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type AttendeeMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    checkedIn?: true
    checkinTime?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type AttendeeMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    checkedIn?: true
    checkinTime?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type AttendeeCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    checkedIn?: true
    checkinTime?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type AttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendee to aggregate.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendees
    **/
    _count?: true | AttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendeeMaxAggregateInputType
  }

  export type GetAttendeeAggregateType<T extends AttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendee[P]>
      : GetScalarType<T[P], AggregateAttendee[P]>
  }




  export type AttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendeeWhereInput
    orderBy?: AttendeeOrderByWithAggregationInput | AttendeeOrderByWithAggregationInput[]
    by: AttendeeScalarFieldEnum[] | AttendeeScalarFieldEnum
    having?: AttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendeeCountAggregateInputType | true
    _min?: AttendeeMinAggregateInputType
    _max?: AttendeeMaxAggregateInputType
  }

  export type AttendeeGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    company: string | null
    jobTitle: string | null
    checkedIn: boolean
    checkinTime: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: AttendeeCountAggregateOutputType | null
    _min: AttendeeMinAggregateOutputType | null
    _max: AttendeeMaxAggregateOutputType | null
  }

  type GetAttendeeGroupByPayload<T extends AttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], AttendeeGroupByOutputType[P]>
        }
      >
    >


  export type AttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendee"]>



  export type AttendeeSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type AttendeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "company" | "jobTitle" | "checkedIn" | "checkinTime" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["attendee"]>
  export type AttendeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $AttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendee"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      company: string | null
      jobTitle: string | null
      checkedIn: boolean
      checkinTime: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["attendee"]>
    composites: {}
  }

  type AttendeeGetPayload<S extends boolean | null | undefined | AttendeeDefaultArgs> = $Result.GetResult<Prisma.$AttendeePayload, S>

  type AttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendeeCountAggregateInputType | true
    }

  export interface AttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendee'], meta: { name: 'Attendee' } }
    /**
     * Find zero or one Attendee that matches the filter.
     * @param {AttendeeFindUniqueArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendeeFindUniqueArgs>(args: SelectSubset<T, AttendeeFindUniqueArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendeeFindUniqueOrThrowArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeFindFirstArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendeeFindFirstArgs>(args?: SelectSubset<T, AttendeeFindFirstArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeFindFirstOrThrowArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendees
     * const attendees = await prisma.attendee.findMany()
     * 
     * // Get first 10 Attendees
     * const attendees = await prisma.attendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendeeWithIdOnly = await prisma.attendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendeeFindManyArgs>(args?: SelectSubset<T, AttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendee.
     * @param {AttendeeCreateArgs} args - Arguments to create a Attendee.
     * @example
     * // Create one Attendee
     * const Attendee = await prisma.attendee.create({
     *   data: {
     *     // ... data to create a Attendee
     *   }
     * })
     * 
     */
    create<T extends AttendeeCreateArgs>(args: SelectSubset<T, AttendeeCreateArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendees.
     * @param {AttendeeCreateManyArgs} args - Arguments to create many Attendees.
     * @example
     * // Create many Attendees
     * const attendee = await prisma.attendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendeeCreateManyArgs>(args?: SelectSubset<T, AttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendee.
     * @param {AttendeeDeleteArgs} args - Arguments to delete one Attendee.
     * @example
     * // Delete one Attendee
     * const Attendee = await prisma.attendee.delete({
     *   where: {
     *     // ... filter to delete one Attendee
     *   }
     * })
     * 
     */
    delete<T extends AttendeeDeleteArgs>(args: SelectSubset<T, AttendeeDeleteArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendee.
     * @param {AttendeeUpdateArgs} args - Arguments to update one Attendee.
     * @example
     * // Update one Attendee
     * const attendee = await prisma.attendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendeeUpdateArgs>(args: SelectSubset<T, AttendeeUpdateArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendees.
     * @param {AttendeeDeleteManyArgs} args - Arguments to filter Attendees to delete.
     * @example
     * // Delete a few Attendees
     * const { count } = await prisma.attendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendeeDeleteManyArgs>(args?: SelectSubset<T, AttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendees
     * const attendee = await prisma.attendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendeeUpdateManyArgs>(args: SelectSubset<T, AttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendee.
     * @param {AttendeeUpsertArgs} args - Arguments to update or create a Attendee.
     * @example
     * // Update or create a Attendee
     * const attendee = await prisma.attendee.upsert({
     *   create: {
     *     // ... data to create a Attendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendee we want to update
     *   }
     * })
     */
    upsert<T extends AttendeeUpsertArgs>(args: SelectSubset<T, AttendeeUpsertArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendees that matches the filter.
     * @param {AttendeeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendee = await prisma.attendee.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AttendeeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendee.
     * @param {AttendeeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendee = await prisma.attendee.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AttendeeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeCountArgs} args - Arguments to filter Attendees to count.
     * @example
     * // Count the number of Attendees
     * const count = await prisma.attendee.count({
     *   where: {
     *     // ... the filter for the Attendees we want to count
     *   }
     * })
    **/
    count<T extends AttendeeCountArgs>(
      args?: Subset<T, AttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendeeAggregateArgs>(args: Subset<T, AttendeeAggregateArgs>): Prisma.PrismaPromise<GetAttendeeAggregateType<T>>

    /**
     * Group by Attendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendeeGroupByArgs['orderBy'] }
        : { orderBy?: AttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendee model
   */
  readonly fields: AttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendee model
   */
  interface AttendeeFieldRefs {
    readonly id: FieldRef<"Attendee", 'String'>
    readonly name: FieldRef<"Attendee", 'String'>
    readonly email: FieldRef<"Attendee", 'String'>
    readonly phone: FieldRef<"Attendee", 'String'>
    readonly company: FieldRef<"Attendee", 'String'>
    readonly jobTitle: FieldRef<"Attendee", 'String'>
    readonly checkedIn: FieldRef<"Attendee", 'Boolean'>
    readonly checkinTime: FieldRef<"Attendee", 'DateTime'>
    readonly createdAt: FieldRef<"Attendee", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendee", 'DateTime'>
    readonly projectId: FieldRef<"Attendee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attendee findUnique
   */
  export type AttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee findUniqueOrThrow
   */
  export type AttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee findFirst
   */
  export type AttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendees.
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendees.
     */
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Attendee findFirstOrThrow
   */
  export type AttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendees.
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendees.
     */
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Attendee findMany
   */
  export type AttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendees.
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Attendee create
   */
  export type AttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendee.
     */
    data: XOR<AttendeeCreateInput, AttendeeUncheckedCreateInput>
  }

  /**
   * Attendee createMany
   */
  export type AttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendees.
     */
    data: AttendeeCreateManyInput | AttendeeCreateManyInput[]
  }

  /**
   * Attendee update
   */
  export type AttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendee.
     */
    data: XOR<AttendeeUpdateInput, AttendeeUncheckedUpdateInput>
    /**
     * Choose, which Attendee to update.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee updateMany
   */
  export type AttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendees.
     */
    data: XOR<AttendeeUpdateManyMutationInput, AttendeeUncheckedUpdateManyInput>
    /**
     * Filter which Attendees to update
     */
    where?: AttendeeWhereInput
    /**
     * Limit how many Attendees to update.
     */
    limit?: number
  }

  /**
   * Attendee upsert
   */
  export type AttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendee to update in case it exists.
     */
    where: AttendeeWhereUniqueInput
    /**
     * In case the Attendee found by the `where` argument doesn't exist, create a new Attendee with this data.
     */
    create: XOR<AttendeeCreateInput, AttendeeUncheckedCreateInput>
    /**
     * In case the Attendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendeeUpdateInput, AttendeeUncheckedUpdateInput>
  }

  /**
   * Attendee delete
   */
  export type AttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
    /**
     * Filter which Attendee to delete.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee deleteMany
   */
  export type AttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendees to delete
     */
    where?: AttendeeWhereInput
    /**
     * Limit how many Attendees to delete.
     */
    limit?: number
  }

  /**
   * Attendee findRaw
   */
  export type AttendeeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendee aggregateRaw
   */
  export type AttendeeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendee without action
   */
  export type AttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendeeInclude<ExtArgs> | null
  }


  /**
   * Model Delegate
   */

  export type AggregateDelegate = {
    _count: DelegateCountAggregateOutputType | null
    _avg: DelegateAvgAggregateOutputType | null
    _sum: DelegateSumAggregateOutputType | null
    _min: DelegateMinAggregateOutputType | null
    _max: DelegateMaxAggregateOutputType | null
  }

  export type DelegateAvgAggregateOutputType = {
    priority: number | null
  }

  export type DelegateSumAggregateOutputType = {
    priority: number | null
  }

  export type DelegateMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    address: string | null
    booth: string | null
    status: string | null
    description: string | null
    priority: number | null
    featured: boolean | null
    type: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type DelegateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    address: string | null
    booth: string | null
    status: string | null
    description: string | null
    priority: number | null
    featured: boolean | null
    type: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type DelegateCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    company: number
    jobTitle: number
    address: number
    booth: number
    status: number
    description: number
    priority: number
    featured: number
    type: number
    image: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type DelegateAvgAggregateInputType = {
    priority?: true
  }

  export type DelegateSumAggregateInputType = {
    priority?: true
  }

  export type DelegateMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    address?: true
    booth?: true
    status?: true
    description?: true
    priority?: true
    featured?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type DelegateMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    address?: true
    booth?: true
    status?: true
    description?: true
    priority?: true
    featured?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type DelegateCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    address?: true
    booth?: true
    status?: true
    description?: true
    priority?: true
    featured?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type DelegateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delegate to aggregate.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Delegates
    **/
    _count?: true | DelegateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DelegateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DelegateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DelegateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DelegateMaxAggregateInputType
  }

  export type GetDelegateAggregateType<T extends DelegateAggregateArgs> = {
        [P in keyof T & keyof AggregateDelegate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelegate[P]>
      : GetScalarType<T[P], AggregateDelegate[P]>
  }




  export type DelegateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelegateWhereInput
    orderBy?: DelegateOrderByWithAggregationInput | DelegateOrderByWithAggregationInput[]
    by: DelegateScalarFieldEnum[] | DelegateScalarFieldEnum
    having?: DelegateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DelegateCountAggregateInputType | true
    _avg?: DelegateAvgAggregateInputType
    _sum?: DelegateSumAggregateInputType
    _min?: DelegateMinAggregateInputType
    _max?: DelegateMaxAggregateInputType
  }

  export type DelegateGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    address: string | null
    booth: string | null
    status: string | null
    description: string | null
    priority: number
    featured: boolean
    type: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: DelegateCountAggregateOutputType | null
    _avg: DelegateAvgAggregateOutputType | null
    _sum: DelegateSumAggregateOutputType | null
    _min: DelegateMinAggregateOutputType | null
    _max: DelegateMaxAggregateOutputType | null
  }

  type GetDelegateGroupByPayload<T extends DelegateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DelegateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DelegateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DelegateGroupByOutputType[P]>
            : GetScalarType<T[P], DelegateGroupByOutputType[P]>
        }
      >
    >


  export type DelegateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    address?: boolean
    booth?: boolean
    status?: boolean
    description?: boolean
    priority?: boolean
    featured?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delegate"]>



  export type DelegateSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    address?: boolean
    booth?: boolean
    status?: boolean
    description?: boolean
    priority?: boolean
    featured?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type DelegateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "company" | "jobTitle" | "address" | "booth" | "status" | "description" | "priority" | "featured" | "type" | "image" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["delegate"]>
  export type DelegateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $DelegatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delegate"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      company: string | null
      jobTitle: string | null
      address: string | null
      booth: string | null
      status: string | null
      description: string | null
      priority: number
      featured: boolean
      type: string
      image: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["delegate"]>
    composites: {}
  }

  type DelegateGetPayload<S extends boolean | null | undefined | DelegateDefaultArgs> = $Result.GetResult<Prisma.$DelegatePayload, S>

  type DelegateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DelegateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DelegateCountAggregateInputType | true
    }

  export interface DelegateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delegate'], meta: { name: 'Delegate' } }
    /**
     * Find zero or one Delegate that matches the filter.
     * @param {DelegateFindUniqueArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DelegateFindUniqueArgs>(args: SelectSubset<T, DelegateFindUniqueArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delegate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DelegateFindUniqueOrThrowArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DelegateFindUniqueOrThrowArgs>(args: SelectSubset<T, DelegateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delegate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateFindFirstArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DelegateFindFirstArgs>(args?: SelectSubset<T, DelegateFindFirstArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delegate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateFindFirstOrThrowArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DelegateFindFirstOrThrowArgs>(args?: SelectSubset<T, DelegateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delegates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delegates
     * const delegates = await prisma.delegate.findMany()
     * 
     * // Get first 10 Delegates
     * const delegates = await prisma.delegate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delegateWithIdOnly = await prisma.delegate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DelegateFindManyArgs>(args?: SelectSubset<T, DelegateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delegate.
     * @param {DelegateCreateArgs} args - Arguments to create a Delegate.
     * @example
     * // Create one Delegate
     * const Delegate = await prisma.delegate.create({
     *   data: {
     *     // ... data to create a Delegate
     *   }
     * })
     * 
     */
    create<T extends DelegateCreateArgs>(args: SelectSubset<T, DelegateCreateArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Delegates.
     * @param {DelegateCreateManyArgs} args - Arguments to create many Delegates.
     * @example
     * // Create many Delegates
     * const delegate = await prisma.delegate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DelegateCreateManyArgs>(args?: SelectSubset<T, DelegateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Delegate.
     * @param {DelegateDeleteArgs} args - Arguments to delete one Delegate.
     * @example
     * // Delete one Delegate
     * const Delegate = await prisma.delegate.delete({
     *   where: {
     *     // ... filter to delete one Delegate
     *   }
     * })
     * 
     */
    delete<T extends DelegateDeleteArgs>(args: SelectSubset<T, DelegateDeleteArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delegate.
     * @param {DelegateUpdateArgs} args - Arguments to update one Delegate.
     * @example
     * // Update one Delegate
     * const delegate = await prisma.delegate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DelegateUpdateArgs>(args: SelectSubset<T, DelegateUpdateArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Delegates.
     * @param {DelegateDeleteManyArgs} args - Arguments to filter Delegates to delete.
     * @example
     * // Delete a few Delegates
     * const { count } = await prisma.delegate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DelegateDeleteManyArgs>(args?: SelectSubset<T, DelegateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delegates
     * const delegate = await prisma.delegate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DelegateUpdateManyArgs>(args: SelectSubset<T, DelegateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delegate.
     * @param {DelegateUpsertArgs} args - Arguments to update or create a Delegate.
     * @example
     * // Update or create a Delegate
     * const delegate = await prisma.delegate.upsert({
     *   create: {
     *     // ... data to create a Delegate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delegate we want to update
     *   }
     * })
     */
    upsert<T extends DelegateUpsertArgs>(args: SelectSubset<T, DelegateUpsertArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delegates that matches the filter.
     * @param {DelegateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const delegate = await prisma.delegate.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DelegateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Delegate.
     * @param {DelegateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const delegate = await prisma.delegate.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DelegateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateCountArgs} args - Arguments to filter Delegates to count.
     * @example
     * // Count the number of Delegates
     * const count = await prisma.delegate.count({
     *   where: {
     *     // ... the filter for the Delegates we want to count
     *   }
     * })
    **/
    count<T extends DelegateCountArgs>(
      args?: Subset<T, DelegateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DelegateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delegate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DelegateAggregateArgs>(args: Subset<T, DelegateAggregateArgs>): Prisma.PrismaPromise<GetDelegateAggregateType<T>>

    /**
     * Group by Delegate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DelegateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DelegateGroupByArgs['orderBy'] }
        : { orderBy?: DelegateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DelegateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelegateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delegate model
   */
  readonly fields: DelegateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delegate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DelegateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delegate model
   */
  interface DelegateFieldRefs {
    readonly id: FieldRef<"Delegate", 'String'>
    readonly name: FieldRef<"Delegate", 'String'>
    readonly email: FieldRef<"Delegate", 'String'>
    readonly phone: FieldRef<"Delegate", 'String'>
    readonly company: FieldRef<"Delegate", 'String'>
    readonly jobTitle: FieldRef<"Delegate", 'String'>
    readonly address: FieldRef<"Delegate", 'String'>
    readonly booth: FieldRef<"Delegate", 'String'>
    readonly status: FieldRef<"Delegate", 'String'>
    readonly description: FieldRef<"Delegate", 'String'>
    readonly priority: FieldRef<"Delegate", 'Int'>
    readonly featured: FieldRef<"Delegate", 'Boolean'>
    readonly type: FieldRef<"Delegate", 'String'>
    readonly image: FieldRef<"Delegate", 'String'>
    readonly createdAt: FieldRef<"Delegate", 'DateTime'>
    readonly updatedAt: FieldRef<"Delegate", 'DateTime'>
    readonly projectId: FieldRef<"Delegate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Delegate findUnique
   */
  export type DelegateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate findUniqueOrThrow
   */
  export type DelegateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate findFirst
   */
  export type DelegateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delegates.
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delegates.
     */
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Delegate findFirstOrThrow
   */
  export type DelegateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delegates.
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delegates.
     */
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Delegate findMany
   */
  export type DelegateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Delegates.
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Delegate create
   */
  export type DelegateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * The data needed to create a Delegate.
     */
    data: XOR<DelegateCreateInput, DelegateUncheckedCreateInput>
  }

  /**
   * Delegate createMany
   */
  export type DelegateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Delegates.
     */
    data: DelegateCreateManyInput | DelegateCreateManyInput[]
  }

  /**
   * Delegate update
   */
  export type DelegateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * The data needed to update a Delegate.
     */
    data: XOR<DelegateUpdateInput, DelegateUncheckedUpdateInput>
    /**
     * Choose, which Delegate to update.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate updateMany
   */
  export type DelegateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Delegates.
     */
    data: XOR<DelegateUpdateManyMutationInput, DelegateUncheckedUpdateManyInput>
    /**
     * Filter which Delegates to update
     */
    where?: DelegateWhereInput
    /**
     * Limit how many Delegates to update.
     */
    limit?: number
  }

  /**
   * Delegate upsert
   */
  export type DelegateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * The filter to search for the Delegate to update in case it exists.
     */
    where: DelegateWhereUniqueInput
    /**
     * In case the Delegate found by the `where` argument doesn't exist, create a new Delegate with this data.
     */
    create: XOR<DelegateCreateInput, DelegateUncheckedCreateInput>
    /**
     * In case the Delegate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DelegateUpdateInput, DelegateUncheckedUpdateInput>
  }

  /**
   * Delegate delete
   */
  export type DelegateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
    /**
     * Filter which Delegate to delete.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate deleteMany
   */
  export type DelegateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delegates to delete
     */
    where?: DelegateWhereInput
    /**
     * Limit how many Delegates to delete.
     */
    limit?: number
  }

  /**
   * Delegate findRaw
   */
  export type DelegateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Delegate aggregateRaw
   */
  export type DelegateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Delegate without action
   */
  export type DelegateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelegateInclude<ExtArgs> | null
  }


  /**
   * Model Speaker
   */

  export type AggregateSpeaker = {
    _count: SpeakerCountAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  export type SpeakerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    position: string | null
    bio: string | null
    featured: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SpeakerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    position: string | null
    bio: string | null
    featured: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SpeakerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    company: number
    position: number
    bio: number
    featured: number
    image: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type SpeakerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    position?: true
    bio?: true
    featured?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SpeakerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    position?: true
    bio?: true
    featured?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SpeakerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    position?: true
    bio?: true
    featured?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type SpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speaker to aggregate.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Speakers
    **/
    _count?: true | SpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakerMaxAggregateInputType
  }

  export type GetSpeakerAggregateType<T extends SpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeaker[P]>
      : GetScalarType<T[P], AggregateSpeaker[P]>
  }




  export type SpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerWhereInput
    orderBy?: SpeakerOrderByWithAggregationInput | SpeakerOrderByWithAggregationInput[]
    by: SpeakerScalarFieldEnum[] | SpeakerScalarFieldEnum
    having?: SpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakerCountAggregateInputType | true
    _min?: SpeakerMinAggregateInputType
    _max?: SpeakerMaxAggregateInputType
  }

  export type SpeakerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    company: string | null
    position: string | null
    bio: string | null
    featured: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: SpeakerCountAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  type GetSpeakerGroupByPayload<T extends SpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
        }
      >
    >


  export type SpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    position?: boolean
    bio?: boolean
    featured?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agendaItems?: boolean | Speaker$agendaItemsArgs<ExtArgs>
    _count?: boolean | SpeakerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speaker"]>



  export type SpeakerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    position?: boolean
    bio?: boolean
    featured?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type SpeakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "company" | "position" | "bio" | "featured" | "image" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["speaker"]>
  export type SpeakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agendaItems?: boolean | Speaker$agendaItemsArgs<ExtArgs>
    _count?: boolean | SpeakerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Speaker"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      agendaItems: Prisma.$AgendaItemSpeakerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      company: string | null
      position: string | null
      bio: string | null
      featured: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["speaker"]>
    composites: {}
  }

  type SpeakerGetPayload<S extends boolean | null | undefined | SpeakerDefaultArgs> = $Result.GetResult<Prisma.$SpeakerPayload, S>

  type SpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakerCountAggregateInputType | true
    }

  export interface SpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Speaker'], meta: { name: 'Speaker' } }
    /**
     * Find zero or one Speaker that matches the filter.
     * @param {SpeakerFindUniqueArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakerFindUniqueArgs>(args: SelectSubset<T, SpeakerFindUniqueArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Speaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakerFindUniqueOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakerFindFirstArgs>(args?: SelectSubset<T, SpeakerFindFirstArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speaker.findMany()
     * 
     * // Get first 10 Speakers
     * const speakers = await prisma.speaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakerWithIdOnly = await prisma.speaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakerFindManyArgs>(args?: SelectSubset<T, SpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Speaker.
     * @param {SpeakerCreateArgs} args - Arguments to create a Speaker.
     * @example
     * // Create one Speaker
     * const Speaker = await prisma.speaker.create({
     *   data: {
     *     // ... data to create a Speaker
     *   }
     * })
     * 
     */
    create<T extends SpeakerCreateArgs>(args: SelectSubset<T, SpeakerCreateArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Speakers.
     * @param {SpeakerCreateManyArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speaker = await prisma.speaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakerCreateManyArgs>(args?: SelectSubset<T, SpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Speaker.
     * @param {SpeakerDeleteArgs} args - Arguments to delete one Speaker.
     * @example
     * // Delete one Speaker
     * const Speaker = await prisma.speaker.delete({
     *   where: {
     *     // ... filter to delete one Speaker
     *   }
     * })
     * 
     */
    delete<T extends SpeakerDeleteArgs>(args: SelectSubset<T, SpeakerDeleteArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Speaker.
     * @param {SpeakerUpdateArgs} args - Arguments to update one Speaker.
     * @example
     * // Update one Speaker
     * const speaker = await prisma.speaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakerUpdateArgs>(args: SelectSubset<T, SpeakerUpdateArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Speakers.
     * @param {SpeakerDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakerDeleteManyArgs>(args?: SelectSubset<T, SpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakerUpdateManyArgs>(args: SelectSubset<T, SpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Speaker.
     * @param {SpeakerUpsertArgs} args - Arguments to update or create a Speaker.
     * @example
     * // Update or create a Speaker
     * const speaker = await prisma.speaker.upsert({
     *   create: {
     *     // ... data to create a Speaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speaker we want to update
     *   }
     * })
     */
    upsert<T extends SpeakerUpsertArgs>(args: SelectSubset<T, SpeakerUpsertArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * @param {SpeakerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const speaker = await prisma.speaker.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SpeakerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Speaker.
     * @param {SpeakerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const speaker = await prisma.speaker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpeakerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speaker.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
    **/
    count<T extends SpeakerCountArgs>(
      args?: Subset<T, SpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakerAggregateArgs>(args: Subset<T, SpeakerAggregateArgs>): Prisma.PrismaPromise<GetSpeakerAggregateType<T>>

    /**
     * Group by Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Speaker model
   */
  readonly fields: SpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agendaItems<T extends Speaker$agendaItemsArgs<ExtArgs> = {}>(args?: Subset<T, Speaker$agendaItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Speaker model
   */
  interface SpeakerFieldRefs {
    readonly id: FieldRef<"Speaker", 'String'>
    readonly name: FieldRef<"Speaker", 'String'>
    readonly email: FieldRef<"Speaker", 'String'>
    readonly phone: FieldRef<"Speaker", 'String'>
    readonly company: FieldRef<"Speaker", 'String'>
    readonly position: FieldRef<"Speaker", 'String'>
    readonly bio: FieldRef<"Speaker", 'String'>
    readonly featured: FieldRef<"Speaker", 'Boolean'>
    readonly image: FieldRef<"Speaker", 'String'>
    readonly createdAt: FieldRef<"Speaker", 'DateTime'>
    readonly updatedAt: FieldRef<"Speaker", 'DateTime'>
    readonly projectId: FieldRef<"Speaker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Speaker findUnique
   */
  export type SpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker findUniqueOrThrow
   */
  export type SpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker findFirst
   */
  export type SpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker findFirstOrThrow
   */
  export type SpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker findMany
   */
  export type SpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker create
   */
  export type SpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * The data needed to create a Speaker.
     */
    data: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
  }

  /**
   * Speaker createMany
   */
  export type SpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Speakers.
     */
    data: SpeakerCreateManyInput | SpeakerCreateManyInput[]
  }

  /**
   * Speaker update
   */
  export type SpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * The data needed to update a Speaker.
     */
    data: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
    /**
     * Choose, which Speaker to update.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker updateMany
   */
  export type SpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>
    /**
     * Filter which Speakers to update
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to update.
     */
    limit?: number
  }

  /**
   * Speaker upsert
   */
  export type SpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * The filter to search for the Speaker to update in case it exists.
     */
    where: SpeakerWhereUniqueInput
    /**
     * In case the Speaker found by the `where` argument doesn't exist, create a new Speaker with this data.
     */
    create: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
    /**
     * In case the Speaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
  }

  /**
   * Speaker delete
   */
  export type SpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter which Speaker to delete.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker deleteMany
   */
  export type SpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speakers to delete
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to delete.
     */
    limit?: number
  }

  /**
   * Speaker findRaw
   */
  export type SpeakerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Speaker aggregateRaw
   */
  export type SpeakerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Speaker.agendaItems
   */
  export type Speaker$agendaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    where?: AgendaItemSpeakerWhereInput
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    cursor?: AgendaItemSpeakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * Speaker without action
   */
  export type SpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
  }


  /**
   * Model MarketingCampaign
   */

  export type AggregateMarketingCampaign = {
    _count: MarketingCampaignCountAggregateOutputType | null
    _avg: MarketingCampaignAvgAggregateOutputType | null
    _sum: MarketingCampaignSumAggregateOutputType | null
    _min: MarketingCampaignMinAggregateOutputType | null
    _max: MarketingCampaignMaxAggregateOutputType | null
  }

  export type MarketingCampaignAvgAggregateOutputType = {
    total: number | null
    revenue: number | null
  }

  export type MarketingCampaignSumAggregateOutputType = {
    total: number | null
    revenue: number | null
  }

  export type MarketingCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    total: number | null
    revenue: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type MarketingCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    total: number | null
    revenue: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type MarketingCampaignCountAggregateOutputType = {
    id: number
    name: number
    type: number
    total: number
    revenue: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type MarketingCampaignAvgAggregateInputType = {
    total?: true
    revenue?: true
  }

  export type MarketingCampaignSumAggregateInputType = {
    total?: true
    revenue?: true
  }

  export type MarketingCampaignMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    total?: true
    revenue?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type MarketingCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    total?: true
    revenue?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type MarketingCampaignCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    total?: true
    revenue?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type MarketingCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingCampaign to aggregate.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingCampaigns
    **/
    _count?: true | MarketingCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketingCampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketingCampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingCampaignMaxAggregateInputType
  }

  export type GetMarketingCampaignAggregateType<T extends MarketingCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingCampaign[P]>
      : GetScalarType<T[P], AggregateMarketingCampaign[P]>
  }




  export type MarketingCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingCampaignWhereInput
    orderBy?: MarketingCampaignOrderByWithAggregationInput | MarketingCampaignOrderByWithAggregationInput[]
    by: MarketingCampaignScalarFieldEnum[] | MarketingCampaignScalarFieldEnum
    having?: MarketingCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingCampaignCountAggregateInputType | true
    _avg?: MarketingCampaignAvgAggregateInputType
    _sum?: MarketingCampaignSumAggregateInputType
    _min?: MarketingCampaignMinAggregateInputType
    _max?: MarketingCampaignMaxAggregateInputType
  }

  export type MarketingCampaignGroupByOutputType = {
    id: string
    name: string
    type: string
    total: number
    revenue: number
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: MarketingCampaignCountAggregateOutputType | null
    _avg: MarketingCampaignAvgAggregateOutputType | null
    _sum: MarketingCampaignSumAggregateOutputType | null
    _min: MarketingCampaignMinAggregateOutputType | null
    _max: MarketingCampaignMaxAggregateOutputType | null
  }

  type GetMarketingCampaignGroupByPayload<T extends MarketingCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingCampaignGroupByOutputType[P]>
        }
      >
    >


  export type MarketingCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    total?: boolean
    revenue?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingCampaign"]>



  export type MarketingCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    total?: boolean
    revenue?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type MarketingCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "total" | "revenue" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["marketingCampaign"]>
  export type MarketingCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MarketingCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingCampaign"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      total: number
      revenue: number
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["marketingCampaign"]>
    composites: {}
  }

  type MarketingCampaignGetPayload<S extends boolean | null | undefined | MarketingCampaignDefaultArgs> = $Result.GetResult<Prisma.$MarketingCampaignPayload, S>

  type MarketingCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingCampaignCountAggregateInputType | true
    }

  export interface MarketingCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingCampaign'], meta: { name: 'MarketingCampaign' } }
    /**
     * Find zero or one MarketingCampaign that matches the filter.
     * @param {MarketingCampaignFindUniqueArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingCampaignFindUniqueArgs>(args: SelectSubset<T, MarketingCampaignFindUniqueArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingCampaignFindUniqueOrThrowArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignFindFirstArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingCampaignFindFirstArgs>(args?: SelectSubset<T, MarketingCampaignFindFirstArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignFindFirstOrThrowArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingCampaigns
     * const marketingCampaigns = await prisma.marketingCampaign.findMany()
     * 
     * // Get first 10 MarketingCampaigns
     * const marketingCampaigns = await prisma.marketingCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingCampaignWithIdOnly = await prisma.marketingCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingCampaignFindManyArgs>(args?: SelectSubset<T, MarketingCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingCampaign.
     * @param {MarketingCampaignCreateArgs} args - Arguments to create a MarketingCampaign.
     * @example
     * // Create one MarketingCampaign
     * const MarketingCampaign = await prisma.marketingCampaign.create({
     *   data: {
     *     // ... data to create a MarketingCampaign
     *   }
     * })
     * 
     */
    create<T extends MarketingCampaignCreateArgs>(args: SelectSubset<T, MarketingCampaignCreateArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingCampaigns.
     * @param {MarketingCampaignCreateManyArgs} args - Arguments to create many MarketingCampaigns.
     * @example
     * // Create many MarketingCampaigns
     * const marketingCampaign = await prisma.marketingCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingCampaignCreateManyArgs>(args?: SelectSubset<T, MarketingCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketingCampaign.
     * @param {MarketingCampaignDeleteArgs} args - Arguments to delete one MarketingCampaign.
     * @example
     * // Delete one MarketingCampaign
     * const MarketingCampaign = await prisma.marketingCampaign.delete({
     *   where: {
     *     // ... filter to delete one MarketingCampaign
     *   }
     * })
     * 
     */
    delete<T extends MarketingCampaignDeleteArgs>(args: SelectSubset<T, MarketingCampaignDeleteArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingCampaign.
     * @param {MarketingCampaignUpdateArgs} args - Arguments to update one MarketingCampaign.
     * @example
     * // Update one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingCampaignUpdateArgs>(args: SelectSubset<T, MarketingCampaignUpdateArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingCampaigns.
     * @param {MarketingCampaignDeleteManyArgs} args - Arguments to filter MarketingCampaigns to delete.
     * @example
     * // Delete a few MarketingCampaigns
     * const { count } = await prisma.marketingCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingCampaignDeleteManyArgs>(args?: SelectSubset<T, MarketingCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingCampaigns
     * const marketingCampaign = await prisma.marketingCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingCampaignUpdateManyArgs>(args: SelectSubset<T, MarketingCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketingCampaign.
     * @param {MarketingCampaignUpsertArgs} args - Arguments to update or create a MarketingCampaign.
     * @example
     * // Update or create a MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.upsert({
     *   create: {
     *     // ... data to create a MarketingCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingCampaign we want to update
     *   }
     * })
     */
    upsert<T extends MarketingCampaignUpsertArgs>(args: SelectSubset<T, MarketingCampaignUpsertArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingCampaigns that matches the filter.
     * @param {MarketingCampaignFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const marketingCampaign = await prisma.marketingCampaign.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MarketingCampaignFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MarketingCampaign.
     * @param {MarketingCampaignAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const marketingCampaign = await prisma.marketingCampaign.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MarketingCampaignAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MarketingCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignCountArgs} args - Arguments to filter MarketingCampaigns to count.
     * @example
     * // Count the number of MarketingCampaigns
     * const count = await prisma.marketingCampaign.count({
     *   where: {
     *     // ... the filter for the MarketingCampaigns we want to count
     *   }
     * })
    **/
    count<T extends MarketingCampaignCountArgs>(
      args?: Subset<T, MarketingCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingCampaignAggregateArgs>(args: Subset<T, MarketingCampaignAggregateArgs>): Prisma.PrismaPromise<GetMarketingCampaignAggregateType<T>>

    /**
     * Group by MarketingCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingCampaignGroupByArgs['orderBy'] }
        : { orderBy?: MarketingCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingCampaign model
   */
  readonly fields: MarketingCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingCampaign model
   */
  interface MarketingCampaignFieldRefs {
    readonly id: FieldRef<"MarketingCampaign", 'String'>
    readonly name: FieldRef<"MarketingCampaign", 'String'>
    readonly type: FieldRef<"MarketingCampaign", 'String'>
    readonly total: FieldRef<"MarketingCampaign", 'Int'>
    readonly revenue: FieldRef<"MarketingCampaign", 'Float'>
    readonly startDate: FieldRef<"MarketingCampaign", 'DateTime'>
    readonly endDate: FieldRef<"MarketingCampaign", 'DateTime'>
    readonly createdAt: FieldRef<"MarketingCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingCampaign", 'DateTime'>
    readonly projectId: FieldRef<"MarketingCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MarketingCampaign findUnique
   */
  export type MarketingCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign findUniqueOrThrow
   */
  export type MarketingCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign findFirst
   */
  export type MarketingCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingCampaigns.
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingCampaigns.
     */
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * MarketingCampaign findFirstOrThrow
   */
  export type MarketingCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingCampaigns.
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingCampaigns.
     */
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * MarketingCampaign findMany
   */
  export type MarketingCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MarketingCampaigns to fetch.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingCampaigns.
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * MarketingCampaign create
   */
  export type MarketingCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingCampaign.
     */
    data: XOR<MarketingCampaignCreateInput, MarketingCampaignUncheckedCreateInput>
  }

  /**
   * MarketingCampaign createMany
   */
  export type MarketingCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingCampaigns.
     */
    data: MarketingCampaignCreateManyInput | MarketingCampaignCreateManyInput[]
  }

  /**
   * MarketingCampaign update
   */
  export type MarketingCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingCampaign.
     */
    data: XOR<MarketingCampaignUpdateInput, MarketingCampaignUncheckedUpdateInput>
    /**
     * Choose, which MarketingCampaign to update.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign updateMany
   */
  export type MarketingCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingCampaigns.
     */
    data: XOR<MarketingCampaignUpdateManyMutationInput, MarketingCampaignUncheckedUpdateManyInput>
    /**
     * Filter which MarketingCampaigns to update
     */
    where?: MarketingCampaignWhereInput
    /**
     * Limit how many MarketingCampaigns to update.
     */
    limit?: number
  }

  /**
   * MarketingCampaign upsert
   */
  export type MarketingCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingCampaign to update in case it exists.
     */
    where: MarketingCampaignWhereUniqueInput
    /**
     * In case the MarketingCampaign found by the `where` argument doesn't exist, create a new MarketingCampaign with this data.
     */
    create: XOR<MarketingCampaignCreateInput, MarketingCampaignUncheckedCreateInput>
    /**
     * In case the MarketingCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingCampaignUpdateInput, MarketingCampaignUncheckedUpdateInput>
  }

  /**
   * MarketingCampaign delete
   */
  export type MarketingCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
    /**
     * Filter which MarketingCampaign to delete.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign deleteMany
   */
  export type MarketingCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingCampaigns to delete
     */
    where?: MarketingCampaignWhereInput
    /**
     * Limit how many MarketingCampaigns to delete.
     */
    limit?: number
  }

  /**
   * MarketingCampaign findRaw
   */
  export type MarketingCampaignFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketingCampaign aggregateRaw
   */
  export type MarketingCampaignAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketingCampaign without action
   */
  export type MarketingCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingCampaignInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    contact: string | null
    company: string | null
    type: string | null
    date: Date | null
    qualifyStatus: string | null
    salesStatus: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    contact: string | null
    company: string | null
    type: string | null
    date: Date | null
    qualifyStatus: string | null
    salesStatus: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    name: number
    email: number
    contact: number
    company: number
    type: number
    date: number
    qualifyStatus: number
    salesStatus: number
    notes: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    contact?: true
    company?: true
    type?: true
    date?: true
    qualifyStatus?: true
    salesStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    contact?: true
    company?: true
    type?: true
    date?: true
    qualifyStatus?: true
    salesStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    contact?: true
    company?: true
    type?: true
    date?: true
    qualifyStatus?: true
    salesStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    name: string
    email: string
    contact: string | null
    company: string | null
    type: string | null
    date: Date | null
    qualifyStatus: string | null
    salesStatus: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    company?: boolean
    type?: boolean
    date?: boolean
    qualifyStatus?: boolean
    salesStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>



  export type LeadSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    contact?: boolean
    company?: boolean
    type?: boolean
    date?: boolean
    qualifyStatus?: boolean
    salesStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "contact" | "company" | "type" | "date" | "qualifyStatus" | "salesStatus" | "notes" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      contact: string | null
      company: string | null
      type: string | null
      date: Date | null
      qualifyStatus: string | null
      salesStatus: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * @param {LeadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const lead = await prisma.lead.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LeadFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Lead.
     * @param {LeadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const lead = await prisma.lead.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LeadAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly contact: FieldRef<"Lead", 'String'>
    readonly company: FieldRef<"Lead", 'String'>
    readonly type: FieldRef<"Lead", 'String'>
    readonly date: FieldRef<"Lead", 'DateTime'>
    readonly qualifyStatus: FieldRef<"Lead", 'String'>
    readonly salesStatus: FieldRef<"Lead", 'String'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly projectId: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead findRaw
   */
  export type LeadFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lead aggregateRaw
   */
  export type LeadAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    day: number | null
  }

  export type SessionSumAggregateOutputType = {
    day: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    date: Date | null
    venue: string | null
    day: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    date: Date | null
    venue: string | null
    day: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startTime: number
    endTime: number
    date: number
    venue: number
    day: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    day?: true
  }

  export type SessionSumAggregateInputType = {
    day?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    date?: true
    venue?: true
    day?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    date?: true
    venue?: true
    day?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    date?: true
    venue?: true
    day?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startTime: string
    endTime: string
    date: Date | null
    venue: string | null
    day: number | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    date?: boolean
    venue?: boolean
    day?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    date?: boolean
    venue?: boolean
    day?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startTime" | "endTime" | "date" | "venue" | "day" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startTime: string
      endTime: string
      date: Date | null
      venue: string | null
      day: number | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly title: FieldRef<"Session", 'String'>
    readonly description: FieldRef<"Session", 'String'>
    readonly startTime: FieldRef<"Session", 'String'>
    readonly endTime: FieldRef<"Session", 'String'>
    readonly date: FieldRef<"Session", 'DateTime'>
    readonly venue: FieldRef<"Session", 'String'>
    readonly day: FieldRef<"Session", 'Int'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly projectId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Exhibitor
   */

  export type AggregateExhibitor = {
    _count: ExhibitorCountAggregateOutputType | null
    _min: ExhibitorMinAggregateOutputType | null
    _max: ExhibitorMaxAggregateOutputType | null
  }

  export type ExhibitorMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    boothNumber: string | null
    category: string | null
    status: string | null
    size: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ExhibitorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    boothNumber: string | null
    category: string | null
    status: string | null
    size: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ExhibitorCountAggregateOutputType = {
    id: number
    name: number
    image: number
    boothNumber: number
    category: number
    status: number
    size: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ExhibitorMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    boothNumber?: true
    category?: true
    status?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ExhibitorMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    boothNumber?: true
    category?: true
    status?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ExhibitorCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    boothNumber?: true
    category?: true
    status?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ExhibitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exhibitor to aggregate.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exhibitors
    **/
    _count?: true | ExhibitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExhibitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExhibitorMaxAggregateInputType
  }

  export type GetExhibitorAggregateType<T extends ExhibitorAggregateArgs> = {
        [P in keyof T & keyof AggregateExhibitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibitor[P]>
      : GetScalarType<T[P], AggregateExhibitor[P]>
  }




  export type ExhibitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExhibitorWhereInput
    orderBy?: ExhibitorOrderByWithAggregationInput | ExhibitorOrderByWithAggregationInput[]
    by: ExhibitorScalarFieldEnum[] | ExhibitorScalarFieldEnum
    having?: ExhibitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExhibitorCountAggregateInputType | true
    _min?: ExhibitorMinAggregateInputType
    _max?: ExhibitorMaxAggregateInputType
  }

  export type ExhibitorGroupByOutputType = {
    id: string
    name: string
    image: string | null
    boothNumber: string | null
    category: string | null
    status: string | null
    size: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: ExhibitorCountAggregateOutputType | null
    _min: ExhibitorMinAggregateOutputType | null
    _max: ExhibitorMaxAggregateOutputType | null
  }

  type GetExhibitorGroupByPayload<T extends ExhibitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExhibitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExhibitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExhibitorGroupByOutputType[P]>
            : GetScalarType<T[P], ExhibitorGroupByOutputType[P]>
        }
      >
    >


  export type ExhibitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    boothNumber?: boolean
    category?: boolean
    status?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exhibitor"]>



  export type ExhibitorSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    boothNumber?: boolean
    category?: boolean
    status?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ExhibitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "boothNumber" | "category" | "status" | "size" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["exhibitor"]>
  export type ExhibitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ExhibitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exhibitor"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string | null
      boothNumber: string | null
      category: string | null
      status: string | null
      size: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["exhibitor"]>
    composites: {}
  }

  type ExhibitorGetPayload<S extends boolean | null | undefined | ExhibitorDefaultArgs> = $Result.GetResult<Prisma.$ExhibitorPayload, S>

  type ExhibitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExhibitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExhibitorCountAggregateInputType | true
    }

  export interface ExhibitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exhibitor'], meta: { name: 'Exhibitor' } }
    /**
     * Find zero or one Exhibitor that matches the filter.
     * @param {ExhibitorFindUniqueArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExhibitorFindUniqueArgs>(args: SelectSubset<T, ExhibitorFindUniqueArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exhibitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExhibitorFindUniqueOrThrowArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExhibitorFindUniqueOrThrowArgs>(args: SelectSubset<T, ExhibitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorFindFirstArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExhibitorFindFirstArgs>(args?: SelectSubset<T, ExhibitorFindFirstArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorFindFirstOrThrowArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExhibitorFindFirstOrThrowArgs>(args?: SelectSubset<T, ExhibitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exhibitors
     * const exhibitors = await prisma.exhibitor.findMany()
     * 
     * // Get first 10 Exhibitors
     * const exhibitors = await prisma.exhibitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exhibitorWithIdOnly = await prisma.exhibitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExhibitorFindManyArgs>(args?: SelectSubset<T, ExhibitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exhibitor.
     * @param {ExhibitorCreateArgs} args - Arguments to create a Exhibitor.
     * @example
     * // Create one Exhibitor
     * const Exhibitor = await prisma.exhibitor.create({
     *   data: {
     *     // ... data to create a Exhibitor
     *   }
     * })
     * 
     */
    create<T extends ExhibitorCreateArgs>(args: SelectSubset<T, ExhibitorCreateArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exhibitors.
     * @param {ExhibitorCreateManyArgs} args - Arguments to create many Exhibitors.
     * @example
     * // Create many Exhibitors
     * const exhibitor = await prisma.exhibitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExhibitorCreateManyArgs>(args?: SelectSubset<T, ExhibitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exhibitor.
     * @param {ExhibitorDeleteArgs} args - Arguments to delete one Exhibitor.
     * @example
     * // Delete one Exhibitor
     * const Exhibitor = await prisma.exhibitor.delete({
     *   where: {
     *     // ... filter to delete one Exhibitor
     *   }
     * })
     * 
     */
    delete<T extends ExhibitorDeleteArgs>(args: SelectSubset<T, ExhibitorDeleteArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exhibitor.
     * @param {ExhibitorUpdateArgs} args - Arguments to update one Exhibitor.
     * @example
     * // Update one Exhibitor
     * const exhibitor = await prisma.exhibitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExhibitorUpdateArgs>(args: SelectSubset<T, ExhibitorUpdateArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exhibitors.
     * @param {ExhibitorDeleteManyArgs} args - Arguments to filter Exhibitors to delete.
     * @example
     * // Delete a few Exhibitors
     * const { count } = await prisma.exhibitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExhibitorDeleteManyArgs>(args?: SelectSubset<T, ExhibitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exhibitors
     * const exhibitor = await prisma.exhibitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExhibitorUpdateManyArgs>(args: SelectSubset<T, ExhibitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exhibitor.
     * @param {ExhibitorUpsertArgs} args - Arguments to update or create a Exhibitor.
     * @example
     * // Update or create a Exhibitor
     * const exhibitor = await prisma.exhibitor.upsert({
     *   create: {
     *     // ... data to create a Exhibitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exhibitor we want to update
     *   }
     * })
     */
    upsert<T extends ExhibitorUpsertArgs>(args: SelectSubset<T, ExhibitorUpsertArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * @param {ExhibitorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const exhibitor = await prisma.exhibitor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExhibitorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Exhibitor.
     * @param {ExhibitorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const exhibitor = await prisma.exhibitor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExhibitorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorCountArgs} args - Arguments to filter Exhibitors to count.
     * @example
     * // Count the number of Exhibitors
     * const count = await prisma.exhibitor.count({
     *   where: {
     *     // ... the filter for the Exhibitors we want to count
     *   }
     * })
    **/
    count<T extends ExhibitorCountArgs>(
      args?: Subset<T, ExhibitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExhibitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exhibitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExhibitorAggregateArgs>(args: Subset<T, ExhibitorAggregateArgs>): Prisma.PrismaPromise<GetExhibitorAggregateType<T>>

    /**
     * Group by Exhibitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExhibitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExhibitorGroupByArgs['orderBy'] }
        : { orderBy?: ExhibitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExhibitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExhibitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exhibitor model
   */
  readonly fields: ExhibitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exhibitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExhibitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exhibitor model
   */
  interface ExhibitorFieldRefs {
    readonly id: FieldRef<"Exhibitor", 'String'>
    readonly name: FieldRef<"Exhibitor", 'String'>
    readonly image: FieldRef<"Exhibitor", 'String'>
    readonly boothNumber: FieldRef<"Exhibitor", 'String'>
    readonly category: FieldRef<"Exhibitor", 'String'>
    readonly status: FieldRef<"Exhibitor", 'String'>
    readonly size: FieldRef<"Exhibitor", 'String'>
    readonly createdAt: FieldRef<"Exhibitor", 'DateTime'>
    readonly updatedAt: FieldRef<"Exhibitor", 'DateTime'>
    readonly projectId: FieldRef<"Exhibitor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Exhibitor findUnique
   */
  export type ExhibitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor findUniqueOrThrow
   */
  export type ExhibitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor findFirst
   */
  export type ExhibitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exhibitors.
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exhibitors.
     */
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Exhibitor findFirstOrThrow
   */
  export type ExhibitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exhibitors.
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exhibitors.
     */
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Exhibitor findMany
   */
  export type ExhibitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exhibitors.
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Exhibitor create
   */
  export type ExhibitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * The data needed to create a Exhibitor.
     */
    data: XOR<ExhibitorCreateInput, ExhibitorUncheckedCreateInput>
  }

  /**
   * Exhibitor createMany
   */
  export type ExhibitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exhibitors.
     */
    data: ExhibitorCreateManyInput | ExhibitorCreateManyInput[]
  }

  /**
   * Exhibitor update
   */
  export type ExhibitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * The data needed to update a Exhibitor.
     */
    data: XOR<ExhibitorUpdateInput, ExhibitorUncheckedUpdateInput>
    /**
     * Choose, which Exhibitor to update.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor updateMany
   */
  export type ExhibitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exhibitors.
     */
    data: XOR<ExhibitorUpdateManyMutationInput, ExhibitorUncheckedUpdateManyInput>
    /**
     * Filter which Exhibitors to update
     */
    where?: ExhibitorWhereInput
    /**
     * Limit how many Exhibitors to update.
     */
    limit?: number
  }

  /**
   * Exhibitor upsert
   */
  export type ExhibitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * The filter to search for the Exhibitor to update in case it exists.
     */
    where: ExhibitorWhereUniqueInput
    /**
     * In case the Exhibitor found by the `where` argument doesn't exist, create a new Exhibitor with this data.
     */
    create: XOR<ExhibitorCreateInput, ExhibitorUncheckedCreateInput>
    /**
     * In case the Exhibitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExhibitorUpdateInput, ExhibitorUncheckedUpdateInput>
  }

  /**
   * Exhibitor delete
   */
  export type ExhibitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
    /**
     * Filter which Exhibitor to delete.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor deleteMany
   */
  export type ExhibitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exhibitors to delete
     */
    where?: ExhibitorWhereInput
    /**
     * Limit how many Exhibitors to delete.
     */
    limit?: number
  }

  /**
   * Exhibitor findRaw
   */
  export type ExhibitorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exhibitor aggregateRaw
   */
  export type ExhibitorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exhibitor without action
   */
  export type ExhibitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExhibitorInclude<ExtArgs> | null
  }


  /**
   * Model Sponsor
   */

  export type AggregateSponsor = {
    _count: SponsorCountAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  export type SponsorMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    level: string | null
    amount: string | null
    status: string | null
    benefits: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SponsorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    level: string | null
    amount: string | null
    status: string | null
    benefits: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SponsorCountAggregateOutputType = {
    id: number
    name: number
    image: number
    level: number
    amount: number
    status: number
    benefits: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type SponsorMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    level?: true
    amount?: true
    status?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SponsorMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    level?: true
    amount?: true
    status?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SponsorCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    level?: true
    amount?: true
    status?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type SponsorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsor to aggregate.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsors
    **/
    _count?: true | SponsorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorMaxAggregateInputType
  }

  export type GetSponsorAggregateType<T extends SponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsor[P]>
      : GetScalarType<T[P], AggregateSponsor[P]>
  }




  export type SponsorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithAggregationInput | SponsorOrderByWithAggregationInput[]
    by: SponsorScalarFieldEnum[] | SponsorScalarFieldEnum
    having?: SponsorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorCountAggregateInputType | true
    _min?: SponsorMinAggregateInputType
    _max?: SponsorMaxAggregateInputType
  }

  export type SponsorGroupByOutputType = {
    id: string
    name: string
    image: string | null
    level: string
    amount: string | null
    status: string | null
    benefits: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: SponsorCountAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  type GetSponsorGroupByPayload<T extends SponsorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorGroupByOutputType[P]>
        }
      >
    >


  export type SponsorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    level?: boolean
    amount?: boolean
    status?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsor"]>



  export type SponsorSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    level?: boolean
    amount?: boolean
    status?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type SponsorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "level" | "amount" | "status" | "benefits" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["sponsor"]>
  export type SponsorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SponsorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsor"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string | null
      level: string
      amount: string | null
      status: string | null
      benefits: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["sponsor"]>
    composites: {}
  }

  type SponsorGetPayload<S extends boolean | null | undefined | SponsorDefaultArgs> = $Result.GetResult<Prisma.$SponsorPayload, S>

  type SponsorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorCountAggregateInputType | true
    }

  export interface SponsorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsor'], meta: { name: 'Sponsor' } }
    /**
     * Find zero or one Sponsor that matches the filter.
     * @param {SponsorFindUniqueArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorFindUniqueArgs>(args: SelectSubset<T, SponsorFindUniqueArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sponsor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorFindUniqueOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorFindFirstArgs>(args?: SelectSubset<T, SponsorFindFirstArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsor.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sponsorWithIdOnly = await prisma.sponsor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SponsorFindManyArgs>(args?: SelectSubset<T, SponsorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sponsor.
     * @param {SponsorCreateArgs} args - Arguments to create a Sponsor.
     * @example
     * // Create one Sponsor
     * const Sponsor = await prisma.sponsor.create({
     *   data: {
     *     // ... data to create a Sponsor
     *   }
     * })
     * 
     */
    create<T extends SponsorCreateArgs>(args: SelectSubset<T, SponsorCreateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sponsors.
     * @param {SponsorCreateManyArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsor = await prisma.sponsor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorCreateManyArgs>(args?: SelectSubset<T, SponsorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sponsor.
     * @param {SponsorDeleteArgs} args - Arguments to delete one Sponsor.
     * @example
     * // Delete one Sponsor
     * const Sponsor = await prisma.sponsor.delete({
     *   where: {
     *     // ... filter to delete one Sponsor
     *   }
     * })
     * 
     */
    delete<T extends SponsorDeleteArgs>(args: SelectSubset<T, SponsorDeleteArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sponsor.
     * @param {SponsorUpdateArgs} args - Arguments to update one Sponsor.
     * @example
     * // Update one Sponsor
     * const sponsor = await prisma.sponsor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorUpdateArgs>(args: SelectSubset<T, SponsorUpdateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sponsors.
     * @param {SponsorDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorDeleteManyArgs>(args?: SelectSubset<T, SponsorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorUpdateManyArgs>(args: SelectSubset<T, SponsorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sponsor.
     * @param {SponsorUpsertArgs} args - Arguments to update or create a Sponsor.
     * @example
     * // Update or create a Sponsor
     * const sponsor = await prisma.sponsor.upsert({
     *   create: {
     *     // ... data to create a Sponsor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsor we want to update
     *   }
     * })
     */
    upsert<T extends SponsorUpsertArgs>(args: SelectSubset<T, SponsorUpsertArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * @param {SponsorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sponsor = await prisma.sponsor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SponsorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sponsor.
     * @param {SponsorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sponsor = await prisma.sponsor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SponsorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsor.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends SponsorCountArgs>(
      args?: Subset<T, SponsorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorAggregateArgs>(args: Subset<T, SponsorAggregateArgs>): Prisma.PrismaPromise<GetSponsorAggregateType<T>>

    /**
     * Group by Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorGroupByArgs['orderBy'] }
        : { orderBy?: SponsorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsor model
   */
  readonly fields: SponsorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sponsor model
   */
  interface SponsorFieldRefs {
    readonly id: FieldRef<"Sponsor", 'String'>
    readonly name: FieldRef<"Sponsor", 'String'>
    readonly image: FieldRef<"Sponsor", 'String'>
    readonly level: FieldRef<"Sponsor", 'String'>
    readonly amount: FieldRef<"Sponsor", 'String'>
    readonly status: FieldRef<"Sponsor", 'String'>
    readonly benefits: FieldRef<"Sponsor", 'String'>
    readonly createdAt: FieldRef<"Sponsor", 'DateTime'>
    readonly updatedAt: FieldRef<"Sponsor", 'DateTime'>
    readonly projectId: FieldRef<"Sponsor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sponsor findUnique
   */
  export type SponsorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findUniqueOrThrow
   */
  export type SponsorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findFirst
   */
  export type SponsorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findFirstOrThrow
   */
  export type SponsorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findMany
   */
  export type SponsorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor create
   */
  export type SponsorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sponsor.
     */
    data: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
  }

  /**
   * Sponsor createMany
   */
  export type SponsorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
  }

  /**
   * Sponsor update
   */
  export type SponsorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sponsor.
     */
    data: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
    /**
     * Choose, which Sponsor to update.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor updateMany
   */
  export type SponsorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
  }

  /**
   * Sponsor upsert
   */
  export type SponsorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sponsor to update in case it exists.
     */
    where: SponsorWhereUniqueInput
    /**
     * In case the Sponsor found by the `where` argument doesn't exist, create a new Sponsor with this data.
     */
    create: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
    /**
     * In case the Sponsor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
  }

  /**
   * Sponsor delete
   */
  export type SponsorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter which Sponsor to delete.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor deleteMany
   */
  export type SponsorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to delete
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to delete.
     */
    limit?: number
  }

  /**
   * Sponsor findRaw
   */
  export type SponsorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sponsor aggregateRaw
   */
  export type SponsorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sponsor without action
   */
  export type SponsorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SponsorInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    type: string | null
    website: string | null
    status: string | null
    contribution: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    type: string | null
    website: string | null
    status: string | null
    contribution: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    name: number
    image: number
    type: number
    website: number
    status: number
    contribution: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    type?: true
    website?: true
    status?: true
    contribution?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    type?: true
    website?: true
    status?: true
    contribution?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    type?: true
    website?: true
    status?: true
    contribution?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    name: string
    image: string | null
    type: string | null
    website: string | null
    status: string | null
    contribution: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    type?: boolean
    website?: boolean
    status?: boolean
    contribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>



  export type PartnerSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    type?: boolean
    website?: boolean
    status?: boolean
    contribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "type" | "website" | "status" | "contribution" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["partner"]>
  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string | null
      type: string | null
      website: string | null
      status: string | null
      contribution: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * @param {PartnerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const partner = await prisma.partner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PartnerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Partner.
     * @param {PartnerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const partner = await prisma.partner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PartnerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly image: FieldRef<"Partner", 'String'>
    readonly type: FieldRef<"Partner", 'String'>
    readonly website: FieldRef<"Partner", 'String'>
    readonly status: FieldRef<"Partner", 'String'>
    readonly contribution: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
    readonly projectId: FieldRef<"Partner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partner findRaw
   */
  export type PartnerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Partner aggregateRaw
   */
  export type PartnerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model MediaPartner
   */

  export type AggregateMediaPartner = {
    _count: MediaPartnerCountAggregateOutputType | null
    _avg: MediaPartnerAvgAggregateOutputType | null
    _sum: MediaPartnerSumAggregateOutputType | null
    _min: MediaPartnerMinAggregateOutputType | null
    _max: MediaPartnerMaxAggregateOutputType | null
  }

  export type MediaPartnerAvgAggregateOutputType = {
    priority: number | null
  }

  export type MediaPartnerSumAggregateOutputType = {
    priority: number | null
  }

  export type MediaPartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    website: string | null
    type: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type MediaPartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    website: string | null
    type: string | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type MediaPartnerCountAggregateOutputType = {
    id: number
    name: number
    image: number
    website: number
    type: number
    priority: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type MediaPartnerAvgAggregateInputType = {
    priority?: true
  }

  export type MediaPartnerSumAggregateInputType = {
    priority?: true
  }

  export type MediaPartnerMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    website?: true
    type?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type MediaPartnerMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    website?: true
    type?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type MediaPartnerCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    website?: true
    type?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type MediaPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaPartner to aggregate.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaPartners
    **/
    _count?: true | MediaPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaPartnerMaxAggregateInputType
  }

  export type GetMediaPartnerAggregateType<T extends MediaPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaPartner[P]>
      : GetScalarType<T[P], AggregateMediaPartner[P]>
  }




  export type MediaPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaPartnerWhereInput
    orderBy?: MediaPartnerOrderByWithAggregationInput | MediaPartnerOrderByWithAggregationInput[]
    by: MediaPartnerScalarFieldEnum[] | MediaPartnerScalarFieldEnum
    having?: MediaPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaPartnerCountAggregateInputType | true
    _avg?: MediaPartnerAvgAggregateInputType
    _sum?: MediaPartnerSumAggregateInputType
    _min?: MediaPartnerMinAggregateInputType
    _max?: MediaPartnerMaxAggregateInputType
  }

  export type MediaPartnerGroupByOutputType = {
    id: string
    name: string
    image: string | null
    website: string | null
    type: string | null
    priority: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: MediaPartnerCountAggregateOutputType | null
    _avg: MediaPartnerAvgAggregateOutputType | null
    _sum: MediaPartnerSumAggregateOutputType | null
    _min: MediaPartnerMinAggregateOutputType | null
    _max: MediaPartnerMaxAggregateOutputType | null
  }

  type GetMediaPartnerGroupByPayload<T extends MediaPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], MediaPartnerGroupByOutputType[P]>
        }
      >
    >


  export type MediaPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    website?: boolean
    type?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaPartner"]>



  export type MediaPartnerSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    website?: boolean
    type?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type MediaPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "image" | "website" | "type" | "priority" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["mediaPartner"]>
  export type MediaPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MediaPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaPartner"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string | null
      website: string | null
      type: string | null
      priority: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["mediaPartner"]>
    composites: {}
  }

  type MediaPartnerGetPayload<S extends boolean | null | undefined | MediaPartnerDefaultArgs> = $Result.GetResult<Prisma.$MediaPartnerPayload, S>

  type MediaPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaPartnerCountAggregateInputType | true
    }

  export interface MediaPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaPartner'], meta: { name: 'MediaPartner' } }
    /**
     * Find zero or one MediaPartner that matches the filter.
     * @param {MediaPartnerFindUniqueArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaPartnerFindUniqueArgs>(args: SelectSubset<T, MediaPartnerFindUniqueArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaPartnerFindUniqueOrThrowArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerFindFirstArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaPartnerFindFirstArgs>(args?: SelectSubset<T, MediaPartnerFindFirstArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerFindFirstOrThrowArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaPartners
     * const mediaPartners = await prisma.mediaPartner.findMany()
     * 
     * // Get first 10 MediaPartners
     * const mediaPartners = await prisma.mediaPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaPartnerWithIdOnly = await prisma.mediaPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaPartnerFindManyArgs>(args?: SelectSubset<T, MediaPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaPartner.
     * @param {MediaPartnerCreateArgs} args - Arguments to create a MediaPartner.
     * @example
     * // Create one MediaPartner
     * const MediaPartner = await prisma.mediaPartner.create({
     *   data: {
     *     // ... data to create a MediaPartner
     *   }
     * })
     * 
     */
    create<T extends MediaPartnerCreateArgs>(args: SelectSubset<T, MediaPartnerCreateArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaPartners.
     * @param {MediaPartnerCreateManyArgs} args - Arguments to create many MediaPartners.
     * @example
     * // Create many MediaPartners
     * const mediaPartner = await prisma.mediaPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaPartnerCreateManyArgs>(args?: SelectSubset<T, MediaPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MediaPartner.
     * @param {MediaPartnerDeleteArgs} args - Arguments to delete one MediaPartner.
     * @example
     * // Delete one MediaPartner
     * const MediaPartner = await prisma.mediaPartner.delete({
     *   where: {
     *     // ... filter to delete one MediaPartner
     *   }
     * })
     * 
     */
    delete<T extends MediaPartnerDeleteArgs>(args: SelectSubset<T, MediaPartnerDeleteArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaPartner.
     * @param {MediaPartnerUpdateArgs} args - Arguments to update one MediaPartner.
     * @example
     * // Update one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaPartnerUpdateArgs>(args: SelectSubset<T, MediaPartnerUpdateArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaPartners.
     * @param {MediaPartnerDeleteManyArgs} args - Arguments to filter MediaPartners to delete.
     * @example
     * // Delete a few MediaPartners
     * const { count } = await prisma.mediaPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaPartnerDeleteManyArgs>(args?: SelectSubset<T, MediaPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaPartners
     * const mediaPartner = await prisma.mediaPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaPartnerUpdateManyArgs>(args: SelectSubset<T, MediaPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaPartner.
     * @param {MediaPartnerUpsertArgs} args - Arguments to update or create a MediaPartner.
     * @example
     * // Update or create a MediaPartner
     * const mediaPartner = await prisma.mediaPartner.upsert({
     *   create: {
     *     // ... data to create a MediaPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaPartner we want to update
     *   }
     * })
     */
    upsert<T extends MediaPartnerUpsertArgs>(args: SelectSubset<T, MediaPartnerUpsertArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaPartners that matches the filter.
     * @param {MediaPartnerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mediaPartner = await prisma.mediaPartner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MediaPartnerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MediaPartner.
     * @param {MediaPartnerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mediaPartner = await prisma.mediaPartner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MediaPartnerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MediaPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerCountArgs} args - Arguments to filter MediaPartners to count.
     * @example
     * // Count the number of MediaPartners
     * const count = await prisma.mediaPartner.count({
     *   where: {
     *     // ... the filter for the MediaPartners we want to count
     *   }
     * })
    **/
    count<T extends MediaPartnerCountArgs>(
      args?: Subset<T, MediaPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaPartnerAggregateArgs>(args: Subset<T, MediaPartnerAggregateArgs>): Prisma.PrismaPromise<GetMediaPartnerAggregateType<T>>

    /**
     * Group by MediaPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaPartnerGroupByArgs['orderBy'] }
        : { orderBy?: MediaPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaPartner model
   */
  readonly fields: MediaPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaPartner model
   */
  interface MediaPartnerFieldRefs {
    readonly id: FieldRef<"MediaPartner", 'String'>
    readonly name: FieldRef<"MediaPartner", 'String'>
    readonly image: FieldRef<"MediaPartner", 'String'>
    readonly website: FieldRef<"MediaPartner", 'String'>
    readonly type: FieldRef<"MediaPartner", 'String'>
    readonly priority: FieldRef<"MediaPartner", 'Int'>
    readonly createdAt: FieldRef<"MediaPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaPartner", 'DateTime'>
    readonly projectId: FieldRef<"MediaPartner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MediaPartner findUnique
   */
  export type MediaPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner findUniqueOrThrow
   */
  export type MediaPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner findFirst
   */
  export type MediaPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaPartners.
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaPartners.
     */
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * MediaPartner findFirstOrThrow
   */
  export type MediaPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaPartners.
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaPartners.
     */
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * MediaPartner findMany
   */
  export type MediaPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * Filter, which MediaPartners to fetch.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaPartners.
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * MediaPartner create
   */
  export type MediaPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaPartner.
     */
    data: XOR<MediaPartnerCreateInput, MediaPartnerUncheckedCreateInput>
  }

  /**
   * MediaPartner createMany
   */
  export type MediaPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaPartners.
     */
    data: MediaPartnerCreateManyInput | MediaPartnerCreateManyInput[]
  }

  /**
   * MediaPartner update
   */
  export type MediaPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaPartner.
     */
    data: XOR<MediaPartnerUpdateInput, MediaPartnerUncheckedUpdateInput>
    /**
     * Choose, which MediaPartner to update.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner updateMany
   */
  export type MediaPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaPartners.
     */
    data: XOR<MediaPartnerUpdateManyMutationInput, MediaPartnerUncheckedUpdateManyInput>
    /**
     * Filter which MediaPartners to update
     */
    where?: MediaPartnerWhereInput
    /**
     * Limit how many MediaPartners to update.
     */
    limit?: number
  }

  /**
   * MediaPartner upsert
   */
  export type MediaPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaPartner to update in case it exists.
     */
    where: MediaPartnerWhereUniqueInput
    /**
     * In case the MediaPartner found by the `where` argument doesn't exist, create a new MediaPartner with this data.
     */
    create: XOR<MediaPartnerCreateInput, MediaPartnerUncheckedCreateInput>
    /**
     * In case the MediaPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaPartnerUpdateInput, MediaPartnerUncheckedUpdateInput>
  }

  /**
   * MediaPartner delete
   */
  export type MediaPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
    /**
     * Filter which MediaPartner to delete.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner deleteMany
   */
  export type MediaPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaPartners to delete
     */
    where?: MediaPartnerWhereInput
    /**
     * Limit how many MediaPartners to delete.
     */
    limit?: number
  }

  /**
   * MediaPartner findRaw
   */
  export type MediaPartnerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MediaPartner aggregateRaw
   */
  export type MediaPartnerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MediaPartner without action
   */
  export type MediaPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaPartnerInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    amount: number | null
  }

  export type OrderSumAggregateOutputType = {
    amount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    customerName: string | null
    customerEmail: string | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    customerName: string | null
    customerEmail: string | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    customerName: number
    customerEmail: number
    amount: number
    status: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    amount?: true
  }

  export type OrderSumAggregateInputType = {
    amount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    customerName?: true
    customerEmail?: true
    amount?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    customerName?: true
    customerEmail?: true
    amount?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    customerName?: true
    customerEmail?: true
    amount?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    customerName?: boolean
    customerEmail?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    customerName?: boolean
    customerEmail?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "customerName" | "customerEmail" | "amount" | "status" | "paymentMethod" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      customerName: string
      customerEmail: string
      amount: number
      status: string
      paymentMethod: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly amount: FieldRef<"Order", 'Float'>
    readonly status: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly projectId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order findRaw
   */
  export type OrderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Enquiry
   */

  export type AggregateEnquiry = {
    _count: EnquiryCountAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  export type EnquiryMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type EnquiryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type EnquiryCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    status: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type EnquiryMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type EnquiryMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type EnquiryCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type EnquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiry to aggregate.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enquiries
    **/
    _count?: true | EnquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnquiryMaxAggregateInputType
  }

  export type GetEnquiryAggregateType<T extends EnquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateEnquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnquiry[P]>
      : GetScalarType<T[P], AggregateEnquiry[P]>
  }




  export type EnquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithAggregationInput | EnquiryOrderByWithAggregationInput[]
    by: EnquiryScalarFieldEnum[] | EnquiryScalarFieldEnum
    having?: EnquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnquiryCountAggregateInputType | true
    _min?: EnquiryMinAggregateInputType
    _max?: EnquiryMaxAggregateInputType
  }

  export type EnquiryGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    subject: string | null
    message: string
    status: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: EnquiryCountAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  type GetEnquiryGroupByPayload<T extends EnquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
            : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
        }
      >
    >


  export type EnquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiry"]>



  export type EnquirySelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type EnquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "subject" | "message" | "status" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["enquiry"]>
  export type EnquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $EnquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enquiry"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      subject: string | null
      message: string
      status: string
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["enquiry"]>
    composites: {}
  }

  type EnquiryGetPayload<S extends boolean | null | undefined | EnquiryDefaultArgs> = $Result.GetResult<Prisma.$EnquiryPayload, S>

  type EnquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnquiryCountAggregateInputType | true
    }

  export interface EnquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enquiry'], meta: { name: 'Enquiry' } }
    /**
     * Find zero or one Enquiry that matches the filter.
     * @param {EnquiryFindUniqueArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnquiryFindUniqueArgs>(args: SelectSubset<T, EnquiryFindUniqueArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnquiryFindUniqueOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, EnquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnquiryFindFirstArgs>(args?: SelectSubset<T, EnquiryFindFirstArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, EnquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enquiries
     * const enquiries = await prisma.enquiry.findMany()
     * 
     * // Get first 10 Enquiries
     * const enquiries = await prisma.enquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnquiryFindManyArgs>(args?: SelectSubset<T, EnquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enquiry.
     * @param {EnquiryCreateArgs} args - Arguments to create a Enquiry.
     * @example
     * // Create one Enquiry
     * const Enquiry = await prisma.enquiry.create({
     *   data: {
     *     // ... data to create a Enquiry
     *   }
     * })
     * 
     */
    create<T extends EnquiryCreateArgs>(args: SelectSubset<T, EnquiryCreateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enquiries.
     * @param {EnquiryCreateManyArgs} args - Arguments to create many Enquiries.
     * @example
     * // Create many Enquiries
     * const enquiry = await prisma.enquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnquiryCreateManyArgs>(args?: SelectSubset<T, EnquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enquiry.
     * @param {EnquiryDeleteArgs} args - Arguments to delete one Enquiry.
     * @example
     * // Delete one Enquiry
     * const Enquiry = await prisma.enquiry.delete({
     *   where: {
     *     // ... filter to delete one Enquiry
     *   }
     * })
     * 
     */
    delete<T extends EnquiryDeleteArgs>(args: SelectSubset<T, EnquiryDeleteArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enquiry.
     * @param {EnquiryUpdateArgs} args - Arguments to update one Enquiry.
     * @example
     * // Update one Enquiry
     * const enquiry = await prisma.enquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnquiryUpdateArgs>(args: SelectSubset<T, EnquiryUpdateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enquiries.
     * @param {EnquiryDeleteManyArgs} args - Arguments to filter Enquiries to delete.
     * @example
     * // Delete a few Enquiries
     * const { count } = await prisma.enquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnquiryDeleteManyArgs>(args?: SelectSubset<T, EnquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enquiries
     * const enquiry = await prisma.enquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnquiryUpdateManyArgs>(args: SelectSubset<T, EnquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enquiry.
     * @param {EnquiryUpsertArgs} args - Arguments to update or create a Enquiry.
     * @example
     * // Update or create a Enquiry
     * const enquiry = await prisma.enquiry.upsert({
     *   create: {
     *     // ... data to create a Enquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enquiry we want to update
     *   }
     * })
     */
    upsert<T extends EnquiryUpsertArgs>(args: SelectSubset<T, EnquiryUpsertArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enquiries that matches the filter.
     * @param {EnquiryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const enquiry = await prisma.enquiry.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EnquiryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Enquiry.
     * @param {EnquiryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const enquiry = await prisma.enquiry.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EnquiryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCountArgs} args - Arguments to filter Enquiries to count.
     * @example
     * // Count the number of Enquiries
     * const count = await prisma.enquiry.count({
     *   where: {
     *     // ... the filter for the Enquiries we want to count
     *   }
     * })
    **/
    count<T extends EnquiryCountArgs>(
      args?: Subset<T, EnquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnquiryAggregateArgs>(args: Subset<T, EnquiryAggregateArgs>): Prisma.PrismaPromise<GetEnquiryAggregateType<T>>

    /**
     * Group by Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnquiryGroupByArgs['orderBy'] }
        : { orderBy?: EnquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enquiry model
   */
  readonly fields: EnquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enquiry model
   */
  interface EnquiryFieldRefs {
    readonly id: FieldRef<"Enquiry", 'String'>
    readonly name: FieldRef<"Enquiry", 'String'>
    readonly email: FieldRef<"Enquiry", 'String'>
    readonly phone: FieldRef<"Enquiry", 'String'>
    readonly subject: FieldRef<"Enquiry", 'String'>
    readonly message: FieldRef<"Enquiry", 'String'>
    readonly status: FieldRef<"Enquiry", 'String'>
    readonly createdAt: FieldRef<"Enquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Enquiry", 'DateTime'>
    readonly projectId: FieldRef<"Enquiry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enquiry findUnique
   */
  export type EnquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findUniqueOrThrow
   */
  export type EnquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findFirst
   */
  export type EnquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findFirstOrThrow
   */
  export type EnquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findMany
   */
  export type EnquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiries to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry create
   */
  export type EnquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Enquiry.
     */
    data: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
  }

  /**
   * Enquiry createMany
   */
  export type EnquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enquiries.
     */
    data: EnquiryCreateManyInput | EnquiryCreateManyInput[]
  }

  /**
   * Enquiry update
   */
  export type EnquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Enquiry.
     */
    data: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
    /**
     * Choose, which Enquiry to update.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry updateMany
   */
  export type EnquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enquiries.
     */
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyInput>
    /**
     * Filter which Enquiries to update
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to update.
     */
    limit?: number
  }

  /**
   * Enquiry upsert
   */
  export type EnquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Enquiry to update in case it exists.
     */
    where: EnquiryWhereUniqueInput
    /**
     * In case the Enquiry found by the `where` argument doesn't exist, create a new Enquiry with this data.
     */
    create: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
    /**
     * In case the Enquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
  }

  /**
   * Enquiry delete
   */
  export type EnquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter which Enquiry to delete.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry deleteMany
   */
  export type EnquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiries to delete
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to delete.
     */
    limit?: number
  }

  /**
   * Enquiry findRaw
   */
  export type EnquiryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Enquiry aggregateRaw
   */
  export type EnquiryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Enquiry without action
   */
  export type EnquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
  }


  /**
   * Model UtmData
   */

  export type AggregateUtmData = {
    _count: UtmDataCountAggregateOutputType | null
    _avg: UtmDataAvgAggregateOutputType | null
    _sum: UtmDataSumAggregateOutputType | null
    _min: UtmDataMinAggregateOutputType | null
    _max: UtmDataMaxAggregateOutputType | null
  }

  export type UtmDataAvgAggregateOutputType = {
    visits: number | null
    conversions: number | null
  }

  export type UtmDataSumAggregateOutputType = {
    visits: number | null
    conversions: number | null
  }

  export type UtmDataMinAggregateOutputType = {
    id: string | null
    source: string | null
    medium: string | null
    campaign: string | null
    term: string | null
    content: string | null
    visits: number | null
    conversions: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type UtmDataMaxAggregateOutputType = {
    id: string | null
    source: string | null
    medium: string | null
    campaign: string | null
    term: string | null
    content: string | null
    visits: number | null
    conversions: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type UtmDataCountAggregateOutputType = {
    id: number
    source: number
    medium: number
    campaign: number
    term: number
    content: number
    visits: number
    conversions: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type UtmDataAvgAggregateInputType = {
    visits?: true
    conversions?: true
  }

  export type UtmDataSumAggregateInputType = {
    visits?: true
    conversions?: true
  }

  export type UtmDataMinAggregateInputType = {
    id?: true
    source?: true
    medium?: true
    campaign?: true
    term?: true
    content?: true
    visits?: true
    conversions?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type UtmDataMaxAggregateInputType = {
    id?: true
    source?: true
    medium?: true
    campaign?: true
    term?: true
    content?: true
    visits?: true
    conversions?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type UtmDataCountAggregateInputType = {
    id?: true
    source?: true
    medium?: true
    campaign?: true
    term?: true
    content?: true
    visits?: true
    conversions?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type UtmDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UtmData to aggregate.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UtmData
    **/
    _count?: true | UtmDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtmDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtmDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtmDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtmDataMaxAggregateInputType
  }

  export type GetUtmDataAggregateType<T extends UtmDataAggregateArgs> = {
        [P in keyof T & keyof AggregateUtmData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtmData[P]>
      : GetScalarType<T[P], AggregateUtmData[P]>
  }




  export type UtmDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtmDataWhereInput
    orderBy?: UtmDataOrderByWithAggregationInput | UtmDataOrderByWithAggregationInput[]
    by: UtmDataScalarFieldEnum[] | UtmDataScalarFieldEnum
    having?: UtmDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtmDataCountAggregateInputType | true
    _avg?: UtmDataAvgAggregateInputType
    _sum?: UtmDataSumAggregateInputType
    _min?: UtmDataMinAggregateInputType
    _max?: UtmDataMaxAggregateInputType
  }

  export type UtmDataGroupByOutputType = {
    id: string
    source: string | null
    medium: string | null
    campaign: string | null
    term: string | null
    content: string | null
    visits: number
    conversions: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: UtmDataCountAggregateOutputType | null
    _avg: UtmDataAvgAggregateOutputType | null
    _sum: UtmDataSumAggregateOutputType | null
    _min: UtmDataMinAggregateOutputType | null
    _max: UtmDataMaxAggregateOutputType | null
  }

  type GetUtmDataGroupByPayload<T extends UtmDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtmDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtmDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtmDataGroupByOutputType[P]>
            : GetScalarType<T[P], UtmDataGroupByOutputType[P]>
        }
      >
    >


  export type UtmDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    term?: boolean
    content?: boolean
    visits?: boolean
    conversions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utmData"]>



  export type UtmDataSelectScalar = {
    id?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    term?: boolean
    content?: boolean
    visits?: boolean
    conversions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type UtmDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source" | "medium" | "campaign" | "term" | "content" | "visits" | "conversions" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["utmData"]>
  export type UtmDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $UtmDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UtmData"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string | null
      medium: string | null
      campaign: string | null
      term: string | null
      content: string | null
      visits: number
      conversions: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["utmData"]>
    composites: {}
  }

  type UtmDataGetPayload<S extends boolean | null | undefined | UtmDataDefaultArgs> = $Result.GetResult<Prisma.$UtmDataPayload, S>

  type UtmDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UtmDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtmDataCountAggregateInputType | true
    }

  export interface UtmDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UtmData'], meta: { name: 'UtmData' } }
    /**
     * Find zero or one UtmData that matches the filter.
     * @param {UtmDataFindUniqueArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UtmDataFindUniqueArgs>(args: SelectSubset<T, UtmDataFindUniqueArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UtmData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UtmDataFindUniqueOrThrowArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UtmDataFindUniqueOrThrowArgs>(args: SelectSubset<T, UtmDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UtmData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataFindFirstArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UtmDataFindFirstArgs>(args?: SelectSubset<T, UtmDataFindFirstArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UtmData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataFindFirstOrThrowArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UtmDataFindFirstOrThrowArgs>(args?: SelectSubset<T, UtmDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UtmData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UtmData
     * const utmData = await prisma.utmData.findMany()
     * 
     * // Get first 10 UtmData
     * const utmData = await prisma.utmData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utmDataWithIdOnly = await prisma.utmData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UtmDataFindManyArgs>(args?: SelectSubset<T, UtmDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UtmData.
     * @param {UtmDataCreateArgs} args - Arguments to create a UtmData.
     * @example
     * // Create one UtmData
     * const UtmData = await prisma.utmData.create({
     *   data: {
     *     // ... data to create a UtmData
     *   }
     * })
     * 
     */
    create<T extends UtmDataCreateArgs>(args: SelectSubset<T, UtmDataCreateArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UtmData.
     * @param {UtmDataCreateManyArgs} args - Arguments to create many UtmData.
     * @example
     * // Create many UtmData
     * const utmData = await prisma.utmData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UtmDataCreateManyArgs>(args?: SelectSubset<T, UtmDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UtmData.
     * @param {UtmDataDeleteArgs} args - Arguments to delete one UtmData.
     * @example
     * // Delete one UtmData
     * const UtmData = await prisma.utmData.delete({
     *   where: {
     *     // ... filter to delete one UtmData
     *   }
     * })
     * 
     */
    delete<T extends UtmDataDeleteArgs>(args: SelectSubset<T, UtmDataDeleteArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UtmData.
     * @param {UtmDataUpdateArgs} args - Arguments to update one UtmData.
     * @example
     * // Update one UtmData
     * const utmData = await prisma.utmData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UtmDataUpdateArgs>(args: SelectSubset<T, UtmDataUpdateArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UtmData.
     * @param {UtmDataDeleteManyArgs} args - Arguments to filter UtmData to delete.
     * @example
     * // Delete a few UtmData
     * const { count } = await prisma.utmData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UtmDataDeleteManyArgs>(args?: SelectSubset<T, UtmDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UtmData
     * const utmData = await prisma.utmData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UtmDataUpdateManyArgs>(args: SelectSubset<T, UtmDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UtmData.
     * @param {UtmDataUpsertArgs} args - Arguments to update or create a UtmData.
     * @example
     * // Update or create a UtmData
     * const utmData = await prisma.utmData.upsert({
     *   create: {
     *     // ... data to create a UtmData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UtmData we want to update
     *   }
     * })
     */
    upsert<T extends UtmDataUpsertArgs>(args: SelectSubset<T, UtmDataUpsertArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UtmData that matches the filter.
     * @param {UtmDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const utmData = await prisma.utmData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UtmDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UtmData.
     * @param {UtmDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const utmData = await prisma.utmData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UtmDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataCountArgs} args - Arguments to filter UtmData to count.
     * @example
     * // Count the number of UtmData
     * const count = await prisma.utmData.count({
     *   where: {
     *     // ... the filter for the UtmData we want to count
     *   }
     * })
    **/
    count<T extends UtmDataCountArgs>(
      args?: Subset<T, UtmDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtmDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtmDataAggregateArgs>(args: Subset<T, UtmDataAggregateArgs>): Prisma.PrismaPromise<GetUtmDataAggregateType<T>>

    /**
     * Group by UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtmDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtmDataGroupByArgs['orderBy'] }
        : { orderBy?: UtmDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtmDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtmDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UtmData model
   */
  readonly fields: UtmDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UtmData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtmDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UtmData model
   */
  interface UtmDataFieldRefs {
    readonly id: FieldRef<"UtmData", 'String'>
    readonly source: FieldRef<"UtmData", 'String'>
    readonly medium: FieldRef<"UtmData", 'String'>
    readonly campaign: FieldRef<"UtmData", 'String'>
    readonly term: FieldRef<"UtmData", 'String'>
    readonly content: FieldRef<"UtmData", 'String'>
    readonly visits: FieldRef<"UtmData", 'Int'>
    readonly conversions: FieldRef<"UtmData", 'Int'>
    readonly createdAt: FieldRef<"UtmData", 'DateTime'>
    readonly updatedAt: FieldRef<"UtmData", 'DateTime'>
    readonly projectId: FieldRef<"UtmData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UtmData findUnique
   */
  export type UtmDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData findUniqueOrThrow
   */
  export type UtmDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData findFirst
   */
  export type UtmDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UtmData.
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UtmData.
     */
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * UtmData findFirstOrThrow
   */
  export type UtmDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UtmData.
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UtmData.
     */
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * UtmData findMany
   */
  export type UtmDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UtmData.
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * UtmData create
   */
  export type UtmDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * The data needed to create a UtmData.
     */
    data: XOR<UtmDataCreateInput, UtmDataUncheckedCreateInput>
  }

  /**
   * UtmData createMany
   */
  export type UtmDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UtmData.
     */
    data: UtmDataCreateManyInput | UtmDataCreateManyInput[]
  }

  /**
   * UtmData update
   */
  export type UtmDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * The data needed to update a UtmData.
     */
    data: XOR<UtmDataUpdateInput, UtmDataUncheckedUpdateInput>
    /**
     * Choose, which UtmData to update.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData updateMany
   */
  export type UtmDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UtmData.
     */
    data: XOR<UtmDataUpdateManyMutationInput, UtmDataUncheckedUpdateManyInput>
    /**
     * Filter which UtmData to update
     */
    where?: UtmDataWhereInput
    /**
     * Limit how many UtmData to update.
     */
    limit?: number
  }

  /**
   * UtmData upsert
   */
  export type UtmDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * The filter to search for the UtmData to update in case it exists.
     */
    where: UtmDataWhereUniqueInput
    /**
     * In case the UtmData found by the `where` argument doesn't exist, create a new UtmData with this data.
     */
    create: XOR<UtmDataCreateInput, UtmDataUncheckedCreateInput>
    /**
     * In case the UtmData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtmDataUpdateInput, UtmDataUncheckedUpdateInput>
  }

  /**
   * UtmData delete
   */
  export type UtmDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
    /**
     * Filter which UtmData to delete.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData deleteMany
   */
  export type UtmDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UtmData to delete
     */
    where?: UtmDataWhereInput
    /**
     * Limit how many UtmData to delete.
     */
    limit?: number
  }

  /**
   * UtmData findRaw
   */
  export type UtmDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UtmData aggregateRaw
   */
  export type UtmDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UtmData without action
   */
  export type UtmDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtmDataInclude<ExtArgs> | null
  }


  /**
   * Model AgendaDay
   */

  export type AggregateAgendaDay = {
    _count: AgendaDayCountAggregateOutputType | null
    _avg: AgendaDayAvgAggregateOutputType | null
    _sum: AgendaDaySumAggregateOutputType | null
    _min: AgendaDayMinAggregateOutputType | null
    _max: AgendaDayMaxAggregateOutputType | null
  }

  export type AgendaDayAvgAggregateOutputType = {
    dayNumber: number | null
  }

  export type AgendaDaySumAggregateOutputType = {
    dayNumber: number | null
  }

  export type AgendaDayMinAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    dayNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type AgendaDayMaxAggregateOutputType = {
    id: string | null
    name: string | null
    date: Date | null
    dayNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type AgendaDayCountAggregateOutputType = {
    id: number
    name: number
    date: number
    dayNumber: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type AgendaDayAvgAggregateInputType = {
    dayNumber?: true
  }

  export type AgendaDaySumAggregateInputType = {
    dayNumber?: true
  }

  export type AgendaDayMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    dayNumber?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type AgendaDayMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    dayNumber?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type AgendaDayCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    dayNumber?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type AgendaDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaDay to aggregate.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaDays
    **/
    _count?: true | AgendaDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgendaDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgendaDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaDayMaxAggregateInputType
  }

  export type GetAgendaDayAggregateType<T extends AgendaDayAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaDay[P]>
      : GetScalarType<T[P], AggregateAgendaDay[P]>
  }




  export type AgendaDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaDayWhereInput
    orderBy?: AgendaDayOrderByWithAggregationInput | AgendaDayOrderByWithAggregationInput[]
    by: AgendaDayScalarFieldEnum[] | AgendaDayScalarFieldEnum
    having?: AgendaDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaDayCountAggregateInputType | true
    _avg?: AgendaDayAvgAggregateInputType
    _sum?: AgendaDaySumAggregateInputType
    _min?: AgendaDayMinAggregateInputType
    _max?: AgendaDayMaxAggregateInputType
  }

  export type AgendaDayGroupByOutputType = {
    id: string
    name: string
    date: Date
    dayNumber: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: AgendaDayCountAggregateOutputType | null
    _avg: AgendaDayAvgAggregateOutputType | null
    _sum: AgendaDaySumAggregateOutputType | null
    _min: AgendaDayMinAggregateOutputType | null
    _max: AgendaDayMaxAggregateOutputType | null
  }

  type GetAgendaDayGroupByPayload<T extends AgendaDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaDayGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaDayGroupByOutputType[P]>
        }
      >
    >


  export type AgendaDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    dayNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sessions?: boolean | AgendaDay$sessionsArgs<ExtArgs>
    _count?: boolean | AgendaDayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agendaDay"]>



  export type AgendaDaySelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    dayNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type AgendaDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "date" | "dayNumber" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["agendaDay"]>
  export type AgendaDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sessions?: boolean | AgendaDay$sessionsArgs<ExtArgs>
    _count?: boolean | AgendaDayCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgendaDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaDay"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      sessions: Prisma.$AgendaSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      date: Date
      dayNumber: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["agendaDay"]>
    composites: {}
  }

  type AgendaDayGetPayload<S extends boolean | null | undefined | AgendaDayDefaultArgs> = $Result.GetResult<Prisma.$AgendaDayPayload, S>

  type AgendaDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaDayCountAggregateInputType | true
    }

  export interface AgendaDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaDay'], meta: { name: 'AgendaDay' } }
    /**
     * Find zero or one AgendaDay that matches the filter.
     * @param {AgendaDayFindUniqueArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaDayFindUniqueArgs>(args: SelectSubset<T, AgendaDayFindUniqueArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaDayFindUniqueOrThrowArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaDayFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayFindFirstArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaDayFindFirstArgs>(args?: SelectSubset<T, AgendaDayFindFirstArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayFindFirstOrThrowArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaDayFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaDays
     * const agendaDays = await prisma.agendaDay.findMany()
     * 
     * // Get first 10 AgendaDays
     * const agendaDays = await prisma.agendaDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaDayWithIdOnly = await prisma.agendaDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaDayFindManyArgs>(args?: SelectSubset<T, AgendaDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaDay.
     * @param {AgendaDayCreateArgs} args - Arguments to create a AgendaDay.
     * @example
     * // Create one AgendaDay
     * const AgendaDay = await prisma.agendaDay.create({
     *   data: {
     *     // ... data to create a AgendaDay
     *   }
     * })
     * 
     */
    create<T extends AgendaDayCreateArgs>(args: SelectSubset<T, AgendaDayCreateArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaDays.
     * @param {AgendaDayCreateManyArgs} args - Arguments to create many AgendaDays.
     * @example
     * // Create many AgendaDays
     * const agendaDay = await prisma.agendaDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaDayCreateManyArgs>(args?: SelectSubset<T, AgendaDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaDay.
     * @param {AgendaDayDeleteArgs} args - Arguments to delete one AgendaDay.
     * @example
     * // Delete one AgendaDay
     * const AgendaDay = await prisma.agendaDay.delete({
     *   where: {
     *     // ... filter to delete one AgendaDay
     *   }
     * })
     * 
     */
    delete<T extends AgendaDayDeleteArgs>(args: SelectSubset<T, AgendaDayDeleteArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaDay.
     * @param {AgendaDayUpdateArgs} args - Arguments to update one AgendaDay.
     * @example
     * // Update one AgendaDay
     * const agendaDay = await prisma.agendaDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaDayUpdateArgs>(args: SelectSubset<T, AgendaDayUpdateArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaDays.
     * @param {AgendaDayDeleteManyArgs} args - Arguments to filter AgendaDays to delete.
     * @example
     * // Delete a few AgendaDays
     * const { count } = await prisma.agendaDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaDayDeleteManyArgs>(args?: SelectSubset<T, AgendaDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaDays
     * const agendaDay = await prisma.agendaDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaDayUpdateManyArgs>(args: SelectSubset<T, AgendaDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaDay.
     * @param {AgendaDayUpsertArgs} args - Arguments to update or create a AgendaDay.
     * @example
     * // Update or create a AgendaDay
     * const agendaDay = await prisma.agendaDay.upsert({
     *   create: {
     *     // ... data to create a AgendaDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaDay we want to update
     *   }
     * })
     */
    upsert<T extends AgendaDayUpsertArgs>(args: SelectSubset<T, AgendaDayUpsertArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaDays that matches the filter.
     * @param {AgendaDayFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaDay = await prisma.agendaDay.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaDayFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaDay.
     * @param {AgendaDayAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaDay = await prisma.agendaDay.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaDayAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayCountArgs} args - Arguments to filter AgendaDays to count.
     * @example
     * // Count the number of AgendaDays
     * const count = await prisma.agendaDay.count({
     *   where: {
     *     // ... the filter for the AgendaDays we want to count
     *   }
     * })
    **/
    count<T extends AgendaDayCountArgs>(
      args?: Subset<T, AgendaDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaDayAggregateArgs>(args: Subset<T, AgendaDayAggregateArgs>): Prisma.PrismaPromise<GetAgendaDayAggregateType<T>>

    /**
     * Group by AgendaDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaDayGroupByArgs['orderBy'] }
        : { orderBy?: AgendaDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaDay model
   */
  readonly fields: AgendaDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends AgendaDay$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AgendaDay$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaDay model
   */
  interface AgendaDayFieldRefs {
    readonly id: FieldRef<"AgendaDay", 'String'>
    readonly name: FieldRef<"AgendaDay", 'String'>
    readonly date: FieldRef<"AgendaDay", 'DateTime'>
    readonly dayNumber: FieldRef<"AgendaDay", 'Int'>
    readonly createdAt: FieldRef<"AgendaDay", 'DateTime'>
    readonly updatedAt: FieldRef<"AgendaDay", 'DateTime'>
    readonly projectId: FieldRef<"AgendaDay", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgendaDay findUnique
   */
  export type AgendaDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay findUniqueOrThrow
   */
  export type AgendaDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay findFirst
   */
  export type AgendaDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaDays.
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaDays.
     */
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * AgendaDay findFirstOrThrow
   */
  export type AgendaDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaDays.
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaDays.
     */
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * AgendaDay findMany
   */
  export type AgendaDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * Filter, which AgendaDays to fetch.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaDays.
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * AgendaDay create
   */
  export type AgendaDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * The data needed to create a AgendaDay.
     */
    data: XOR<AgendaDayCreateInput, AgendaDayUncheckedCreateInput>
  }

  /**
   * AgendaDay createMany
   */
  export type AgendaDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaDays.
     */
    data: AgendaDayCreateManyInput | AgendaDayCreateManyInput[]
  }

  /**
   * AgendaDay update
   */
  export type AgendaDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * The data needed to update a AgendaDay.
     */
    data: XOR<AgendaDayUpdateInput, AgendaDayUncheckedUpdateInput>
    /**
     * Choose, which AgendaDay to update.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay updateMany
   */
  export type AgendaDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaDays.
     */
    data: XOR<AgendaDayUpdateManyMutationInput, AgendaDayUncheckedUpdateManyInput>
    /**
     * Filter which AgendaDays to update
     */
    where?: AgendaDayWhereInput
    /**
     * Limit how many AgendaDays to update.
     */
    limit?: number
  }

  /**
   * AgendaDay upsert
   */
  export type AgendaDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * The filter to search for the AgendaDay to update in case it exists.
     */
    where: AgendaDayWhereUniqueInput
    /**
     * In case the AgendaDay found by the `where` argument doesn't exist, create a new AgendaDay with this data.
     */
    create: XOR<AgendaDayCreateInput, AgendaDayUncheckedCreateInput>
    /**
     * In case the AgendaDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaDayUpdateInput, AgendaDayUncheckedUpdateInput>
  }

  /**
   * AgendaDay delete
   */
  export type AgendaDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
    /**
     * Filter which AgendaDay to delete.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay deleteMany
   */
  export type AgendaDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaDays to delete
     */
    where?: AgendaDayWhereInput
    /**
     * Limit how many AgendaDays to delete.
     */
    limit?: number
  }

  /**
   * AgendaDay findRaw
   */
  export type AgendaDayFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaDay aggregateRaw
   */
  export type AgendaDayAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaDay.sessions
   */
  export type AgendaDay$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    where?: AgendaSessionWhereInput
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    cursor?: AgendaSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaDay without action
   */
  export type AgendaDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaDayInclude<ExtArgs> | null
  }


  /**
   * Model AgendaSession
   */

  export type AggregateAgendaSession = {
    _count: AgendaSessionCountAggregateOutputType | null
    _min: AgendaSessionMinAggregateOutputType | null
    _max: AgendaSessionMaxAggregateOutputType | null
  }

  export type AgendaSessionMinAggregateOutputType = {
    id: string | null
    title: string | null
    startTime: string | null
    endTime: string | null
    color: string | null
    venue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dayId: string | null
  }

  export type AgendaSessionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    startTime: string | null
    endTime: string | null
    color: string | null
    venue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dayId: string | null
  }

  export type AgendaSessionCountAggregateOutputType = {
    id: number
    title: number
    startTime: number
    endTime: number
    color: number
    venue: number
    createdAt: number
    updatedAt: number
    dayId: number
    _all: number
  }


  export type AgendaSessionMinAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    color?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
    dayId?: true
  }

  export type AgendaSessionMaxAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    color?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
    dayId?: true
  }

  export type AgendaSessionCountAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    color?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
    dayId?: true
    _all?: true
  }

  export type AgendaSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaSession to aggregate.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaSessions
    **/
    _count?: true | AgendaSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaSessionMaxAggregateInputType
  }

  export type GetAgendaSessionAggregateType<T extends AgendaSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaSession[P]>
      : GetScalarType<T[P], AggregateAgendaSession[P]>
  }




  export type AgendaSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaSessionWhereInput
    orderBy?: AgendaSessionOrderByWithAggregationInput | AgendaSessionOrderByWithAggregationInput[]
    by: AgendaSessionScalarFieldEnum[] | AgendaSessionScalarFieldEnum
    having?: AgendaSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaSessionCountAggregateInputType | true
    _min?: AgendaSessionMinAggregateInputType
    _max?: AgendaSessionMaxAggregateInputType
  }

  export type AgendaSessionGroupByOutputType = {
    id: string
    title: string
    startTime: string
    endTime: string
    color: string | null
    venue: string | null
    createdAt: Date
    updatedAt: Date
    dayId: string
    _count: AgendaSessionCountAggregateOutputType | null
    _min: AgendaSessionMinAggregateOutputType | null
    _max: AgendaSessionMaxAggregateOutputType | null
  }

  type GetAgendaSessionGroupByPayload<T extends AgendaSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaSessionGroupByOutputType[P]>
        }
      >
    >


  export type AgendaSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    color?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayId?: boolean
    day?: boolean | AgendaDayDefaultArgs<ExtArgs>
    items?: boolean | AgendaSession$itemsArgs<ExtArgs>
    _count?: boolean | AgendaSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agendaSession"]>



  export type AgendaSessionSelectScalar = {
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    color?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayId?: boolean
  }

  export type AgendaSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "startTime" | "endTime" | "color" | "venue" | "createdAt" | "updatedAt" | "dayId", ExtArgs["result"]["agendaSession"]>
  export type AgendaSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    day?: boolean | AgendaDayDefaultArgs<ExtArgs>
    items?: boolean | AgendaSession$itemsArgs<ExtArgs>
    _count?: boolean | AgendaSessionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgendaSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaSession"
    objects: {
      day: Prisma.$AgendaDayPayload<ExtArgs>
      items: Prisma.$AgendaItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      startTime: string
      endTime: string
      color: string | null
      venue: string | null
      createdAt: Date
      updatedAt: Date
      dayId: string
    }, ExtArgs["result"]["agendaSession"]>
    composites: {}
  }

  type AgendaSessionGetPayload<S extends boolean | null | undefined | AgendaSessionDefaultArgs> = $Result.GetResult<Prisma.$AgendaSessionPayload, S>

  type AgendaSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaSessionCountAggregateInputType | true
    }

  export interface AgendaSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaSession'], meta: { name: 'AgendaSession' } }
    /**
     * Find zero or one AgendaSession that matches the filter.
     * @param {AgendaSessionFindUniqueArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaSessionFindUniqueArgs>(args: SelectSubset<T, AgendaSessionFindUniqueArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaSessionFindUniqueOrThrowArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionFindFirstArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaSessionFindFirstArgs>(args?: SelectSubset<T, AgendaSessionFindFirstArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionFindFirstOrThrowArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaSessions
     * const agendaSessions = await prisma.agendaSession.findMany()
     * 
     * // Get first 10 AgendaSessions
     * const agendaSessions = await prisma.agendaSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaSessionWithIdOnly = await prisma.agendaSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaSessionFindManyArgs>(args?: SelectSubset<T, AgendaSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaSession.
     * @param {AgendaSessionCreateArgs} args - Arguments to create a AgendaSession.
     * @example
     * // Create one AgendaSession
     * const AgendaSession = await prisma.agendaSession.create({
     *   data: {
     *     // ... data to create a AgendaSession
     *   }
     * })
     * 
     */
    create<T extends AgendaSessionCreateArgs>(args: SelectSubset<T, AgendaSessionCreateArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaSessions.
     * @param {AgendaSessionCreateManyArgs} args - Arguments to create many AgendaSessions.
     * @example
     * // Create many AgendaSessions
     * const agendaSession = await prisma.agendaSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaSessionCreateManyArgs>(args?: SelectSubset<T, AgendaSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaSession.
     * @param {AgendaSessionDeleteArgs} args - Arguments to delete one AgendaSession.
     * @example
     * // Delete one AgendaSession
     * const AgendaSession = await prisma.agendaSession.delete({
     *   where: {
     *     // ... filter to delete one AgendaSession
     *   }
     * })
     * 
     */
    delete<T extends AgendaSessionDeleteArgs>(args: SelectSubset<T, AgendaSessionDeleteArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaSession.
     * @param {AgendaSessionUpdateArgs} args - Arguments to update one AgendaSession.
     * @example
     * // Update one AgendaSession
     * const agendaSession = await prisma.agendaSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaSessionUpdateArgs>(args: SelectSubset<T, AgendaSessionUpdateArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaSessions.
     * @param {AgendaSessionDeleteManyArgs} args - Arguments to filter AgendaSessions to delete.
     * @example
     * // Delete a few AgendaSessions
     * const { count } = await prisma.agendaSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaSessionDeleteManyArgs>(args?: SelectSubset<T, AgendaSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaSessions
     * const agendaSession = await prisma.agendaSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaSessionUpdateManyArgs>(args: SelectSubset<T, AgendaSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaSession.
     * @param {AgendaSessionUpsertArgs} args - Arguments to update or create a AgendaSession.
     * @example
     * // Update or create a AgendaSession
     * const agendaSession = await prisma.agendaSession.upsert({
     *   create: {
     *     // ... data to create a AgendaSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaSession we want to update
     *   }
     * })
     */
    upsert<T extends AgendaSessionUpsertArgs>(args: SelectSubset<T, AgendaSessionUpsertArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaSessions that matches the filter.
     * @param {AgendaSessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaSession = await prisma.agendaSession.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaSessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaSession.
     * @param {AgendaSessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaSession = await prisma.agendaSession.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaSessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionCountArgs} args - Arguments to filter AgendaSessions to count.
     * @example
     * // Count the number of AgendaSessions
     * const count = await prisma.agendaSession.count({
     *   where: {
     *     // ... the filter for the AgendaSessions we want to count
     *   }
     * })
    **/
    count<T extends AgendaSessionCountArgs>(
      args?: Subset<T, AgendaSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaSessionAggregateArgs>(args: Subset<T, AgendaSessionAggregateArgs>): Prisma.PrismaPromise<GetAgendaSessionAggregateType<T>>

    /**
     * Group by AgendaSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaSessionGroupByArgs['orderBy'] }
        : { orderBy?: AgendaSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaSession model
   */
  readonly fields: AgendaSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    day<T extends AgendaDayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgendaDayDefaultArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends AgendaSession$itemsArgs<ExtArgs> = {}>(args?: Subset<T, AgendaSession$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaSession model
   */
  interface AgendaSessionFieldRefs {
    readonly id: FieldRef<"AgendaSession", 'String'>
    readonly title: FieldRef<"AgendaSession", 'String'>
    readonly startTime: FieldRef<"AgendaSession", 'String'>
    readonly endTime: FieldRef<"AgendaSession", 'String'>
    readonly color: FieldRef<"AgendaSession", 'String'>
    readonly venue: FieldRef<"AgendaSession", 'String'>
    readonly createdAt: FieldRef<"AgendaSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AgendaSession", 'DateTime'>
    readonly dayId: FieldRef<"AgendaSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgendaSession findUnique
   */
  export type AgendaSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession findUniqueOrThrow
   */
  export type AgendaSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession findFirst
   */
  export type AgendaSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaSessions.
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaSessions.
     */
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaSession findFirstOrThrow
   */
  export type AgendaSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaSessions.
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaSessions.
     */
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaSession findMany
   */
  export type AgendaSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgendaSessions to fetch.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaSessions.
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaSession create
   */
  export type AgendaSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgendaSession.
     */
    data: XOR<AgendaSessionCreateInput, AgendaSessionUncheckedCreateInput>
  }

  /**
   * AgendaSession createMany
   */
  export type AgendaSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaSessions.
     */
    data: AgendaSessionCreateManyInput | AgendaSessionCreateManyInput[]
  }

  /**
   * AgendaSession update
   */
  export type AgendaSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgendaSession.
     */
    data: XOR<AgendaSessionUpdateInput, AgendaSessionUncheckedUpdateInput>
    /**
     * Choose, which AgendaSession to update.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession updateMany
   */
  export type AgendaSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaSessions.
     */
    data: XOR<AgendaSessionUpdateManyMutationInput, AgendaSessionUncheckedUpdateManyInput>
    /**
     * Filter which AgendaSessions to update
     */
    where?: AgendaSessionWhereInput
    /**
     * Limit how many AgendaSessions to update.
     */
    limit?: number
  }

  /**
   * AgendaSession upsert
   */
  export type AgendaSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgendaSession to update in case it exists.
     */
    where: AgendaSessionWhereUniqueInput
    /**
     * In case the AgendaSession found by the `where` argument doesn't exist, create a new AgendaSession with this data.
     */
    create: XOR<AgendaSessionCreateInput, AgendaSessionUncheckedCreateInput>
    /**
     * In case the AgendaSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaSessionUpdateInput, AgendaSessionUncheckedUpdateInput>
  }

  /**
   * AgendaSession delete
   */
  export type AgendaSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
    /**
     * Filter which AgendaSession to delete.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession deleteMany
   */
  export type AgendaSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaSessions to delete
     */
    where?: AgendaSessionWhereInput
    /**
     * Limit how many AgendaSessions to delete.
     */
    limit?: number
  }

  /**
   * AgendaSession findRaw
   */
  export type AgendaSessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaSession aggregateRaw
   */
  export type AgendaSessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaSession.items
   */
  export type AgendaSession$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    where?: AgendaItemWhereInput
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    cursor?: AgendaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaSession without action
   */
  export type AgendaSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaSessionInclude<ExtArgs> | null
  }


  /**
   * Model AgendaItem
   */

  export type AggregateAgendaItem = {
    _count: AgendaItemCountAggregateOutputType | null
    _min: AgendaItemMinAggregateOutputType | null
    _max: AgendaItemMaxAggregateOutputType | null
  }

  export type AgendaItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    startTime: string | null
    endTime: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionId: string | null
  }

  export type AgendaItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    startTime: string | null
    endTime: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sessionId: string | null
  }

  export type AgendaItemCountAggregateOutputType = {
    id: number
    title: number
    startTime: number
    endTime: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    sessionId: number
    _all: number
  }


  export type AgendaItemMinAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    sessionId?: true
  }

  export type AgendaItemMaxAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    sessionId?: true
  }

  export type AgendaItemCountAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    sessionId?: true
    _all?: true
  }

  export type AgendaItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItem to aggregate.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaItems
    **/
    _count?: true | AgendaItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaItemMaxAggregateInputType
  }

  export type GetAgendaItemAggregateType<T extends AgendaItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaItem[P]>
      : GetScalarType<T[P], AggregateAgendaItem[P]>
  }




  export type AgendaItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemWhereInput
    orderBy?: AgendaItemOrderByWithAggregationInput | AgendaItemOrderByWithAggregationInput[]
    by: AgendaItemScalarFieldEnum[] | AgendaItemScalarFieldEnum
    having?: AgendaItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaItemCountAggregateInputType | true
    _min?: AgendaItemMinAggregateInputType
    _max?: AgendaItemMaxAggregateInputType
  }

  export type AgendaItemGroupByOutputType = {
    id: string
    title: string
    startTime: string
    endTime: string
    type: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    sessionId: string
    _count: AgendaItemCountAggregateOutputType | null
    _min: AgendaItemMinAggregateOutputType | null
    _max: AgendaItemMaxAggregateOutputType | null
  }

  type GetAgendaItemGroupByPayload<T extends AgendaItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaItemGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaItemGroupByOutputType[P]>
        }
      >
    >


  export type AgendaItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionId?: boolean
    session?: boolean | AgendaSessionDefaultArgs<ExtArgs>
    speakers?: boolean | AgendaItem$speakersArgs<ExtArgs>
    _count?: boolean | AgendaItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agendaItem"]>



  export type AgendaItemSelectScalar = {
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessionId?: boolean
  }

  export type AgendaItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "startTime" | "endTime" | "type" | "description" | "createdAt" | "updatedAt" | "sessionId", ExtArgs["result"]["agendaItem"]>
  export type AgendaItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AgendaSessionDefaultArgs<ExtArgs>
    speakers?: boolean | AgendaItem$speakersArgs<ExtArgs>
    _count?: boolean | AgendaItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgendaItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaItem"
    objects: {
      session: Prisma.$AgendaSessionPayload<ExtArgs>
      speakers: Prisma.$AgendaItemSpeakerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      startTime: string
      endTime: string
      type: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      sessionId: string
    }, ExtArgs["result"]["agendaItem"]>
    composites: {}
  }

  type AgendaItemGetPayload<S extends boolean | null | undefined | AgendaItemDefaultArgs> = $Result.GetResult<Prisma.$AgendaItemPayload, S>

  type AgendaItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaItemCountAggregateInputType | true
    }

  export interface AgendaItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaItem'], meta: { name: 'AgendaItem' } }
    /**
     * Find zero or one AgendaItem that matches the filter.
     * @param {AgendaItemFindUniqueArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaItemFindUniqueArgs>(args: SelectSubset<T, AgendaItemFindUniqueArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaItemFindUniqueOrThrowArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemFindFirstArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaItemFindFirstArgs>(args?: SelectSubset<T, AgendaItemFindFirstArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemFindFirstOrThrowArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaItems
     * const agendaItems = await prisma.agendaItem.findMany()
     * 
     * // Get first 10 AgendaItems
     * const agendaItems = await prisma.agendaItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaItemWithIdOnly = await prisma.agendaItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaItemFindManyArgs>(args?: SelectSubset<T, AgendaItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaItem.
     * @param {AgendaItemCreateArgs} args - Arguments to create a AgendaItem.
     * @example
     * // Create one AgendaItem
     * const AgendaItem = await prisma.agendaItem.create({
     *   data: {
     *     // ... data to create a AgendaItem
     *   }
     * })
     * 
     */
    create<T extends AgendaItemCreateArgs>(args: SelectSubset<T, AgendaItemCreateArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaItems.
     * @param {AgendaItemCreateManyArgs} args - Arguments to create many AgendaItems.
     * @example
     * // Create many AgendaItems
     * const agendaItem = await prisma.agendaItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaItemCreateManyArgs>(args?: SelectSubset<T, AgendaItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaItem.
     * @param {AgendaItemDeleteArgs} args - Arguments to delete one AgendaItem.
     * @example
     * // Delete one AgendaItem
     * const AgendaItem = await prisma.agendaItem.delete({
     *   where: {
     *     // ... filter to delete one AgendaItem
     *   }
     * })
     * 
     */
    delete<T extends AgendaItemDeleteArgs>(args: SelectSubset<T, AgendaItemDeleteArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaItem.
     * @param {AgendaItemUpdateArgs} args - Arguments to update one AgendaItem.
     * @example
     * // Update one AgendaItem
     * const agendaItem = await prisma.agendaItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaItemUpdateArgs>(args: SelectSubset<T, AgendaItemUpdateArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaItems.
     * @param {AgendaItemDeleteManyArgs} args - Arguments to filter AgendaItems to delete.
     * @example
     * // Delete a few AgendaItems
     * const { count } = await prisma.agendaItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaItemDeleteManyArgs>(args?: SelectSubset<T, AgendaItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaItems
     * const agendaItem = await prisma.agendaItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaItemUpdateManyArgs>(args: SelectSubset<T, AgendaItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaItem.
     * @param {AgendaItemUpsertArgs} args - Arguments to update or create a AgendaItem.
     * @example
     * // Update or create a AgendaItem
     * const agendaItem = await prisma.agendaItem.upsert({
     *   create: {
     *     // ... data to create a AgendaItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaItem we want to update
     *   }
     * })
     */
    upsert<T extends AgendaItemUpsertArgs>(args: SelectSubset<T, AgendaItemUpsertArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItems that matches the filter.
     * @param {AgendaItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaItem = await prisma.agendaItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaItem.
     * @param {AgendaItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaItem = await prisma.agendaItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemCountArgs} args - Arguments to filter AgendaItems to count.
     * @example
     * // Count the number of AgendaItems
     * const count = await prisma.agendaItem.count({
     *   where: {
     *     // ... the filter for the AgendaItems we want to count
     *   }
     * })
    **/
    count<T extends AgendaItemCountArgs>(
      args?: Subset<T, AgendaItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaItemAggregateArgs>(args: Subset<T, AgendaItemAggregateArgs>): Prisma.PrismaPromise<GetAgendaItemAggregateType<T>>

    /**
     * Group by AgendaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaItemGroupByArgs['orderBy'] }
        : { orderBy?: AgendaItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaItem model
   */
  readonly fields: AgendaItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AgendaSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgendaSessionDefaultArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    speakers<T extends AgendaItem$speakersArgs<ExtArgs> = {}>(args?: Subset<T, AgendaItem$speakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaItem model
   */
  interface AgendaItemFieldRefs {
    readonly id: FieldRef<"AgendaItem", 'String'>
    readonly title: FieldRef<"AgendaItem", 'String'>
    readonly startTime: FieldRef<"AgendaItem", 'String'>
    readonly endTime: FieldRef<"AgendaItem", 'String'>
    readonly type: FieldRef<"AgendaItem", 'String'>
    readonly description: FieldRef<"AgendaItem", 'String'>
    readonly createdAt: FieldRef<"AgendaItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AgendaItem", 'DateTime'>
    readonly sessionId: FieldRef<"AgendaItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgendaItem findUnique
   */
  export type AgendaItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem findUniqueOrThrow
   */
  export type AgendaItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem findFirst
   */
  export type AgendaItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItems.
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItems.
     */
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaItem findFirstOrThrow
   */
  export type AgendaItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItems.
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItems.
     */
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaItem findMany
   */
  export type AgendaItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItems to fetch.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaItems.
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaItem create
   */
  export type AgendaItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AgendaItem.
     */
    data: XOR<AgendaItemCreateInput, AgendaItemUncheckedCreateInput>
  }

  /**
   * AgendaItem createMany
   */
  export type AgendaItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaItems.
     */
    data: AgendaItemCreateManyInput | AgendaItemCreateManyInput[]
  }

  /**
   * AgendaItem update
   */
  export type AgendaItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AgendaItem.
     */
    data: XOR<AgendaItemUpdateInput, AgendaItemUncheckedUpdateInput>
    /**
     * Choose, which AgendaItem to update.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem updateMany
   */
  export type AgendaItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaItems.
     */
    data: XOR<AgendaItemUpdateManyMutationInput, AgendaItemUncheckedUpdateManyInput>
    /**
     * Filter which AgendaItems to update
     */
    where?: AgendaItemWhereInput
    /**
     * Limit how many AgendaItems to update.
     */
    limit?: number
  }

  /**
   * AgendaItem upsert
   */
  export type AgendaItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AgendaItem to update in case it exists.
     */
    where: AgendaItemWhereUniqueInput
    /**
     * In case the AgendaItem found by the `where` argument doesn't exist, create a new AgendaItem with this data.
     */
    create: XOR<AgendaItemCreateInput, AgendaItemUncheckedCreateInput>
    /**
     * In case the AgendaItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaItemUpdateInput, AgendaItemUncheckedUpdateInput>
  }

  /**
   * AgendaItem delete
   */
  export type AgendaItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
    /**
     * Filter which AgendaItem to delete.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem deleteMany
   */
  export type AgendaItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItems to delete
     */
    where?: AgendaItemWhereInput
    /**
     * Limit how many AgendaItems to delete.
     */
    limit?: number
  }

  /**
   * AgendaItem findRaw
   */
  export type AgendaItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItem aggregateRaw
   */
  export type AgendaItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItem.speakers
   */
  export type AgendaItem$speakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    where?: AgendaItemSpeakerWhereInput
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    cursor?: AgendaItemSpeakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItem without action
   */
  export type AgendaItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemInclude<ExtArgs> | null
  }


  /**
   * Model AgendaItemSpeaker
   */

  export type AggregateAgendaItemSpeaker = {
    _count: AgendaItemSpeakerCountAggregateOutputType | null
    _min: AgendaItemSpeakerMinAggregateOutputType | null
    _max: AgendaItemSpeakerMaxAggregateOutputType | null
  }

  export type AgendaItemSpeakerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    agendaItemId: string | null
    speakerId: string | null
  }

  export type AgendaItemSpeakerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    agendaItemId: string | null
    speakerId: string | null
  }

  export type AgendaItemSpeakerCountAggregateOutputType = {
    id: number
    createdAt: number
    agendaItemId: number
    speakerId: number
    _all: number
  }


  export type AgendaItemSpeakerMinAggregateInputType = {
    id?: true
    createdAt?: true
    agendaItemId?: true
    speakerId?: true
  }

  export type AgendaItemSpeakerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    agendaItemId?: true
    speakerId?: true
  }

  export type AgendaItemSpeakerCountAggregateInputType = {
    id?: true
    createdAt?: true
    agendaItemId?: true
    speakerId?: true
    _all?: true
  }

  export type AgendaItemSpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItemSpeaker to aggregate.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaItemSpeakers
    **/
    _count?: true | AgendaItemSpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaItemSpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaItemSpeakerMaxAggregateInputType
  }

  export type GetAgendaItemSpeakerAggregateType<T extends AgendaItemSpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaItemSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaItemSpeaker[P]>
      : GetScalarType<T[P], AggregateAgendaItemSpeaker[P]>
  }




  export type AgendaItemSpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemSpeakerWhereInput
    orderBy?: AgendaItemSpeakerOrderByWithAggregationInput | AgendaItemSpeakerOrderByWithAggregationInput[]
    by: AgendaItemSpeakerScalarFieldEnum[] | AgendaItemSpeakerScalarFieldEnum
    having?: AgendaItemSpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaItemSpeakerCountAggregateInputType | true
    _min?: AgendaItemSpeakerMinAggregateInputType
    _max?: AgendaItemSpeakerMaxAggregateInputType
  }

  export type AgendaItemSpeakerGroupByOutputType = {
    id: string
    createdAt: Date
    agendaItemId: string
    speakerId: string
    _count: AgendaItemSpeakerCountAggregateOutputType | null
    _min: AgendaItemSpeakerMinAggregateOutputType | null
    _max: AgendaItemSpeakerMaxAggregateOutputType | null
  }

  type GetAgendaItemSpeakerGroupByPayload<T extends AgendaItemSpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaItemSpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaItemSpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaItemSpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaItemSpeakerGroupByOutputType[P]>
        }
      >
    >


  export type AgendaItemSpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    agendaItemId?: boolean
    speakerId?: boolean
    agendaItem?: boolean | AgendaItemDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agendaItemSpeaker"]>



  export type AgendaItemSpeakerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    agendaItemId?: boolean
    speakerId?: boolean
  }

  export type AgendaItemSpeakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "agendaItemId" | "speakerId", ExtArgs["result"]["agendaItemSpeaker"]>
  export type AgendaItemSpeakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agendaItem?: boolean | AgendaItemDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }

  export type $AgendaItemSpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaItemSpeaker"
    objects: {
      agendaItem: Prisma.$AgendaItemPayload<ExtArgs>
      speaker: Prisma.$SpeakerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      agendaItemId: string
      speakerId: string
    }, ExtArgs["result"]["agendaItemSpeaker"]>
    composites: {}
  }

  type AgendaItemSpeakerGetPayload<S extends boolean | null | undefined | AgendaItemSpeakerDefaultArgs> = $Result.GetResult<Prisma.$AgendaItemSpeakerPayload, S>

  type AgendaItemSpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaItemSpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaItemSpeakerCountAggregateInputType | true
    }

  export interface AgendaItemSpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaItemSpeaker'], meta: { name: 'AgendaItemSpeaker' } }
    /**
     * Find zero or one AgendaItemSpeaker that matches the filter.
     * @param {AgendaItemSpeakerFindUniqueArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaItemSpeakerFindUniqueArgs>(args: SelectSubset<T, AgendaItemSpeakerFindUniqueArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaItemSpeaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaItemSpeakerFindUniqueOrThrowArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaItemSpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaItemSpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItemSpeaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerFindFirstArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaItemSpeakerFindFirstArgs>(args?: SelectSubset<T, AgendaItemSpeakerFindFirstArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItemSpeaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerFindFirstOrThrowArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaItemSpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaItemSpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItemSpeakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaItemSpeakers
     * const agendaItemSpeakers = await prisma.agendaItemSpeaker.findMany()
     * 
     * // Get first 10 AgendaItemSpeakers
     * const agendaItemSpeakers = await prisma.agendaItemSpeaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaItemSpeakerWithIdOnly = await prisma.agendaItemSpeaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaItemSpeakerFindManyArgs>(args?: SelectSubset<T, AgendaItemSpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaItemSpeaker.
     * @param {AgendaItemSpeakerCreateArgs} args - Arguments to create a AgendaItemSpeaker.
     * @example
     * // Create one AgendaItemSpeaker
     * const AgendaItemSpeaker = await prisma.agendaItemSpeaker.create({
     *   data: {
     *     // ... data to create a AgendaItemSpeaker
     *   }
     * })
     * 
     */
    create<T extends AgendaItemSpeakerCreateArgs>(args: SelectSubset<T, AgendaItemSpeakerCreateArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaItemSpeakers.
     * @param {AgendaItemSpeakerCreateManyArgs} args - Arguments to create many AgendaItemSpeakers.
     * @example
     * // Create many AgendaItemSpeakers
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaItemSpeakerCreateManyArgs>(args?: SelectSubset<T, AgendaItemSpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaItemSpeaker.
     * @param {AgendaItemSpeakerDeleteArgs} args - Arguments to delete one AgendaItemSpeaker.
     * @example
     * // Delete one AgendaItemSpeaker
     * const AgendaItemSpeaker = await prisma.agendaItemSpeaker.delete({
     *   where: {
     *     // ... filter to delete one AgendaItemSpeaker
     *   }
     * })
     * 
     */
    delete<T extends AgendaItemSpeakerDeleteArgs>(args: SelectSubset<T, AgendaItemSpeakerDeleteArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaItemSpeaker.
     * @param {AgendaItemSpeakerUpdateArgs} args - Arguments to update one AgendaItemSpeaker.
     * @example
     * // Update one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaItemSpeakerUpdateArgs>(args: SelectSubset<T, AgendaItemSpeakerUpdateArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaItemSpeakers.
     * @param {AgendaItemSpeakerDeleteManyArgs} args - Arguments to filter AgendaItemSpeakers to delete.
     * @example
     * // Delete a few AgendaItemSpeakers
     * const { count } = await prisma.agendaItemSpeaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaItemSpeakerDeleteManyArgs>(args?: SelectSubset<T, AgendaItemSpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaItemSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaItemSpeakers
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaItemSpeakerUpdateManyArgs>(args: SelectSubset<T, AgendaItemSpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaItemSpeaker.
     * @param {AgendaItemSpeakerUpsertArgs} args - Arguments to update or create a AgendaItemSpeaker.
     * @example
     * // Update or create a AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.upsert({
     *   create: {
     *     // ... data to create a AgendaItemSpeaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaItemSpeaker we want to update
     *   }
     * })
     */
    upsert<T extends AgendaItemSpeakerUpsertArgs>(args: SelectSubset<T, AgendaItemSpeakerUpsertArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItemSpeakers that matches the filter.
     * @param {AgendaItemSpeakerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaItemSpeakerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaItemSpeaker.
     * @param {AgendaItemSpeakerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaItemSpeakerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaItemSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerCountArgs} args - Arguments to filter AgendaItemSpeakers to count.
     * @example
     * // Count the number of AgendaItemSpeakers
     * const count = await prisma.agendaItemSpeaker.count({
     *   where: {
     *     // ... the filter for the AgendaItemSpeakers we want to count
     *   }
     * })
    **/
    count<T extends AgendaItemSpeakerCountArgs>(
      args?: Subset<T, AgendaItemSpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaItemSpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaItemSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaItemSpeakerAggregateArgs>(args: Subset<T, AgendaItemSpeakerAggregateArgs>): Prisma.PrismaPromise<GetAgendaItemSpeakerAggregateType<T>>

    /**
     * Group by AgendaItemSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaItemSpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaItemSpeakerGroupByArgs['orderBy'] }
        : { orderBy?: AgendaItemSpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaItemSpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaItemSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaItemSpeaker model
   */
  readonly fields: AgendaItemSpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaItemSpeaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaItemSpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agendaItem<T extends AgendaItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgendaItemDefaultArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    speaker<T extends SpeakerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeakerDefaultArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaItemSpeaker model
   */
  interface AgendaItemSpeakerFieldRefs {
    readonly id: FieldRef<"AgendaItemSpeaker", 'String'>
    readonly createdAt: FieldRef<"AgendaItemSpeaker", 'DateTime'>
    readonly agendaItemId: FieldRef<"AgendaItemSpeaker", 'String'>
    readonly speakerId: FieldRef<"AgendaItemSpeaker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgendaItemSpeaker findUnique
   */
  export type AgendaItemSpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker findUniqueOrThrow
   */
  export type AgendaItemSpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker findFirst
   */
  export type AgendaItemSpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItemSpeakers.
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItemSpeakers.
     */
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItemSpeaker findFirstOrThrow
   */
  export type AgendaItemSpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItemSpeakers.
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItemSpeakers.
     */
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItemSpeaker findMany
   */
  export type AgendaItemSpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeakers to fetch.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaItemSpeakers.
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItemSpeaker create
   */
  export type AgendaItemSpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * The data needed to create a AgendaItemSpeaker.
     */
    data: XOR<AgendaItemSpeakerCreateInput, AgendaItemSpeakerUncheckedCreateInput>
  }

  /**
   * AgendaItemSpeaker createMany
   */
  export type AgendaItemSpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaItemSpeakers.
     */
    data: AgendaItemSpeakerCreateManyInput | AgendaItemSpeakerCreateManyInput[]
  }

  /**
   * AgendaItemSpeaker update
   */
  export type AgendaItemSpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * The data needed to update a AgendaItemSpeaker.
     */
    data: XOR<AgendaItemSpeakerUpdateInput, AgendaItemSpeakerUncheckedUpdateInput>
    /**
     * Choose, which AgendaItemSpeaker to update.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker updateMany
   */
  export type AgendaItemSpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaItemSpeakers.
     */
    data: XOR<AgendaItemSpeakerUpdateManyMutationInput, AgendaItemSpeakerUncheckedUpdateManyInput>
    /**
     * Filter which AgendaItemSpeakers to update
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * Limit how many AgendaItemSpeakers to update.
     */
    limit?: number
  }

  /**
   * AgendaItemSpeaker upsert
   */
  export type AgendaItemSpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * The filter to search for the AgendaItemSpeaker to update in case it exists.
     */
    where: AgendaItemSpeakerWhereUniqueInput
    /**
     * In case the AgendaItemSpeaker found by the `where` argument doesn't exist, create a new AgendaItemSpeaker with this data.
     */
    create: XOR<AgendaItemSpeakerCreateInput, AgendaItemSpeakerUncheckedCreateInput>
    /**
     * In case the AgendaItemSpeaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaItemSpeakerUpdateInput, AgendaItemSpeakerUncheckedUpdateInput>
  }

  /**
   * AgendaItemSpeaker delete
   */
  export type AgendaItemSpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
    /**
     * Filter which AgendaItemSpeaker to delete.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker deleteMany
   */
  export type AgendaItemSpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItemSpeakers to delete
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * Limit how many AgendaItemSpeakers to delete.
     */
    limit?: number
  }

  /**
   * AgendaItemSpeaker findRaw
   */
  export type AgendaItemSpeakerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItemSpeaker aggregateRaw
   */
  export type AgendaItemSpeakerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItemSpeaker without action
   */
  export type AgendaItemSpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgendaItemSpeakerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    venue: 'venue',
    website: 'website',
    image: 'image',
    year: 'year',
    currency: 'currency',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectStatsScalarFieldEnum: {
    id: 'id',
    speakers: 'speakers',
    partners: 'partners',
    mediaPartners: 'mediaPartners',
    sponsors: 'sponsors',
    exhibitors: 'exhibitors',
    delegates: 'delegates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ProjectStatsScalarFieldEnum = (typeof ProjectStatsScalarFieldEnum)[keyof typeof ProjectStatsScalarFieldEnum]


  export const AttendeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    jobTitle: 'jobTitle',
    checkedIn: 'checkedIn',
    checkinTime: 'checkinTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type AttendeeScalarFieldEnum = (typeof AttendeeScalarFieldEnum)[keyof typeof AttendeeScalarFieldEnum]


  export const DelegateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    jobTitle: 'jobTitle',
    address: 'address',
    booth: 'booth',
    status: 'status',
    description: 'description',
    priority: 'priority',
    featured: 'featured',
    type: 'type',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type DelegateScalarFieldEnum = (typeof DelegateScalarFieldEnum)[keyof typeof DelegateScalarFieldEnum]


  export const SpeakerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    position: 'position',
    bio: 'bio',
    featured: 'featured',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type SpeakerScalarFieldEnum = (typeof SpeakerScalarFieldEnum)[keyof typeof SpeakerScalarFieldEnum]


  export const MarketingCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    total: 'total',
    revenue: 'revenue',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type MarketingCampaignScalarFieldEnum = (typeof MarketingCampaignScalarFieldEnum)[keyof typeof MarketingCampaignScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    contact: 'contact',
    company: 'company',
    type: 'type',
    date: 'date',
    qualifyStatus: 'qualifyStatus',
    salesStatus: 'salesStatus',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    date: 'date',
    venue: 'venue',
    day: 'day',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ExhibitorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    boothNumber: 'boothNumber',
    category: 'category',
    status: 'status',
    size: 'size',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ExhibitorScalarFieldEnum = (typeof ExhibitorScalarFieldEnum)[keyof typeof ExhibitorScalarFieldEnum]


  export const SponsorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    level: 'level',
    amount: 'amount',
    status: 'status',
    benefits: 'benefits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type SponsorScalarFieldEnum = (typeof SponsorScalarFieldEnum)[keyof typeof SponsorScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    type: 'type',
    website: 'website',
    status: 'status',
    contribution: 'contribution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const MediaPartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    website: 'website',
    type: 'type',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type MediaPartnerScalarFieldEnum = (typeof MediaPartnerScalarFieldEnum)[keyof typeof MediaPartnerScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const EnquiryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type EnquiryScalarFieldEnum = (typeof EnquiryScalarFieldEnum)[keyof typeof EnquiryScalarFieldEnum]


  export const UtmDataScalarFieldEnum: {
    id: 'id',
    source: 'source',
    medium: 'medium',
    campaign: 'campaign',
    term: 'term',
    content: 'content',
    visits: 'visits',
    conversions: 'conversions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type UtmDataScalarFieldEnum = (typeof UtmDataScalarFieldEnum)[keyof typeof UtmDataScalarFieldEnum]


  export const AgendaDayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    dayNumber: 'dayNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type AgendaDayScalarFieldEnum = (typeof AgendaDayScalarFieldEnum)[keyof typeof AgendaDayScalarFieldEnum]


  export const AgendaSessionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    startTime: 'startTime',
    endTime: 'endTime',
    color: 'color',
    venue: 'venue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dayId: 'dayId'
  };

  export type AgendaSessionScalarFieldEnum = (typeof AgendaSessionScalarFieldEnum)[keyof typeof AgendaSessionScalarFieldEnum]


  export const AgendaItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    startTime: 'startTime',
    endTime: 'endTime',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sessionId: 'sessionId'
  };

  export type AgendaItemScalarFieldEnum = (typeof AgendaItemScalarFieldEnum)[keyof typeof AgendaItemScalarFieldEnum]


  export const AgendaItemSpeakerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    agendaItemId: 'agendaItemId',
    speakerId: 'speakerId'
  };

  export type AgendaItemSpeakerScalarFieldEnum = (typeof AgendaItemSpeakerScalarFieldEnum)[keyof typeof AgendaItemSpeakerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    venue?: StringNullableFilter<"Project"> | string | null
    website?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    year?: StringFilter<"Project"> | string
    currency?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    stats?: XOR<ProjectStatsNullableScalarRelationFilter, ProjectStatsWhereInput> | null
    attendees?: AttendeeListRelationFilter
    delegates?: DelegateListRelationFilter
    speakers?: SpeakerListRelationFilter
    marketingCampaigns?: MarketingCampaignListRelationFilter
    leads?: LeadListRelationFilter
    sessions?: SessionListRelationFilter
    exhibitors?: ExhibitorListRelationFilter
    sponsors?: SponsorListRelationFilter
    partners?: PartnerListRelationFilter
    mediaPartners?: MediaPartnerListRelationFilter
    orders?: OrderListRelationFilter
    enquiries?: EnquiryListRelationFilter
    utmData?: UtmDataListRelationFilter
    agendaDays?: AgendaDayListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    image?: SortOrder
    year?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stats?: ProjectStatsOrderByWithRelationInput
    attendees?: AttendeeOrderByRelationAggregateInput
    delegates?: DelegateOrderByRelationAggregateInput
    speakers?: SpeakerOrderByRelationAggregateInput
    marketingCampaigns?: MarketingCampaignOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    exhibitors?: ExhibitorOrderByRelationAggregateInput
    sponsors?: SponsorOrderByRelationAggregateInput
    partners?: PartnerOrderByRelationAggregateInput
    mediaPartners?: MediaPartnerOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    enquiries?: EnquiryOrderByRelationAggregateInput
    utmData?: UtmDataOrderByRelationAggregateInput
    agendaDays?: AgendaDayOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    venue?: StringNullableFilter<"Project"> | string | null
    website?: StringNullableFilter<"Project"> | string | null
    image?: StringNullableFilter<"Project"> | string | null
    year?: StringFilter<"Project"> | string
    currency?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    stats?: XOR<ProjectStatsNullableScalarRelationFilter, ProjectStatsWhereInput> | null
    attendees?: AttendeeListRelationFilter
    delegates?: DelegateListRelationFilter
    speakers?: SpeakerListRelationFilter
    marketingCampaigns?: MarketingCampaignListRelationFilter
    leads?: LeadListRelationFilter
    sessions?: SessionListRelationFilter
    exhibitors?: ExhibitorListRelationFilter
    sponsors?: SponsorListRelationFilter
    partners?: PartnerListRelationFilter
    mediaPartners?: MediaPartnerListRelationFilter
    orders?: OrderListRelationFilter
    enquiries?: EnquiryListRelationFilter
    utmData?: UtmDataListRelationFilter
    agendaDays?: AgendaDayListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    image?: SortOrder
    year?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    venue?: StringNullableWithAggregatesFilter<"Project"> | string | null
    website?: StringNullableWithAggregatesFilter<"Project"> | string | null
    image?: StringNullableWithAggregatesFilter<"Project"> | string | null
    year?: StringWithAggregatesFilter<"Project"> | string
    currency?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectStatsWhereInput = {
    AND?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    OR?: ProjectStatsWhereInput[]
    NOT?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    id?: StringFilter<"ProjectStats"> | string
    speakers?: IntFilter<"ProjectStats"> | number
    partners?: IntFilter<"ProjectStats"> | number
    mediaPartners?: IntFilter<"ProjectStats"> | number
    sponsors?: IntFilter<"ProjectStats"> | number
    exhibitors?: IntFilter<"ProjectStats"> | number
    delegates?: IntFilter<"ProjectStats"> | number
    createdAt?: DateTimeFilter<"ProjectStats"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStats"> | Date | string
    projectId?: StringFilter<"ProjectStats"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectStatsOrderByWithRelationInput = {
    id?: SortOrder
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    OR?: ProjectStatsWhereInput[]
    NOT?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    speakers?: IntFilter<"ProjectStats"> | number
    partners?: IntFilter<"ProjectStats"> | number
    mediaPartners?: IntFilter<"ProjectStats"> | number
    sponsors?: IntFilter<"ProjectStats"> | number
    exhibitors?: IntFilter<"ProjectStats"> | number
    delegates?: IntFilter<"ProjectStats"> | number
    createdAt?: DateTimeFilter<"ProjectStats"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStats"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type ProjectStatsOrderByWithAggregationInput = {
    id?: SortOrder
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ProjectStatsCountOrderByAggregateInput
    _avg?: ProjectStatsAvgOrderByAggregateInput
    _max?: ProjectStatsMaxOrderByAggregateInput
    _min?: ProjectStatsMinOrderByAggregateInput
    _sum?: ProjectStatsSumOrderByAggregateInput
  }

  export type ProjectStatsScalarWhereWithAggregatesInput = {
    AND?: ProjectStatsScalarWhereWithAggregatesInput | ProjectStatsScalarWhereWithAggregatesInput[]
    OR?: ProjectStatsScalarWhereWithAggregatesInput[]
    NOT?: ProjectStatsScalarWhereWithAggregatesInput | ProjectStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectStats"> | string
    speakers?: IntWithAggregatesFilter<"ProjectStats"> | number
    partners?: IntWithAggregatesFilter<"ProjectStats"> | number
    mediaPartners?: IntWithAggregatesFilter<"ProjectStats"> | number
    sponsors?: IntWithAggregatesFilter<"ProjectStats"> | number
    exhibitors?: IntWithAggregatesFilter<"ProjectStats"> | number
    delegates?: IntWithAggregatesFilter<"ProjectStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectStats"> | Date | string
    projectId?: StringWithAggregatesFilter<"ProjectStats"> | string
  }

  export type AttendeeWhereInput = {
    AND?: AttendeeWhereInput | AttendeeWhereInput[]
    OR?: AttendeeWhereInput[]
    NOT?: AttendeeWhereInput | AttendeeWhereInput[]
    id?: StringFilter<"Attendee"> | string
    name?: StringFilter<"Attendee"> | string
    email?: StringFilter<"Attendee"> | string
    phone?: StringNullableFilter<"Attendee"> | string | null
    company?: StringNullableFilter<"Attendee"> | string | null
    jobTitle?: StringNullableFilter<"Attendee"> | string | null
    checkedIn?: BoolFilter<"Attendee"> | boolean
    checkinTime?: DateTimeNullableFilter<"Attendee"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendee"> | Date | string
    updatedAt?: DateTimeFilter<"Attendee"> | Date | string
    projectId?: StringFilter<"Attendee"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type AttendeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type AttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendeeWhereInput | AttendeeWhereInput[]
    OR?: AttendeeWhereInput[]
    NOT?: AttendeeWhereInput | AttendeeWhereInput[]
    name?: StringFilter<"Attendee"> | string
    email?: StringFilter<"Attendee"> | string
    phone?: StringNullableFilter<"Attendee"> | string | null
    company?: StringNullableFilter<"Attendee"> | string | null
    jobTitle?: StringNullableFilter<"Attendee"> | string | null
    checkedIn?: BoolFilter<"Attendee"> | boolean
    checkinTime?: DateTimeNullableFilter<"Attendee"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendee"> | Date | string
    updatedAt?: DateTimeFilter<"Attendee"> | Date | string
    projectId?: StringFilter<"Attendee"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type AttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: AttendeeCountOrderByAggregateInput
    _max?: AttendeeMaxOrderByAggregateInput
    _min?: AttendeeMinOrderByAggregateInput
  }

  export type AttendeeScalarWhereWithAggregatesInput = {
    AND?: AttendeeScalarWhereWithAggregatesInput | AttendeeScalarWhereWithAggregatesInput[]
    OR?: AttendeeScalarWhereWithAggregatesInput[]
    NOT?: AttendeeScalarWhereWithAggregatesInput | AttendeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendee"> | string
    name?: StringWithAggregatesFilter<"Attendee"> | string
    email?: StringWithAggregatesFilter<"Attendee"> | string
    phone?: StringNullableWithAggregatesFilter<"Attendee"> | string | null
    company?: StringNullableWithAggregatesFilter<"Attendee"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Attendee"> | string | null
    checkedIn?: BoolWithAggregatesFilter<"Attendee"> | boolean
    checkinTime?: DateTimeNullableWithAggregatesFilter<"Attendee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendee"> | Date | string
    projectId?: StringWithAggregatesFilter<"Attendee"> | string
  }

  export type DelegateWhereInput = {
    AND?: DelegateWhereInput | DelegateWhereInput[]
    OR?: DelegateWhereInput[]
    NOT?: DelegateWhereInput | DelegateWhereInput[]
    id?: StringFilter<"Delegate"> | string
    name?: StringFilter<"Delegate"> | string
    email?: StringNullableFilter<"Delegate"> | string | null
    phone?: StringNullableFilter<"Delegate"> | string | null
    company?: StringNullableFilter<"Delegate"> | string | null
    jobTitle?: StringNullableFilter<"Delegate"> | string | null
    address?: StringNullableFilter<"Delegate"> | string | null
    booth?: StringNullableFilter<"Delegate"> | string | null
    status?: StringNullableFilter<"Delegate"> | string | null
    description?: StringNullableFilter<"Delegate"> | string | null
    priority?: IntFilter<"Delegate"> | number
    featured?: BoolFilter<"Delegate"> | boolean
    type?: StringFilter<"Delegate"> | string
    image?: StringNullableFilter<"Delegate"> | string | null
    createdAt?: DateTimeFilter<"Delegate"> | Date | string
    updatedAt?: DateTimeFilter<"Delegate"> | Date | string
    projectId?: StringFilter<"Delegate"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type DelegateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    status?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    featured?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type DelegateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DelegateWhereInput | DelegateWhereInput[]
    OR?: DelegateWhereInput[]
    NOT?: DelegateWhereInput | DelegateWhereInput[]
    name?: StringFilter<"Delegate"> | string
    email?: StringNullableFilter<"Delegate"> | string | null
    phone?: StringNullableFilter<"Delegate"> | string | null
    company?: StringNullableFilter<"Delegate"> | string | null
    jobTitle?: StringNullableFilter<"Delegate"> | string | null
    address?: StringNullableFilter<"Delegate"> | string | null
    booth?: StringNullableFilter<"Delegate"> | string | null
    status?: StringNullableFilter<"Delegate"> | string | null
    description?: StringNullableFilter<"Delegate"> | string | null
    priority?: IntFilter<"Delegate"> | number
    featured?: BoolFilter<"Delegate"> | boolean
    type?: StringFilter<"Delegate"> | string
    image?: StringNullableFilter<"Delegate"> | string | null
    createdAt?: DateTimeFilter<"Delegate"> | Date | string
    updatedAt?: DateTimeFilter<"Delegate"> | Date | string
    projectId?: StringFilter<"Delegate"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type DelegateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    status?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    featured?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: DelegateCountOrderByAggregateInput
    _avg?: DelegateAvgOrderByAggregateInput
    _max?: DelegateMaxOrderByAggregateInput
    _min?: DelegateMinOrderByAggregateInput
    _sum?: DelegateSumOrderByAggregateInput
  }

  export type DelegateScalarWhereWithAggregatesInput = {
    AND?: DelegateScalarWhereWithAggregatesInput | DelegateScalarWhereWithAggregatesInput[]
    OR?: DelegateScalarWhereWithAggregatesInput[]
    NOT?: DelegateScalarWhereWithAggregatesInput | DelegateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delegate"> | string
    name?: StringWithAggregatesFilter<"Delegate"> | string
    email?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    company?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    address?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    booth?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    status?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    description?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    priority?: IntWithAggregatesFilter<"Delegate"> | number
    featured?: BoolWithAggregatesFilter<"Delegate"> | boolean
    type?: StringWithAggregatesFilter<"Delegate"> | string
    image?: StringNullableWithAggregatesFilter<"Delegate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Delegate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delegate"> | Date | string
    projectId?: StringWithAggregatesFilter<"Delegate"> | string
  }

  export type SpeakerWhereInput = {
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
    id?: StringFilter<"Speaker"> | string
    name?: StringFilter<"Speaker"> | string
    email?: StringNullableFilter<"Speaker"> | string | null
    phone?: StringNullableFilter<"Speaker"> | string | null
    company?: StringNullableFilter<"Speaker"> | string | null
    position?: StringNullableFilter<"Speaker"> | string | null
    bio?: StringNullableFilter<"Speaker"> | string | null
    featured?: BoolFilter<"Speaker"> | boolean
    image?: StringNullableFilter<"Speaker"> | string | null
    createdAt?: DateTimeFilter<"Speaker"> | Date | string
    updatedAt?: DateTimeFilter<"Speaker"> | Date | string
    projectId?: StringFilter<"Speaker"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    agendaItems?: AgendaItemSpeakerListRelationFilter
  }

  export type SpeakerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    position?: SortOrder
    bio?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    agendaItems?: AgendaItemSpeakerOrderByRelationAggregateInput
  }

  export type SpeakerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
    name?: StringFilter<"Speaker"> | string
    email?: StringNullableFilter<"Speaker"> | string | null
    phone?: StringNullableFilter<"Speaker"> | string | null
    company?: StringNullableFilter<"Speaker"> | string | null
    position?: StringNullableFilter<"Speaker"> | string | null
    bio?: StringNullableFilter<"Speaker"> | string | null
    featured?: BoolFilter<"Speaker"> | boolean
    image?: StringNullableFilter<"Speaker"> | string | null
    createdAt?: DateTimeFilter<"Speaker"> | Date | string
    updatedAt?: DateTimeFilter<"Speaker"> | Date | string
    projectId?: StringFilter<"Speaker"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    agendaItems?: AgendaItemSpeakerListRelationFilter
  }, "id">

  export type SpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    position?: SortOrder
    bio?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: SpeakerCountOrderByAggregateInput
    _max?: SpeakerMaxOrderByAggregateInput
    _min?: SpeakerMinOrderByAggregateInput
  }

  export type SpeakerScalarWhereWithAggregatesInput = {
    AND?: SpeakerScalarWhereWithAggregatesInput | SpeakerScalarWhereWithAggregatesInput[]
    OR?: SpeakerScalarWhereWithAggregatesInput[]
    NOT?: SpeakerScalarWhereWithAggregatesInput | SpeakerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Speaker"> | string
    name?: StringWithAggregatesFilter<"Speaker"> | string
    email?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
    company?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
    position?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
    featured?: BoolWithAggregatesFilter<"Speaker"> | boolean
    image?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Speaker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Speaker"> | Date | string
    projectId?: StringWithAggregatesFilter<"Speaker"> | string
  }

  export type MarketingCampaignWhereInput = {
    AND?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    OR?: MarketingCampaignWhereInput[]
    NOT?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    id?: StringFilter<"MarketingCampaign"> | string
    name?: StringFilter<"MarketingCampaign"> | string
    type?: StringFilter<"MarketingCampaign"> | string
    total?: IntFilter<"MarketingCampaign"> | number
    revenue?: FloatFilter<"MarketingCampaign"> | number
    startDate?: DateTimeNullableFilter<"MarketingCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"MarketingCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketingCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingCampaign"> | Date | string
    projectId?: StringFilter<"MarketingCampaign"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type MarketingCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    total?: SortOrder
    revenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type MarketingCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    OR?: MarketingCampaignWhereInput[]
    NOT?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    name?: StringFilter<"MarketingCampaign"> | string
    type?: StringFilter<"MarketingCampaign"> | string
    total?: IntFilter<"MarketingCampaign"> | number
    revenue?: FloatFilter<"MarketingCampaign"> | number
    startDate?: DateTimeNullableFilter<"MarketingCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"MarketingCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketingCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingCampaign"> | Date | string
    projectId?: StringFilter<"MarketingCampaign"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type MarketingCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    total?: SortOrder
    revenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: MarketingCampaignCountOrderByAggregateInput
    _avg?: MarketingCampaignAvgOrderByAggregateInput
    _max?: MarketingCampaignMaxOrderByAggregateInput
    _min?: MarketingCampaignMinOrderByAggregateInput
    _sum?: MarketingCampaignSumOrderByAggregateInput
  }

  export type MarketingCampaignScalarWhereWithAggregatesInput = {
    AND?: MarketingCampaignScalarWhereWithAggregatesInput | MarketingCampaignScalarWhereWithAggregatesInput[]
    OR?: MarketingCampaignScalarWhereWithAggregatesInput[]
    NOT?: MarketingCampaignScalarWhereWithAggregatesInput | MarketingCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingCampaign"> | string
    name?: StringWithAggregatesFilter<"MarketingCampaign"> | string
    type?: StringWithAggregatesFilter<"MarketingCampaign"> | string
    total?: IntWithAggregatesFilter<"MarketingCampaign"> | number
    revenue?: FloatWithAggregatesFilter<"MarketingCampaign"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"MarketingCampaign"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"MarketingCampaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingCampaign"> | Date | string
    projectId?: StringWithAggregatesFilter<"MarketingCampaign"> | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    contact?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    type?: StringNullableFilter<"Lead"> | string | null
    date?: DateTimeNullableFilter<"Lead"> | Date | string | null
    qualifyStatus?: StringNullableFilter<"Lead"> | string | null
    salesStatus?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    projectId?: StringFilter<"Lead"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    company?: SortOrder
    type?: SortOrder
    date?: SortOrder
    qualifyStatus?: SortOrder
    salesStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    name?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    contact?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    type?: StringNullableFilter<"Lead"> | string | null
    date?: DateTimeNullableFilter<"Lead"> | Date | string | null
    qualifyStatus?: StringNullableFilter<"Lead"> | string | null
    salesStatus?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    projectId?: StringFilter<"Lead"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    company?: SortOrder
    type?: SortOrder
    date?: SortOrder
    qualifyStatus?: SortOrder
    salesStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    name?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringWithAggregatesFilter<"Lead"> | string
    contact?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    company?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    type?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    qualifyStatus?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    salesStatus?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    projectId?: StringWithAggregatesFilter<"Lead"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    title?: StringFilter<"Session"> | string
    description?: StringNullableFilter<"Session"> | string | null
    startTime?: StringFilter<"Session"> | string
    endTime?: StringFilter<"Session"> | string
    date?: DateTimeNullableFilter<"Session"> | Date | string | null
    venue?: StringNullableFilter<"Session"> | string | null
    day?: IntNullableFilter<"Session"> | number | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    projectId?: StringFilter<"Session"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    venue?: SortOrder
    day?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    title?: StringFilter<"Session"> | string
    description?: StringNullableFilter<"Session"> | string | null
    startTime?: StringFilter<"Session"> | string
    endTime?: StringFilter<"Session"> | string
    date?: DateTimeNullableFilter<"Session"> | Date | string | null
    venue?: StringNullableFilter<"Session"> | string | null
    day?: IntNullableFilter<"Session"> | number | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    projectId?: StringFilter<"Session"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    venue?: SortOrder
    day?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    title?: StringWithAggregatesFilter<"Session"> | string
    description?: StringNullableWithAggregatesFilter<"Session"> | string | null
    startTime?: StringWithAggregatesFilter<"Session"> | string
    endTime?: StringWithAggregatesFilter<"Session"> | string
    date?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    venue?: StringNullableWithAggregatesFilter<"Session"> | string | null
    day?: IntNullableWithAggregatesFilter<"Session"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    projectId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type ExhibitorWhereInput = {
    AND?: ExhibitorWhereInput | ExhibitorWhereInput[]
    OR?: ExhibitorWhereInput[]
    NOT?: ExhibitorWhereInput | ExhibitorWhereInput[]
    id?: StringFilter<"Exhibitor"> | string
    name?: StringFilter<"Exhibitor"> | string
    image?: StringNullableFilter<"Exhibitor"> | string | null
    boothNumber?: StringNullableFilter<"Exhibitor"> | string | null
    category?: StringNullableFilter<"Exhibitor"> | string | null
    status?: StringNullableFilter<"Exhibitor"> | string | null
    size?: StringNullableFilter<"Exhibitor"> | string | null
    createdAt?: DateTimeFilter<"Exhibitor"> | Date | string
    updatedAt?: DateTimeFilter<"Exhibitor"> | Date | string
    projectId?: StringFilter<"Exhibitor"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ExhibitorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    status?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ExhibitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExhibitorWhereInput | ExhibitorWhereInput[]
    OR?: ExhibitorWhereInput[]
    NOT?: ExhibitorWhereInput | ExhibitorWhereInput[]
    name?: StringFilter<"Exhibitor"> | string
    image?: StringNullableFilter<"Exhibitor"> | string | null
    boothNumber?: StringNullableFilter<"Exhibitor"> | string | null
    category?: StringNullableFilter<"Exhibitor"> | string | null
    status?: StringNullableFilter<"Exhibitor"> | string | null
    size?: StringNullableFilter<"Exhibitor"> | string | null
    createdAt?: DateTimeFilter<"Exhibitor"> | Date | string
    updatedAt?: DateTimeFilter<"Exhibitor"> | Date | string
    projectId?: StringFilter<"Exhibitor"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ExhibitorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    status?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ExhibitorCountOrderByAggregateInput
    _max?: ExhibitorMaxOrderByAggregateInput
    _min?: ExhibitorMinOrderByAggregateInput
  }

  export type ExhibitorScalarWhereWithAggregatesInput = {
    AND?: ExhibitorScalarWhereWithAggregatesInput | ExhibitorScalarWhereWithAggregatesInput[]
    OR?: ExhibitorScalarWhereWithAggregatesInput[]
    NOT?: ExhibitorScalarWhereWithAggregatesInput | ExhibitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exhibitor"> | string
    name?: StringWithAggregatesFilter<"Exhibitor"> | string
    image?: StringNullableWithAggregatesFilter<"Exhibitor"> | string | null
    boothNumber?: StringNullableWithAggregatesFilter<"Exhibitor"> | string | null
    category?: StringNullableWithAggregatesFilter<"Exhibitor"> | string | null
    status?: StringNullableWithAggregatesFilter<"Exhibitor"> | string | null
    size?: StringNullableWithAggregatesFilter<"Exhibitor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exhibitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exhibitor"> | Date | string
    projectId?: StringWithAggregatesFilter<"Exhibitor"> | string
  }

  export type SponsorWhereInput = {
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    id?: StringFilter<"Sponsor"> | string
    name?: StringFilter<"Sponsor"> | string
    image?: StringNullableFilter<"Sponsor"> | string | null
    level?: StringFilter<"Sponsor"> | string
    amount?: StringNullableFilter<"Sponsor"> | string | null
    status?: StringNullableFilter<"Sponsor"> | string | null
    benefits?: StringNullableFilter<"Sponsor"> | string | null
    createdAt?: DateTimeFilter<"Sponsor"> | Date | string
    updatedAt?: DateTimeFilter<"Sponsor"> | Date | string
    projectId?: StringFilter<"Sponsor"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type SponsorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    level?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type SponsorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    name?: StringFilter<"Sponsor"> | string
    image?: StringNullableFilter<"Sponsor"> | string | null
    level?: StringFilter<"Sponsor"> | string
    amount?: StringNullableFilter<"Sponsor"> | string | null
    status?: StringNullableFilter<"Sponsor"> | string | null
    benefits?: StringNullableFilter<"Sponsor"> | string | null
    createdAt?: DateTimeFilter<"Sponsor"> | Date | string
    updatedAt?: DateTimeFilter<"Sponsor"> | Date | string
    projectId?: StringFilter<"Sponsor"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type SponsorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    level?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: SponsorCountOrderByAggregateInput
    _max?: SponsorMaxOrderByAggregateInput
    _min?: SponsorMinOrderByAggregateInput
  }

  export type SponsorScalarWhereWithAggregatesInput = {
    AND?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    OR?: SponsorScalarWhereWithAggregatesInput[]
    NOT?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sponsor"> | string
    name?: StringWithAggregatesFilter<"Sponsor"> | string
    image?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    level?: StringWithAggregatesFilter<"Sponsor"> | string
    amount?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    status?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    benefits?: StringNullableWithAggregatesFilter<"Sponsor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sponsor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sponsor"> | Date | string
    projectId?: StringWithAggregatesFilter<"Sponsor"> | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    image?: StringNullableFilter<"Partner"> | string | null
    type?: StringNullableFilter<"Partner"> | string | null
    website?: StringNullableFilter<"Partner"> | string | null
    status?: StringNullableFilter<"Partner"> | string | null
    contribution?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    projectId?: StringFilter<"Partner"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    website?: SortOrder
    status?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    name?: StringFilter<"Partner"> | string
    image?: StringNullableFilter<"Partner"> | string | null
    type?: StringNullableFilter<"Partner"> | string | null
    website?: StringNullableFilter<"Partner"> | string | null
    status?: StringNullableFilter<"Partner"> | string | null
    contribution?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    projectId?: StringFilter<"Partner"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    website?: SortOrder
    status?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    image?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    type?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    website?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    status?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    contribution?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    projectId?: StringWithAggregatesFilter<"Partner"> | string
  }

  export type MediaPartnerWhereInput = {
    AND?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    OR?: MediaPartnerWhereInput[]
    NOT?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    id?: StringFilter<"MediaPartner"> | string
    name?: StringFilter<"MediaPartner"> | string
    image?: StringNullableFilter<"MediaPartner"> | string | null
    website?: StringNullableFilter<"MediaPartner"> | string | null
    type?: StringNullableFilter<"MediaPartner"> | string | null
    priority?: IntFilter<"MediaPartner"> | number
    createdAt?: DateTimeFilter<"MediaPartner"> | Date | string
    updatedAt?: DateTimeFilter<"MediaPartner"> | Date | string
    projectId?: StringFilter<"MediaPartner"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type MediaPartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    website?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type MediaPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    OR?: MediaPartnerWhereInput[]
    NOT?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    name?: StringFilter<"MediaPartner"> | string
    image?: StringNullableFilter<"MediaPartner"> | string | null
    website?: StringNullableFilter<"MediaPartner"> | string | null
    type?: StringNullableFilter<"MediaPartner"> | string | null
    priority?: IntFilter<"MediaPartner"> | number
    createdAt?: DateTimeFilter<"MediaPartner"> | Date | string
    updatedAt?: DateTimeFilter<"MediaPartner"> | Date | string
    projectId?: StringFilter<"MediaPartner"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type MediaPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    website?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: MediaPartnerCountOrderByAggregateInput
    _avg?: MediaPartnerAvgOrderByAggregateInput
    _max?: MediaPartnerMaxOrderByAggregateInput
    _min?: MediaPartnerMinOrderByAggregateInput
    _sum?: MediaPartnerSumOrderByAggregateInput
  }

  export type MediaPartnerScalarWhereWithAggregatesInput = {
    AND?: MediaPartnerScalarWhereWithAggregatesInput | MediaPartnerScalarWhereWithAggregatesInput[]
    OR?: MediaPartnerScalarWhereWithAggregatesInput[]
    NOT?: MediaPartnerScalarWhereWithAggregatesInput | MediaPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaPartner"> | string
    name?: StringWithAggregatesFilter<"MediaPartner"> | string
    image?: StringNullableWithAggregatesFilter<"MediaPartner"> | string | null
    website?: StringNullableWithAggregatesFilter<"MediaPartner"> | string | null
    type?: StringNullableWithAggregatesFilter<"MediaPartner"> | string | null
    priority?: IntWithAggregatesFilter<"MediaPartner"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MediaPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaPartner"> | Date | string
    projectId?: StringWithAggregatesFilter<"MediaPartner"> | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    projectId?: StringFilter<"Order"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    orderNumber?: StringFilter<"Order"> | string
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    projectId?: StringFilter<"Order"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    customerName?: StringWithAggregatesFilter<"Order"> | string
    customerEmail?: StringWithAggregatesFilter<"Order"> | string
    amount?: FloatWithAggregatesFilter<"Order"> | number
    status?: StringWithAggregatesFilter<"Order"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    projectId?: StringWithAggregatesFilter<"Order"> | string
  }

  export type EnquiryWhereInput = {
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    id?: StringFilter<"Enquiry"> | string
    name?: StringFilter<"Enquiry"> | string
    email?: StringFilter<"Enquiry"> | string
    phone?: StringNullableFilter<"Enquiry"> | string | null
    subject?: StringNullableFilter<"Enquiry"> | string | null
    message?: StringFilter<"Enquiry"> | string
    status?: StringFilter<"Enquiry"> | string
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    projectId?: StringFilter<"Enquiry"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type EnquiryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type EnquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    name?: StringFilter<"Enquiry"> | string
    email?: StringFilter<"Enquiry"> | string
    phone?: StringNullableFilter<"Enquiry"> | string | null
    subject?: StringNullableFilter<"Enquiry"> | string | null
    message?: StringFilter<"Enquiry"> | string
    status?: StringFilter<"Enquiry"> | string
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    projectId?: StringFilter<"Enquiry"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type EnquiryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: EnquiryCountOrderByAggregateInput
    _max?: EnquiryMaxOrderByAggregateInput
    _min?: EnquiryMinOrderByAggregateInput
  }

  export type EnquiryScalarWhereWithAggregatesInput = {
    AND?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    OR?: EnquiryScalarWhereWithAggregatesInput[]
    NOT?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enquiry"> | string
    name?: StringWithAggregatesFilter<"Enquiry"> | string
    email?: StringWithAggregatesFilter<"Enquiry"> | string
    phone?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    subject?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    message?: StringWithAggregatesFilter<"Enquiry"> | string
    status?: StringWithAggregatesFilter<"Enquiry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enquiry"> | Date | string
    projectId?: StringWithAggregatesFilter<"Enquiry"> | string
  }

  export type UtmDataWhereInput = {
    AND?: UtmDataWhereInput | UtmDataWhereInput[]
    OR?: UtmDataWhereInput[]
    NOT?: UtmDataWhereInput | UtmDataWhereInput[]
    id?: StringFilter<"UtmData"> | string
    source?: StringNullableFilter<"UtmData"> | string | null
    medium?: StringNullableFilter<"UtmData"> | string | null
    campaign?: StringNullableFilter<"UtmData"> | string | null
    term?: StringNullableFilter<"UtmData"> | string | null
    content?: StringNullableFilter<"UtmData"> | string | null
    visits?: IntFilter<"UtmData"> | number
    conversions?: IntFilter<"UtmData"> | number
    createdAt?: DateTimeFilter<"UtmData"> | Date | string
    updatedAt?: DateTimeFilter<"UtmData"> | Date | string
    projectId?: StringFilter<"UtmData"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type UtmDataOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    term?: SortOrder
    content?: SortOrder
    visits?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type UtmDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UtmDataWhereInput | UtmDataWhereInput[]
    OR?: UtmDataWhereInput[]
    NOT?: UtmDataWhereInput | UtmDataWhereInput[]
    source?: StringNullableFilter<"UtmData"> | string | null
    medium?: StringNullableFilter<"UtmData"> | string | null
    campaign?: StringNullableFilter<"UtmData"> | string | null
    term?: StringNullableFilter<"UtmData"> | string | null
    content?: StringNullableFilter<"UtmData"> | string | null
    visits?: IntFilter<"UtmData"> | number
    conversions?: IntFilter<"UtmData"> | number
    createdAt?: DateTimeFilter<"UtmData"> | Date | string
    updatedAt?: DateTimeFilter<"UtmData"> | Date | string
    projectId?: StringFilter<"UtmData"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type UtmDataOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    term?: SortOrder
    content?: SortOrder
    visits?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: UtmDataCountOrderByAggregateInput
    _avg?: UtmDataAvgOrderByAggregateInput
    _max?: UtmDataMaxOrderByAggregateInput
    _min?: UtmDataMinOrderByAggregateInput
    _sum?: UtmDataSumOrderByAggregateInput
  }

  export type UtmDataScalarWhereWithAggregatesInput = {
    AND?: UtmDataScalarWhereWithAggregatesInput | UtmDataScalarWhereWithAggregatesInput[]
    OR?: UtmDataScalarWhereWithAggregatesInput[]
    NOT?: UtmDataScalarWhereWithAggregatesInput | UtmDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UtmData"> | string
    source?: StringNullableWithAggregatesFilter<"UtmData"> | string | null
    medium?: StringNullableWithAggregatesFilter<"UtmData"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"UtmData"> | string | null
    term?: StringNullableWithAggregatesFilter<"UtmData"> | string | null
    content?: StringNullableWithAggregatesFilter<"UtmData"> | string | null
    visits?: IntWithAggregatesFilter<"UtmData"> | number
    conversions?: IntWithAggregatesFilter<"UtmData"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UtmData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UtmData"> | Date | string
    projectId?: StringWithAggregatesFilter<"UtmData"> | string
  }

  export type AgendaDayWhereInput = {
    AND?: AgendaDayWhereInput | AgendaDayWhereInput[]
    OR?: AgendaDayWhereInput[]
    NOT?: AgendaDayWhereInput | AgendaDayWhereInput[]
    id?: StringFilter<"AgendaDay"> | string
    name?: StringFilter<"AgendaDay"> | string
    date?: DateTimeFilter<"AgendaDay"> | Date | string
    dayNumber?: IntFilter<"AgendaDay"> | number
    createdAt?: DateTimeFilter<"AgendaDay"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaDay"> | Date | string
    projectId?: StringFilter<"AgendaDay"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sessions?: AgendaSessionListRelationFilter
  }

  export type AgendaDayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    sessions?: AgendaSessionOrderByRelationAggregateInput
  }

  export type AgendaDayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaDayWhereInput | AgendaDayWhereInput[]
    OR?: AgendaDayWhereInput[]
    NOT?: AgendaDayWhereInput | AgendaDayWhereInput[]
    name?: StringFilter<"AgendaDay"> | string
    date?: DateTimeFilter<"AgendaDay"> | Date | string
    dayNumber?: IntFilter<"AgendaDay"> | number
    createdAt?: DateTimeFilter<"AgendaDay"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaDay"> | Date | string
    projectId?: StringFilter<"AgendaDay"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sessions?: AgendaSessionListRelationFilter
  }, "id">

  export type AgendaDayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: AgendaDayCountOrderByAggregateInput
    _avg?: AgendaDayAvgOrderByAggregateInput
    _max?: AgendaDayMaxOrderByAggregateInput
    _min?: AgendaDayMinOrderByAggregateInput
    _sum?: AgendaDaySumOrderByAggregateInput
  }

  export type AgendaDayScalarWhereWithAggregatesInput = {
    AND?: AgendaDayScalarWhereWithAggregatesInput | AgendaDayScalarWhereWithAggregatesInput[]
    OR?: AgendaDayScalarWhereWithAggregatesInput[]
    NOT?: AgendaDayScalarWhereWithAggregatesInput | AgendaDayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaDay"> | string
    name?: StringWithAggregatesFilter<"AgendaDay"> | string
    date?: DateTimeWithAggregatesFilter<"AgendaDay"> | Date | string
    dayNumber?: IntWithAggregatesFilter<"AgendaDay"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AgendaDay"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgendaDay"> | Date | string
    projectId?: StringWithAggregatesFilter<"AgendaDay"> | string
  }

  export type AgendaSessionWhereInput = {
    AND?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    OR?: AgendaSessionWhereInput[]
    NOT?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    id?: StringFilter<"AgendaSession"> | string
    title?: StringFilter<"AgendaSession"> | string
    startTime?: StringFilter<"AgendaSession"> | string
    endTime?: StringFilter<"AgendaSession"> | string
    color?: StringNullableFilter<"AgendaSession"> | string | null
    venue?: StringNullableFilter<"AgendaSession"> | string | null
    createdAt?: DateTimeFilter<"AgendaSession"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaSession"> | Date | string
    dayId?: StringFilter<"AgendaSession"> | string
    day?: XOR<AgendaDayScalarRelationFilter, AgendaDayWhereInput>
    items?: AgendaItemListRelationFilter
  }

  export type AgendaSessionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    color?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayId?: SortOrder
    day?: AgendaDayOrderByWithRelationInput
    items?: AgendaItemOrderByRelationAggregateInput
  }

  export type AgendaSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    OR?: AgendaSessionWhereInput[]
    NOT?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    title?: StringFilter<"AgendaSession"> | string
    startTime?: StringFilter<"AgendaSession"> | string
    endTime?: StringFilter<"AgendaSession"> | string
    color?: StringNullableFilter<"AgendaSession"> | string | null
    venue?: StringNullableFilter<"AgendaSession"> | string | null
    createdAt?: DateTimeFilter<"AgendaSession"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaSession"> | Date | string
    dayId?: StringFilter<"AgendaSession"> | string
    day?: XOR<AgendaDayScalarRelationFilter, AgendaDayWhereInput>
    items?: AgendaItemListRelationFilter
  }, "id">

  export type AgendaSessionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    color?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayId?: SortOrder
    _count?: AgendaSessionCountOrderByAggregateInput
    _max?: AgendaSessionMaxOrderByAggregateInput
    _min?: AgendaSessionMinOrderByAggregateInput
  }

  export type AgendaSessionScalarWhereWithAggregatesInput = {
    AND?: AgendaSessionScalarWhereWithAggregatesInput | AgendaSessionScalarWhereWithAggregatesInput[]
    OR?: AgendaSessionScalarWhereWithAggregatesInput[]
    NOT?: AgendaSessionScalarWhereWithAggregatesInput | AgendaSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaSession"> | string
    title?: StringWithAggregatesFilter<"AgendaSession"> | string
    startTime?: StringWithAggregatesFilter<"AgendaSession"> | string
    endTime?: StringWithAggregatesFilter<"AgendaSession"> | string
    color?: StringNullableWithAggregatesFilter<"AgendaSession"> | string | null
    venue?: StringNullableWithAggregatesFilter<"AgendaSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgendaSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgendaSession"> | Date | string
    dayId?: StringWithAggregatesFilter<"AgendaSession"> | string
  }

  export type AgendaItemWhereInput = {
    AND?: AgendaItemWhereInput | AgendaItemWhereInput[]
    OR?: AgendaItemWhereInput[]
    NOT?: AgendaItemWhereInput | AgendaItemWhereInput[]
    id?: StringFilter<"AgendaItem"> | string
    title?: StringFilter<"AgendaItem"> | string
    startTime?: StringFilter<"AgendaItem"> | string
    endTime?: StringFilter<"AgendaItem"> | string
    type?: StringFilter<"AgendaItem"> | string
    description?: StringNullableFilter<"AgendaItem"> | string | null
    createdAt?: DateTimeFilter<"AgendaItem"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaItem"> | Date | string
    sessionId?: StringFilter<"AgendaItem"> | string
    session?: XOR<AgendaSessionScalarRelationFilter, AgendaSessionWhereInput>
    speakers?: AgendaItemSpeakerListRelationFilter
  }

  export type AgendaItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    session?: AgendaSessionOrderByWithRelationInput
    speakers?: AgendaItemSpeakerOrderByRelationAggregateInput
  }

  export type AgendaItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaItemWhereInput | AgendaItemWhereInput[]
    OR?: AgendaItemWhereInput[]
    NOT?: AgendaItemWhereInput | AgendaItemWhereInput[]
    title?: StringFilter<"AgendaItem"> | string
    startTime?: StringFilter<"AgendaItem"> | string
    endTime?: StringFilter<"AgendaItem"> | string
    type?: StringFilter<"AgendaItem"> | string
    description?: StringNullableFilter<"AgendaItem"> | string | null
    createdAt?: DateTimeFilter<"AgendaItem"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaItem"> | Date | string
    sessionId?: StringFilter<"AgendaItem"> | string
    session?: XOR<AgendaSessionScalarRelationFilter, AgendaSessionWhereInput>
    speakers?: AgendaItemSpeakerListRelationFilter
  }, "id">

  export type AgendaItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
    _count?: AgendaItemCountOrderByAggregateInput
    _max?: AgendaItemMaxOrderByAggregateInput
    _min?: AgendaItemMinOrderByAggregateInput
  }

  export type AgendaItemScalarWhereWithAggregatesInput = {
    AND?: AgendaItemScalarWhereWithAggregatesInput | AgendaItemScalarWhereWithAggregatesInput[]
    OR?: AgendaItemScalarWhereWithAggregatesInput[]
    NOT?: AgendaItemScalarWhereWithAggregatesInput | AgendaItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaItem"> | string
    title?: StringWithAggregatesFilter<"AgendaItem"> | string
    startTime?: StringWithAggregatesFilter<"AgendaItem"> | string
    endTime?: StringWithAggregatesFilter<"AgendaItem"> | string
    type?: StringWithAggregatesFilter<"AgendaItem"> | string
    description?: StringNullableWithAggregatesFilter<"AgendaItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgendaItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgendaItem"> | Date | string
    sessionId?: StringWithAggregatesFilter<"AgendaItem"> | string
  }

  export type AgendaItemSpeakerWhereInput = {
    AND?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    OR?: AgendaItemSpeakerWhereInput[]
    NOT?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    id?: StringFilter<"AgendaItemSpeaker"> | string
    createdAt?: DateTimeFilter<"AgendaItemSpeaker"> | Date | string
    agendaItemId?: StringFilter<"AgendaItemSpeaker"> | string
    speakerId?: StringFilter<"AgendaItemSpeaker"> | string
    agendaItem?: XOR<AgendaItemScalarRelationFilter, AgendaItemWhereInput>
    speaker?: XOR<SpeakerScalarRelationFilter, SpeakerWhereInput>
  }

  export type AgendaItemSpeakerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
    agendaItem?: AgendaItemOrderByWithRelationInput
    speaker?: SpeakerOrderByWithRelationInput
  }

  export type AgendaItemSpeakerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agendaItemId_speakerId?: AgendaItemSpeakerAgendaItemIdSpeakerIdCompoundUniqueInput
    AND?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    OR?: AgendaItemSpeakerWhereInput[]
    NOT?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    createdAt?: DateTimeFilter<"AgendaItemSpeaker"> | Date | string
    agendaItemId?: StringFilter<"AgendaItemSpeaker"> | string
    speakerId?: StringFilter<"AgendaItemSpeaker"> | string
    agendaItem?: XOR<AgendaItemScalarRelationFilter, AgendaItemWhereInput>
    speaker?: XOR<SpeakerScalarRelationFilter, SpeakerWhereInput>
  }, "id" | "agendaItemId_speakerId">

  export type AgendaItemSpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
    _count?: AgendaItemSpeakerCountOrderByAggregateInput
    _max?: AgendaItemSpeakerMaxOrderByAggregateInput
    _min?: AgendaItemSpeakerMinOrderByAggregateInput
  }

  export type AgendaItemSpeakerScalarWhereWithAggregatesInput = {
    AND?: AgendaItemSpeakerScalarWhereWithAggregatesInput | AgendaItemSpeakerScalarWhereWithAggregatesInput[]
    OR?: AgendaItemSpeakerScalarWhereWithAggregatesInput[]
    NOT?: AgendaItemSpeakerScalarWhereWithAggregatesInput | AgendaItemSpeakerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaItemSpeaker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgendaItemSpeaker"> | Date | string
    agendaItemId?: StringWithAggregatesFilter<"AgendaItemSpeaker"> | string
    speakerId?: StringWithAggregatesFilter<"AgendaItemSpeaker"> | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatsCreateInput = {
    id?: string
    speakers?: number
    partners?: number
    mediaPartners?: number
    sponsors?: number
    exhibitors?: number
    delegates?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutStatsInput
  }

  export type ProjectStatsUncheckedCreateInput = {
    id?: string
    speakers?: number
    partners?: number
    mediaPartners?: number
    sponsors?: number
    exhibitors?: number
    delegates?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ProjectStatsUpdateInput = {
    speakers?: IntFieldUpdateOperationsInput | number
    partners?: IntFieldUpdateOperationsInput | number
    mediaPartners?: IntFieldUpdateOperationsInput | number
    sponsors?: IntFieldUpdateOperationsInput | number
    exhibitors?: IntFieldUpdateOperationsInput | number
    delegates?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutStatsNestedInput
  }

  export type ProjectStatsUncheckedUpdateInput = {
    speakers?: IntFieldUpdateOperationsInput | number
    partners?: IntFieldUpdateOperationsInput | number
    mediaPartners?: IntFieldUpdateOperationsInput | number
    sponsors?: IntFieldUpdateOperationsInput | number
    exhibitors?: IntFieldUpdateOperationsInput | number
    delegates?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectStatsCreateManyInput = {
    id?: string
    speakers?: number
    partners?: number
    mediaPartners?: number
    sponsors?: number
    exhibitors?: number
    delegates?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ProjectStatsUpdateManyMutationInput = {
    speakers?: IntFieldUpdateOperationsInput | number
    partners?: IntFieldUpdateOperationsInput | number
    mediaPartners?: IntFieldUpdateOperationsInput | number
    sponsors?: IntFieldUpdateOperationsInput | number
    exhibitors?: IntFieldUpdateOperationsInput | number
    delegates?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatsUncheckedUpdateManyInput = {
    speakers?: IntFieldUpdateOperationsInput | number
    partners?: IntFieldUpdateOperationsInput | number
    mediaPartners?: IntFieldUpdateOperationsInput | number
    sponsors?: IntFieldUpdateOperationsInput | number
    exhibitors?: IntFieldUpdateOperationsInput | number
    delegates?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendeeCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    checkedIn?: boolean
    checkinTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAttendeesInput
  }

  export type AttendeeUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    checkedIn?: boolean
    checkinTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type AttendeeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAttendeesNestedInput
  }

  export type AttendeeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendeeCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    checkedIn?: boolean
    checkinTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type AttendeeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type DelegateCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    booth?: string | null
    status?: string | null
    description?: string | null
    priority?: number
    featured?: boolean
    type: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDelegatesInput
  }

  export type DelegateUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    booth?: string | null
    status?: string | null
    description?: string | null
    priority?: number
    featured?: boolean
    type: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type DelegateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDelegatesNestedInput
  }

  export type DelegateUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type DelegateCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    booth?: string | null
    status?: string | null
    description?: string | null
    priority?: number
    featured?: boolean
    type: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type DelegateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSpeakersInput
    agendaItems?: AgendaItemSpeakerCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    agendaItems?: AgendaItemSpeakerUncheckedCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSpeakersNestedInput
    agendaItems?: AgendaItemSpeakerUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    agendaItems?: AgendaItemSpeakerUncheckedUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SpeakerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingCampaignCreateInput = {
    id?: string
    name: string
    type: string
    total?: number
    revenue?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMarketingCampaignsInput
  }

  export type MarketingCampaignUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    total?: number
    revenue?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type MarketingCampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMarketingCampaignsNestedInput
  }

  export type MarketingCampaignUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingCampaignCreateManyInput = {
    id?: string
    name: string
    type: string
    total?: number
    revenue?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type MarketingCampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingCampaignUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateInput = {
    id?: string
    name: string
    email: string
    contact?: string | null
    company?: string | null
    type?: string | null
    date?: Date | string | null
    qualifyStatus?: string | null
    salesStatus?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    contact?: string | null
    company?: string | null
    type?: string | null
    date?: Date | string | null
    qualifyStatus?: string | null
    salesStatus?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type LeadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateManyInput = {
    id?: string
    name: string
    email: string
    contact?: string | null
    company?: string | null
    type?: string | null
    date?: Date | string | null
    qualifyStatus?: string | null
    salesStatus?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type LeadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: string
    endTime: string
    date?: Date | string | null
    venue?: string | null
    day?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: string
    endTime: string
    date?: Date | string | null
    venue?: string | null
    day?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SessionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: string
    endTime: string
    date?: Date | string | null
    venue?: string | null
    day?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SessionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ExhibitorCreateInput = {
    id?: string
    name: string
    image?: string | null
    boothNumber?: string | null
    category?: string | null
    status?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutExhibitorsInput
  }

  export type ExhibitorUncheckedCreateInput = {
    id?: string
    name: string
    image?: string | null
    boothNumber?: string | null
    category?: string | null
    status?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ExhibitorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutExhibitorsNestedInput
  }

  export type ExhibitorUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ExhibitorCreateManyInput = {
    id?: string
    name: string
    image?: string | null
    boothNumber?: string | null
    category?: string | null
    status?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ExhibitorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SponsorCreateInput = {
    id?: string
    name: string
    image?: string | null
    level: string
    amount?: string | null
    status?: string | null
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSponsorsInput
  }

  export type SponsorUncheckedCreateInput = {
    id?: string
    name: string
    image?: string | null
    level: string
    amount?: string | null
    status?: string | null
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SponsorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSponsorsNestedInput
  }

  export type SponsorUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type SponsorCreateManyInput = {
    id?: string
    name: string
    image?: string | null
    level: string
    amount?: string | null
    status?: string | null
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SponsorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type PartnerCreateInput = {
    id?: string
    name: string
    image?: string | null
    type?: string | null
    website?: string | null
    status?: string | null
    contribution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPartnersInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    name: string
    image?: string | null
    type?: string | null
    website?: string | null
    status?: string | null
    contribution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type PartnerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPartnersNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type PartnerCreateManyInput = {
    id?: string
    name: string
    image?: string | null
    type?: string | null
    website?: string | null
    status?: string | null
    contribution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type PartnerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaPartnerCreateInput = {
    id?: string
    name: string
    image?: string | null
    website?: string | null
    type?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMediaPartnersInput
  }

  export type MediaPartnerUncheckedCreateInput = {
    id?: string
    name: string
    image?: string | null
    website?: string | null
    type?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type MediaPartnerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMediaPartnersNestedInput
  }

  export type MediaPartnerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaPartnerCreateManyInput = {
    id?: string
    name: string
    image?: string | null
    website?: string | null
    type?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type MediaPartnerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPartnerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEnquiriesInput
  }

  export type EnquiryUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type EnquiryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEnquiriesNestedInput
  }

  export type EnquiryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type EnquiryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnquiryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type UtmDataCreateInput = {
    id?: string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    term?: string | null
    content?: string | null
    visits?: number
    conversions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUtmDataInput
  }

  export type UtmDataUncheckedCreateInput = {
    id?: string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    term?: string | null
    content?: string | null
    visits?: number
    conversions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type UtmDataUpdateInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUtmDataNestedInput
  }

  export type UtmDataUncheckedUpdateInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type UtmDataCreateManyInput = {
    id?: string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    term?: string | null
    content?: string | null
    visits?: number
    conversions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type UtmDataUpdateManyMutationInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtmDataUncheckedUpdateManyInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaDayCreateInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgendaDaysInput
    sessions?: AgendaSessionCreateNestedManyWithoutDayInput
  }

  export type AgendaDayUncheckedCreateInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    sessions?: AgendaSessionUncheckedCreateNestedManyWithoutDayInput
  }

  export type AgendaDayUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgendaDaysNestedInput
    sessions?: AgendaSessionUpdateManyWithoutDayNestedInput
  }

  export type AgendaDayUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    sessions?: AgendaSessionUncheckedUpdateManyWithoutDayNestedInput
  }

  export type AgendaDayCreateManyInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type AgendaDayUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaDayUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaSessionCreateInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    day: AgendaDayCreateNestedOneWithoutSessionsInput
    items?: AgendaItemCreateNestedManyWithoutSessionInput
  }

  export type AgendaSessionUncheckedCreateInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayId: string
    items?: AgendaItemUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AgendaSessionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    day?: AgendaDayUpdateOneRequiredWithoutSessionsNestedInput
    items?: AgendaItemUpdateManyWithoutSessionNestedInput
  }

  export type AgendaSessionUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
    items?: AgendaItemUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AgendaSessionCreateManyInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayId: string
  }

  export type AgendaSessionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaSessionUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemCreateInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AgendaSessionCreateNestedOneWithoutItemsInput
    speakers?: AgendaItemSpeakerCreateNestedManyWithoutAgendaItemInput
  }

  export type AgendaItemUncheckedCreateInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
    speakers?: AgendaItemSpeakerUncheckedCreateNestedManyWithoutAgendaItemInput
  }

  export type AgendaItemUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AgendaSessionUpdateOneRequiredWithoutItemsNestedInput
    speakers?: AgendaItemSpeakerUpdateManyWithoutAgendaItemNestedInput
  }

  export type AgendaItemUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    speakers?: AgendaItemSpeakerUncheckedUpdateManyWithoutAgendaItemNestedInput
  }

  export type AgendaItemCreateManyInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
  }

  export type AgendaItemUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemSpeakerCreateInput = {
    id?: string
    createdAt?: Date | string
    agendaItem: AgendaItemCreateNestedOneWithoutSpeakersInput
    speaker: SpeakerCreateNestedOneWithoutAgendaItemsInput
  }

  export type AgendaItemSpeakerUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    agendaItemId: string
    speakerId: string
  }

  export type AgendaItemSpeakerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItem?: AgendaItemUpdateOneRequiredWithoutSpeakersNestedInput
    speaker?: SpeakerUpdateOneRequiredWithoutAgendaItemsNestedInput
  }

  export type AgendaItemSpeakerUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItemId?: StringFieldUpdateOperationsInput | string
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemSpeakerCreateManyInput = {
    id?: string
    createdAt?: Date | string
    agendaItemId: string
    speakerId: string
  }

  export type AgendaItemSpeakerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemSpeakerUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItemId?: StringFieldUpdateOperationsInput | string
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectStatsNullableScalarRelationFilter = {
    is?: ProjectStatsWhereInput | null
    isNot?: ProjectStatsWhereInput | null
  }

  export type AttendeeListRelationFilter = {
    every?: AttendeeWhereInput
    some?: AttendeeWhereInput
    none?: AttendeeWhereInput
  }

  export type DelegateListRelationFilter = {
    every?: DelegateWhereInput
    some?: DelegateWhereInput
    none?: DelegateWhereInput
  }

  export type SpeakerListRelationFilter = {
    every?: SpeakerWhereInput
    some?: SpeakerWhereInput
    none?: SpeakerWhereInput
  }

  export type MarketingCampaignListRelationFilter = {
    every?: MarketingCampaignWhereInput
    some?: MarketingCampaignWhereInput
    none?: MarketingCampaignWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ExhibitorListRelationFilter = {
    every?: ExhibitorWhereInput
    some?: ExhibitorWhereInput
    none?: ExhibitorWhereInput
  }

  export type SponsorListRelationFilter = {
    every?: SponsorWhereInput
    some?: SponsorWhereInput
    none?: SponsorWhereInput
  }

  export type PartnerListRelationFilter = {
    every?: PartnerWhereInput
    some?: PartnerWhereInput
    none?: PartnerWhereInput
  }

  export type MediaPartnerListRelationFilter = {
    every?: MediaPartnerWhereInput
    some?: MediaPartnerWhereInput
    none?: MediaPartnerWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type EnquiryListRelationFilter = {
    every?: EnquiryWhereInput
    some?: EnquiryWhereInput
    none?: EnquiryWhereInput
  }

  export type UtmDataListRelationFilter = {
    every?: UtmDataWhereInput
    some?: UtmDataWhereInput
    none?: UtmDataWhereInput
  }

  export type AgendaDayListRelationFilter = {
    every?: AgendaDayWhereInput
    some?: AgendaDayWhereInput
    none?: AgendaDayWhereInput
  }

  export type AttendeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DelegateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeakerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketingCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExhibitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SponsorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaPartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UtmDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgendaDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    image?: SortOrder
    year?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    image?: SortOrder
    year?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    image?: SortOrder
    year?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectStatsCountOrderByAggregateInput = {
    id?: SortOrder
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectStatsAvgOrderByAggregateInput = {
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
  }

  export type ProjectStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectStatsMinOrderByAggregateInput = {
    id?: SortOrder
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectStatsSumOrderByAggregateInput = {
    speakers?: SortOrder
    partners?: SortOrder
    mediaPartners?: SortOrder
    sponsors?: SortOrder
    exhibitors?: SortOrder
    delegates?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DelegateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    status?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    featured?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type DelegateAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type DelegateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    status?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    featured?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type DelegateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    status?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    featured?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type DelegateSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type AgendaItemSpeakerListRelationFilter = {
    every?: AgendaItemSpeakerWhereInput
    some?: AgendaItemSpeakerWhereInput
    none?: AgendaItemSpeakerWhereInput
  }

  export type AgendaItemSpeakerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeakerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    position?: SortOrder
    bio?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    position?: SortOrder
    bio?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SpeakerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    position?: SortOrder
    bio?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MarketingCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    total?: SortOrder
    revenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MarketingCampaignAvgOrderByAggregateInput = {
    total?: SortOrder
    revenue?: SortOrder
  }

  export type MarketingCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    total?: SortOrder
    revenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MarketingCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    total?: SortOrder
    revenue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MarketingCampaignSumOrderByAggregateInput = {
    total?: SortOrder
    revenue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    company?: SortOrder
    type?: SortOrder
    date?: SortOrder
    qualifyStatus?: SortOrder
    salesStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    company?: SortOrder
    type?: SortOrder
    date?: SortOrder
    qualifyStatus?: SortOrder
    salesStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact?: SortOrder
    company?: SortOrder
    type?: SortOrder
    date?: SortOrder
    qualifyStatus?: SortOrder
    salesStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    venue?: SortOrder
    day?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    day?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    venue?: SortOrder
    day?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    venue?: SortOrder
    day?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    day?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ExhibitorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    status?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ExhibitorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    status?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ExhibitorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    status?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SponsorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    level?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SponsorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    level?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SponsorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    level?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    website?: SortOrder
    status?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    website?: SortOrder
    status?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    type?: SortOrder
    website?: SortOrder
    status?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MediaPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    website?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MediaPartnerAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type MediaPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    website?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MediaPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    website?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MediaPartnerSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnquiryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnquiryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type UtmDataCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    term?: SortOrder
    content?: SortOrder
    visits?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type UtmDataAvgOrderByAggregateInput = {
    visits?: SortOrder
    conversions?: SortOrder
  }

  export type UtmDataMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    term?: SortOrder
    content?: SortOrder
    visits?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type UtmDataMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    term?: SortOrder
    content?: SortOrder
    visits?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type UtmDataSumOrderByAggregateInput = {
    visits?: SortOrder
    conversions?: SortOrder
  }

  export type AgendaSessionListRelationFilter = {
    every?: AgendaSessionWhereInput
    some?: AgendaSessionWhereInput
    none?: AgendaSessionWhereInput
  }

  export type AgendaSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgendaDayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AgendaDayAvgOrderByAggregateInput = {
    dayNumber?: SortOrder
  }

  export type AgendaDayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AgendaDayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AgendaDaySumOrderByAggregateInput = {
    dayNumber?: SortOrder
  }

  export type AgendaDayScalarRelationFilter = {
    is?: AgendaDayWhereInput
    isNot?: AgendaDayWhereInput
  }

  export type AgendaItemListRelationFilter = {
    every?: AgendaItemWhereInput
    some?: AgendaItemWhereInput
    none?: AgendaItemWhereInput
  }

  export type AgendaItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgendaSessionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    color?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayId?: SortOrder
  }

  export type AgendaSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    color?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayId?: SortOrder
  }

  export type AgendaSessionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    color?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayId?: SortOrder
  }

  export type AgendaSessionScalarRelationFilter = {
    is?: AgendaSessionWhereInput
    isNot?: AgendaSessionWhereInput
  }

  export type AgendaItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
  }

  export type AgendaItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
  }

  export type AgendaItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessionId?: SortOrder
  }

  export type AgendaItemScalarRelationFilter = {
    is?: AgendaItemWhereInput
    isNot?: AgendaItemWhereInput
  }

  export type SpeakerScalarRelationFilter = {
    is?: SpeakerWhereInput
    isNot?: SpeakerWhereInput
  }

  export type AgendaItemSpeakerAgendaItemIdSpeakerIdCompoundUniqueInput = {
    agendaItemId: string
    speakerId: string
  }

  export type AgendaItemSpeakerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
  }

  export type AgendaItemSpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
  }

  export type AgendaItemSpeakerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
  }

  export type ProjectStatsCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectStatsCreateWithoutProjectInput, ProjectStatsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectStatsCreateOrConnectWithoutProjectInput
    connect?: ProjectStatsWhereUniqueInput
  }

  export type AttendeeCreateNestedManyWithoutProjectInput = {
    create?: XOR<AttendeeCreateWithoutProjectInput, AttendeeUncheckedCreateWithoutProjectInput> | AttendeeCreateWithoutProjectInput[] | AttendeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendeeCreateOrConnectWithoutProjectInput | AttendeeCreateOrConnectWithoutProjectInput[]
    createMany?: AttendeeCreateManyProjectInputEnvelope
    connect?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
  }

  export type DelegateCreateNestedManyWithoutProjectInput = {
    create?: XOR<DelegateCreateWithoutProjectInput, DelegateUncheckedCreateWithoutProjectInput> | DelegateCreateWithoutProjectInput[] | DelegateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelegateCreateOrConnectWithoutProjectInput | DelegateCreateOrConnectWithoutProjectInput[]
    createMany?: DelegateCreateManyProjectInputEnvelope
    connect?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
  }

  export type SpeakerCreateNestedManyWithoutProjectInput = {
    create?: XOR<SpeakerCreateWithoutProjectInput, SpeakerUncheckedCreateWithoutProjectInput> | SpeakerCreateWithoutProjectInput[] | SpeakerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpeakerCreateOrConnectWithoutProjectInput | SpeakerCreateOrConnectWithoutProjectInput[]
    createMany?: SpeakerCreateManyProjectInputEnvelope
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
  }

  export type MarketingCampaignCreateNestedManyWithoutProjectInput = {
    create?: XOR<MarketingCampaignCreateWithoutProjectInput, MarketingCampaignUncheckedCreateWithoutProjectInput> | MarketingCampaignCreateWithoutProjectInput[] | MarketingCampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MarketingCampaignCreateOrConnectWithoutProjectInput | MarketingCampaignCreateOrConnectWithoutProjectInput[]
    createMany?: MarketingCampaignCreateManyProjectInputEnvelope
    connect?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutProjectInput = {
    create?: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput> | LeadCreateWithoutProjectInput[] | LeadUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutProjectInput | LeadCreateOrConnectWithoutProjectInput[]
    createMany?: LeadCreateManyProjectInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutProjectInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ExhibitorCreateNestedManyWithoutProjectInput = {
    create?: XOR<ExhibitorCreateWithoutProjectInput, ExhibitorUncheckedCreateWithoutProjectInput> | ExhibitorCreateWithoutProjectInput[] | ExhibitorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExhibitorCreateOrConnectWithoutProjectInput | ExhibitorCreateOrConnectWithoutProjectInput[]
    createMany?: ExhibitorCreateManyProjectInputEnvelope
    connect?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
  }

  export type SponsorCreateNestedManyWithoutProjectInput = {
    create?: XOR<SponsorCreateWithoutProjectInput, SponsorUncheckedCreateWithoutProjectInput> | SponsorCreateWithoutProjectInput[] | SponsorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutProjectInput | SponsorCreateOrConnectWithoutProjectInput[]
    createMany?: SponsorCreateManyProjectInputEnvelope
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
  }

  export type PartnerCreateNestedManyWithoutProjectInput = {
    create?: XOR<PartnerCreateWithoutProjectInput, PartnerUncheckedCreateWithoutProjectInput> | PartnerCreateWithoutProjectInput[] | PartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutProjectInput | PartnerCreateOrConnectWithoutProjectInput[]
    createMany?: PartnerCreateManyProjectInputEnvelope
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
  }

  export type MediaPartnerCreateNestedManyWithoutProjectInput = {
    create?: XOR<MediaPartnerCreateWithoutProjectInput, MediaPartnerUncheckedCreateWithoutProjectInput> | MediaPartnerCreateWithoutProjectInput[] | MediaPartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaPartnerCreateOrConnectWithoutProjectInput | MediaPartnerCreateOrConnectWithoutProjectInput[]
    createMany?: MediaPartnerCreateManyProjectInputEnvelope
    connect?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutProjectInput = {
    create?: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput> | OrderCreateWithoutProjectInput[] | OrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProjectInput | OrderCreateOrConnectWithoutProjectInput[]
    createMany?: OrderCreateManyProjectInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EnquiryCreateNestedManyWithoutProjectInput = {
    create?: XOR<EnquiryCreateWithoutProjectInput, EnquiryUncheckedCreateWithoutProjectInput> | EnquiryCreateWithoutProjectInput[] | EnquiryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutProjectInput | EnquiryCreateOrConnectWithoutProjectInput[]
    createMany?: EnquiryCreateManyProjectInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type UtmDataCreateNestedManyWithoutProjectInput = {
    create?: XOR<UtmDataCreateWithoutProjectInput, UtmDataUncheckedCreateWithoutProjectInput> | UtmDataCreateWithoutProjectInput[] | UtmDataUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UtmDataCreateOrConnectWithoutProjectInput | UtmDataCreateOrConnectWithoutProjectInput[]
    createMany?: UtmDataCreateManyProjectInputEnvelope
    connect?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
  }

  export type AgendaDayCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgendaDayCreateWithoutProjectInput, AgendaDayUncheckedCreateWithoutProjectInput> | AgendaDayCreateWithoutProjectInput[] | AgendaDayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgendaDayCreateOrConnectWithoutProjectInput | AgendaDayCreateOrConnectWithoutProjectInput[]
    createMany?: AgendaDayCreateManyProjectInputEnvelope
    connect?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
  }

  export type ProjectStatsUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectStatsCreateWithoutProjectInput, ProjectStatsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectStatsCreateOrConnectWithoutProjectInput
    connect?: ProjectStatsWhereUniqueInput
  }

  export type AttendeeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AttendeeCreateWithoutProjectInput, AttendeeUncheckedCreateWithoutProjectInput> | AttendeeCreateWithoutProjectInput[] | AttendeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendeeCreateOrConnectWithoutProjectInput | AttendeeCreateOrConnectWithoutProjectInput[]
    createMany?: AttendeeCreateManyProjectInputEnvelope
    connect?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
  }

  export type DelegateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DelegateCreateWithoutProjectInput, DelegateUncheckedCreateWithoutProjectInput> | DelegateCreateWithoutProjectInput[] | DelegateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelegateCreateOrConnectWithoutProjectInput | DelegateCreateOrConnectWithoutProjectInput[]
    createMany?: DelegateCreateManyProjectInputEnvelope
    connect?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
  }

  export type SpeakerUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SpeakerCreateWithoutProjectInput, SpeakerUncheckedCreateWithoutProjectInput> | SpeakerCreateWithoutProjectInput[] | SpeakerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpeakerCreateOrConnectWithoutProjectInput | SpeakerCreateOrConnectWithoutProjectInput[]
    createMany?: SpeakerCreateManyProjectInputEnvelope
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
  }

  export type MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MarketingCampaignCreateWithoutProjectInput, MarketingCampaignUncheckedCreateWithoutProjectInput> | MarketingCampaignCreateWithoutProjectInput[] | MarketingCampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MarketingCampaignCreateOrConnectWithoutProjectInput | MarketingCampaignCreateOrConnectWithoutProjectInput[]
    createMany?: MarketingCampaignCreateManyProjectInputEnvelope
    connect?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput> | LeadCreateWithoutProjectInput[] | LeadUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutProjectInput | LeadCreateOrConnectWithoutProjectInput[]
    createMany?: LeadCreateManyProjectInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ExhibitorUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ExhibitorCreateWithoutProjectInput, ExhibitorUncheckedCreateWithoutProjectInput> | ExhibitorCreateWithoutProjectInput[] | ExhibitorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExhibitorCreateOrConnectWithoutProjectInput | ExhibitorCreateOrConnectWithoutProjectInput[]
    createMany?: ExhibitorCreateManyProjectInputEnvelope
    connect?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
  }

  export type SponsorUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SponsorCreateWithoutProjectInput, SponsorUncheckedCreateWithoutProjectInput> | SponsorCreateWithoutProjectInput[] | SponsorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutProjectInput | SponsorCreateOrConnectWithoutProjectInput[]
    createMany?: SponsorCreateManyProjectInputEnvelope
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
  }

  export type PartnerUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PartnerCreateWithoutProjectInput, PartnerUncheckedCreateWithoutProjectInput> | PartnerCreateWithoutProjectInput[] | PartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutProjectInput | PartnerCreateOrConnectWithoutProjectInput[]
    createMany?: PartnerCreateManyProjectInputEnvelope
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
  }

  export type MediaPartnerUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MediaPartnerCreateWithoutProjectInput, MediaPartnerUncheckedCreateWithoutProjectInput> | MediaPartnerCreateWithoutProjectInput[] | MediaPartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaPartnerCreateOrConnectWithoutProjectInput | MediaPartnerCreateOrConnectWithoutProjectInput[]
    createMany?: MediaPartnerCreateManyProjectInputEnvelope
    connect?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput> | OrderCreateWithoutProjectInput[] | OrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProjectInput | OrderCreateOrConnectWithoutProjectInput[]
    createMany?: OrderCreateManyProjectInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EnquiryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EnquiryCreateWithoutProjectInput, EnquiryUncheckedCreateWithoutProjectInput> | EnquiryCreateWithoutProjectInput[] | EnquiryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutProjectInput | EnquiryCreateOrConnectWithoutProjectInput[]
    createMany?: EnquiryCreateManyProjectInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type UtmDataUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UtmDataCreateWithoutProjectInput, UtmDataUncheckedCreateWithoutProjectInput> | UtmDataCreateWithoutProjectInput[] | UtmDataUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UtmDataCreateOrConnectWithoutProjectInput | UtmDataCreateOrConnectWithoutProjectInput[]
    createMany?: UtmDataCreateManyProjectInputEnvelope
    connect?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
  }

  export type AgendaDayUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgendaDayCreateWithoutProjectInput, AgendaDayUncheckedCreateWithoutProjectInput> | AgendaDayCreateWithoutProjectInput[] | AgendaDayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgendaDayCreateOrConnectWithoutProjectInput | AgendaDayCreateOrConnectWithoutProjectInput[]
    createMany?: AgendaDayCreateManyProjectInputEnvelope
    connect?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectStatsUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectStatsCreateWithoutProjectInput, ProjectStatsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectStatsCreateOrConnectWithoutProjectInput
    upsert?: ProjectStatsUpsertWithoutProjectInput
    disconnect?: ProjectStatsWhereInput | boolean
    delete?: ProjectStatsWhereInput | boolean
    connect?: ProjectStatsWhereUniqueInput
    update?: XOR<XOR<ProjectStatsUpdateToOneWithWhereWithoutProjectInput, ProjectStatsUpdateWithoutProjectInput>, ProjectStatsUncheckedUpdateWithoutProjectInput>
  }

  export type AttendeeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AttendeeCreateWithoutProjectInput, AttendeeUncheckedCreateWithoutProjectInput> | AttendeeCreateWithoutProjectInput[] | AttendeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendeeCreateOrConnectWithoutProjectInput | AttendeeCreateOrConnectWithoutProjectInput[]
    upsert?: AttendeeUpsertWithWhereUniqueWithoutProjectInput | AttendeeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AttendeeCreateManyProjectInputEnvelope
    set?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    disconnect?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    delete?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    connect?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    update?: AttendeeUpdateWithWhereUniqueWithoutProjectInput | AttendeeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AttendeeUpdateManyWithWhereWithoutProjectInput | AttendeeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AttendeeScalarWhereInput | AttendeeScalarWhereInput[]
  }

  export type DelegateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DelegateCreateWithoutProjectInput, DelegateUncheckedCreateWithoutProjectInput> | DelegateCreateWithoutProjectInput[] | DelegateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelegateCreateOrConnectWithoutProjectInput | DelegateCreateOrConnectWithoutProjectInput[]
    upsert?: DelegateUpsertWithWhereUniqueWithoutProjectInput | DelegateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DelegateCreateManyProjectInputEnvelope
    set?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    disconnect?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    delete?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    connect?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    update?: DelegateUpdateWithWhereUniqueWithoutProjectInput | DelegateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DelegateUpdateManyWithWhereWithoutProjectInput | DelegateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DelegateScalarWhereInput | DelegateScalarWhereInput[]
  }

  export type SpeakerUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SpeakerCreateWithoutProjectInput, SpeakerUncheckedCreateWithoutProjectInput> | SpeakerCreateWithoutProjectInput[] | SpeakerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpeakerCreateOrConnectWithoutProjectInput | SpeakerCreateOrConnectWithoutProjectInput[]
    upsert?: SpeakerUpsertWithWhereUniqueWithoutProjectInput | SpeakerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SpeakerCreateManyProjectInputEnvelope
    set?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    disconnect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    delete?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    update?: SpeakerUpdateWithWhereUniqueWithoutProjectInput | SpeakerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SpeakerUpdateManyWithWhereWithoutProjectInput | SpeakerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[]
  }

  export type MarketingCampaignUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MarketingCampaignCreateWithoutProjectInput, MarketingCampaignUncheckedCreateWithoutProjectInput> | MarketingCampaignCreateWithoutProjectInput[] | MarketingCampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MarketingCampaignCreateOrConnectWithoutProjectInput | MarketingCampaignCreateOrConnectWithoutProjectInput[]
    upsert?: MarketingCampaignUpsertWithWhereUniqueWithoutProjectInput | MarketingCampaignUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MarketingCampaignCreateManyProjectInputEnvelope
    set?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    disconnect?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    delete?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    connect?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    update?: MarketingCampaignUpdateWithWhereUniqueWithoutProjectInput | MarketingCampaignUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MarketingCampaignUpdateManyWithWhereWithoutProjectInput | MarketingCampaignUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MarketingCampaignScalarWhereInput | MarketingCampaignScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput> | LeadCreateWithoutProjectInput[] | LeadUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutProjectInput | LeadCreateOrConnectWithoutProjectInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutProjectInput | LeadUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LeadCreateManyProjectInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutProjectInput | LeadUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutProjectInput | LeadUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProjectInput | SessionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProjectInput | SessionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProjectInput | SessionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ExhibitorUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ExhibitorCreateWithoutProjectInput, ExhibitorUncheckedCreateWithoutProjectInput> | ExhibitorCreateWithoutProjectInput[] | ExhibitorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExhibitorCreateOrConnectWithoutProjectInput | ExhibitorCreateOrConnectWithoutProjectInput[]
    upsert?: ExhibitorUpsertWithWhereUniqueWithoutProjectInput | ExhibitorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ExhibitorCreateManyProjectInputEnvelope
    set?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    disconnect?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    delete?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    connect?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    update?: ExhibitorUpdateWithWhereUniqueWithoutProjectInput | ExhibitorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ExhibitorUpdateManyWithWhereWithoutProjectInput | ExhibitorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ExhibitorScalarWhereInput | ExhibitorScalarWhereInput[]
  }

  export type SponsorUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SponsorCreateWithoutProjectInput, SponsorUncheckedCreateWithoutProjectInput> | SponsorCreateWithoutProjectInput[] | SponsorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutProjectInput | SponsorCreateOrConnectWithoutProjectInput[]
    upsert?: SponsorUpsertWithWhereUniqueWithoutProjectInput | SponsorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SponsorCreateManyProjectInputEnvelope
    set?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    disconnect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    delete?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    update?: SponsorUpdateWithWhereUniqueWithoutProjectInput | SponsorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SponsorUpdateManyWithWhereWithoutProjectInput | SponsorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
  }

  export type PartnerUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PartnerCreateWithoutProjectInput, PartnerUncheckedCreateWithoutProjectInput> | PartnerCreateWithoutProjectInput[] | PartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutProjectInput | PartnerCreateOrConnectWithoutProjectInput[]
    upsert?: PartnerUpsertWithWhereUniqueWithoutProjectInput | PartnerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PartnerCreateManyProjectInputEnvelope
    set?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    disconnect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    delete?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    update?: PartnerUpdateWithWhereUniqueWithoutProjectInput | PartnerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PartnerUpdateManyWithWhereWithoutProjectInput | PartnerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
  }

  export type MediaPartnerUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MediaPartnerCreateWithoutProjectInput, MediaPartnerUncheckedCreateWithoutProjectInput> | MediaPartnerCreateWithoutProjectInput[] | MediaPartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaPartnerCreateOrConnectWithoutProjectInput | MediaPartnerCreateOrConnectWithoutProjectInput[]
    upsert?: MediaPartnerUpsertWithWhereUniqueWithoutProjectInput | MediaPartnerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MediaPartnerCreateManyProjectInputEnvelope
    set?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    disconnect?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    delete?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    connect?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    update?: MediaPartnerUpdateWithWhereUniqueWithoutProjectInput | MediaPartnerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MediaPartnerUpdateManyWithWhereWithoutProjectInput | MediaPartnerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MediaPartnerScalarWhereInput | MediaPartnerScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutProjectNestedInput = {
    create?: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput> | OrderCreateWithoutProjectInput[] | OrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProjectInput | OrderCreateOrConnectWithoutProjectInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProjectInput | OrderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: OrderCreateManyProjectInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProjectInput | OrderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProjectInput | OrderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EnquiryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EnquiryCreateWithoutProjectInput, EnquiryUncheckedCreateWithoutProjectInput> | EnquiryCreateWithoutProjectInput[] | EnquiryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutProjectInput | EnquiryCreateOrConnectWithoutProjectInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutProjectInput | EnquiryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EnquiryCreateManyProjectInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutProjectInput | EnquiryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutProjectInput | EnquiryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type UtmDataUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UtmDataCreateWithoutProjectInput, UtmDataUncheckedCreateWithoutProjectInput> | UtmDataCreateWithoutProjectInput[] | UtmDataUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UtmDataCreateOrConnectWithoutProjectInput | UtmDataCreateOrConnectWithoutProjectInput[]
    upsert?: UtmDataUpsertWithWhereUniqueWithoutProjectInput | UtmDataUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UtmDataCreateManyProjectInputEnvelope
    set?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    disconnect?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    delete?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    connect?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    update?: UtmDataUpdateWithWhereUniqueWithoutProjectInput | UtmDataUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UtmDataUpdateManyWithWhereWithoutProjectInput | UtmDataUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UtmDataScalarWhereInput | UtmDataScalarWhereInput[]
  }

  export type AgendaDayUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgendaDayCreateWithoutProjectInput, AgendaDayUncheckedCreateWithoutProjectInput> | AgendaDayCreateWithoutProjectInput[] | AgendaDayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgendaDayCreateOrConnectWithoutProjectInput | AgendaDayCreateOrConnectWithoutProjectInput[]
    upsert?: AgendaDayUpsertWithWhereUniqueWithoutProjectInput | AgendaDayUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgendaDayCreateManyProjectInputEnvelope
    set?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    disconnect?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    delete?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    connect?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    update?: AgendaDayUpdateWithWhereUniqueWithoutProjectInput | AgendaDayUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgendaDayUpdateManyWithWhereWithoutProjectInput | AgendaDayUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgendaDayScalarWhereInput | AgendaDayScalarWhereInput[]
  }

  export type ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectStatsCreateWithoutProjectInput, ProjectStatsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectStatsCreateOrConnectWithoutProjectInput
    upsert?: ProjectStatsUpsertWithoutProjectInput
    disconnect?: ProjectStatsWhereInput | boolean
    delete?: ProjectStatsWhereInput | boolean
    connect?: ProjectStatsWhereUniqueInput
    update?: XOR<XOR<ProjectStatsUpdateToOneWithWhereWithoutProjectInput, ProjectStatsUpdateWithoutProjectInput>, ProjectStatsUncheckedUpdateWithoutProjectInput>
  }

  export type AttendeeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AttendeeCreateWithoutProjectInput, AttendeeUncheckedCreateWithoutProjectInput> | AttendeeCreateWithoutProjectInput[] | AttendeeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendeeCreateOrConnectWithoutProjectInput | AttendeeCreateOrConnectWithoutProjectInput[]
    upsert?: AttendeeUpsertWithWhereUniqueWithoutProjectInput | AttendeeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AttendeeCreateManyProjectInputEnvelope
    set?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    disconnect?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    delete?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    connect?: AttendeeWhereUniqueInput | AttendeeWhereUniqueInput[]
    update?: AttendeeUpdateWithWhereUniqueWithoutProjectInput | AttendeeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AttendeeUpdateManyWithWhereWithoutProjectInput | AttendeeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AttendeeScalarWhereInput | AttendeeScalarWhereInput[]
  }

  export type DelegateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DelegateCreateWithoutProjectInput, DelegateUncheckedCreateWithoutProjectInput> | DelegateCreateWithoutProjectInput[] | DelegateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelegateCreateOrConnectWithoutProjectInput | DelegateCreateOrConnectWithoutProjectInput[]
    upsert?: DelegateUpsertWithWhereUniqueWithoutProjectInput | DelegateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DelegateCreateManyProjectInputEnvelope
    set?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    disconnect?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    delete?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    connect?: DelegateWhereUniqueInput | DelegateWhereUniqueInput[]
    update?: DelegateUpdateWithWhereUniqueWithoutProjectInput | DelegateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DelegateUpdateManyWithWhereWithoutProjectInput | DelegateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DelegateScalarWhereInput | DelegateScalarWhereInput[]
  }

  export type SpeakerUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SpeakerCreateWithoutProjectInput, SpeakerUncheckedCreateWithoutProjectInput> | SpeakerCreateWithoutProjectInput[] | SpeakerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SpeakerCreateOrConnectWithoutProjectInput | SpeakerCreateOrConnectWithoutProjectInput[]
    upsert?: SpeakerUpsertWithWhereUniqueWithoutProjectInput | SpeakerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SpeakerCreateManyProjectInputEnvelope
    set?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    disconnect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    delete?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    connect?: SpeakerWhereUniqueInput | SpeakerWhereUniqueInput[]
    update?: SpeakerUpdateWithWhereUniqueWithoutProjectInput | SpeakerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SpeakerUpdateManyWithWhereWithoutProjectInput | SpeakerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[]
  }

  export type MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MarketingCampaignCreateWithoutProjectInput, MarketingCampaignUncheckedCreateWithoutProjectInput> | MarketingCampaignCreateWithoutProjectInput[] | MarketingCampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MarketingCampaignCreateOrConnectWithoutProjectInput | MarketingCampaignCreateOrConnectWithoutProjectInput[]
    upsert?: MarketingCampaignUpsertWithWhereUniqueWithoutProjectInput | MarketingCampaignUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MarketingCampaignCreateManyProjectInputEnvelope
    set?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    disconnect?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    delete?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    connect?: MarketingCampaignWhereUniqueInput | MarketingCampaignWhereUniqueInput[]
    update?: MarketingCampaignUpdateWithWhereUniqueWithoutProjectInput | MarketingCampaignUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MarketingCampaignUpdateManyWithWhereWithoutProjectInput | MarketingCampaignUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MarketingCampaignScalarWhereInput | MarketingCampaignScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput> | LeadCreateWithoutProjectInput[] | LeadUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutProjectInput | LeadCreateOrConnectWithoutProjectInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutProjectInput | LeadUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LeadCreateManyProjectInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutProjectInput | LeadUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutProjectInput | LeadUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput> | SessionCreateWithoutProjectInput[] | SessionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProjectInput | SessionCreateOrConnectWithoutProjectInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProjectInput | SessionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SessionCreateManyProjectInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProjectInput | SessionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProjectInput | SessionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ExhibitorUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ExhibitorCreateWithoutProjectInput, ExhibitorUncheckedCreateWithoutProjectInput> | ExhibitorCreateWithoutProjectInput[] | ExhibitorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ExhibitorCreateOrConnectWithoutProjectInput | ExhibitorCreateOrConnectWithoutProjectInput[]
    upsert?: ExhibitorUpsertWithWhereUniqueWithoutProjectInput | ExhibitorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ExhibitorCreateManyProjectInputEnvelope
    set?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    disconnect?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    delete?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    connect?: ExhibitorWhereUniqueInput | ExhibitorWhereUniqueInput[]
    update?: ExhibitorUpdateWithWhereUniqueWithoutProjectInput | ExhibitorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ExhibitorUpdateManyWithWhereWithoutProjectInput | ExhibitorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ExhibitorScalarWhereInput | ExhibitorScalarWhereInput[]
  }

  export type SponsorUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SponsorCreateWithoutProjectInput, SponsorUncheckedCreateWithoutProjectInput> | SponsorCreateWithoutProjectInput[] | SponsorUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutProjectInput | SponsorCreateOrConnectWithoutProjectInput[]
    upsert?: SponsorUpsertWithWhereUniqueWithoutProjectInput | SponsorUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SponsorCreateManyProjectInputEnvelope
    set?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    disconnect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    delete?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    update?: SponsorUpdateWithWhereUniqueWithoutProjectInput | SponsorUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SponsorUpdateManyWithWhereWithoutProjectInput | SponsorUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
  }

  export type PartnerUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PartnerCreateWithoutProjectInput, PartnerUncheckedCreateWithoutProjectInput> | PartnerCreateWithoutProjectInput[] | PartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutProjectInput | PartnerCreateOrConnectWithoutProjectInput[]
    upsert?: PartnerUpsertWithWhereUniqueWithoutProjectInput | PartnerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PartnerCreateManyProjectInputEnvelope
    set?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    disconnect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    delete?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    update?: PartnerUpdateWithWhereUniqueWithoutProjectInput | PartnerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PartnerUpdateManyWithWhereWithoutProjectInput | PartnerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
  }

  export type MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MediaPartnerCreateWithoutProjectInput, MediaPartnerUncheckedCreateWithoutProjectInput> | MediaPartnerCreateWithoutProjectInput[] | MediaPartnerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MediaPartnerCreateOrConnectWithoutProjectInput | MediaPartnerCreateOrConnectWithoutProjectInput[]
    upsert?: MediaPartnerUpsertWithWhereUniqueWithoutProjectInput | MediaPartnerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MediaPartnerCreateManyProjectInputEnvelope
    set?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    disconnect?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    delete?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    connect?: MediaPartnerWhereUniqueInput | MediaPartnerWhereUniqueInput[]
    update?: MediaPartnerUpdateWithWhereUniqueWithoutProjectInput | MediaPartnerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MediaPartnerUpdateManyWithWhereWithoutProjectInput | MediaPartnerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MediaPartnerScalarWhereInput | MediaPartnerScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput> | OrderCreateWithoutProjectInput[] | OrderUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutProjectInput | OrderCreateOrConnectWithoutProjectInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutProjectInput | OrderUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: OrderCreateManyProjectInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutProjectInput | OrderUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutProjectInput | OrderUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EnquiryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EnquiryCreateWithoutProjectInput, EnquiryUncheckedCreateWithoutProjectInput> | EnquiryCreateWithoutProjectInput[] | EnquiryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutProjectInput | EnquiryCreateOrConnectWithoutProjectInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutProjectInput | EnquiryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EnquiryCreateManyProjectInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutProjectInput | EnquiryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutProjectInput | EnquiryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type UtmDataUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UtmDataCreateWithoutProjectInput, UtmDataUncheckedCreateWithoutProjectInput> | UtmDataCreateWithoutProjectInput[] | UtmDataUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UtmDataCreateOrConnectWithoutProjectInput | UtmDataCreateOrConnectWithoutProjectInput[]
    upsert?: UtmDataUpsertWithWhereUniqueWithoutProjectInput | UtmDataUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UtmDataCreateManyProjectInputEnvelope
    set?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    disconnect?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    delete?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    connect?: UtmDataWhereUniqueInput | UtmDataWhereUniqueInput[]
    update?: UtmDataUpdateWithWhereUniqueWithoutProjectInput | UtmDataUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UtmDataUpdateManyWithWhereWithoutProjectInput | UtmDataUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UtmDataScalarWhereInput | UtmDataScalarWhereInput[]
  }

  export type AgendaDayUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgendaDayCreateWithoutProjectInput, AgendaDayUncheckedCreateWithoutProjectInput> | AgendaDayCreateWithoutProjectInput[] | AgendaDayUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgendaDayCreateOrConnectWithoutProjectInput | AgendaDayCreateOrConnectWithoutProjectInput[]
    upsert?: AgendaDayUpsertWithWhereUniqueWithoutProjectInput | AgendaDayUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgendaDayCreateManyProjectInputEnvelope
    set?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    disconnect?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    delete?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    connect?: AgendaDayWhereUniqueInput | AgendaDayWhereUniqueInput[]
    update?: AgendaDayUpdateWithWhereUniqueWithoutProjectInput | AgendaDayUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgendaDayUpdateManyWithWhereWithoutProjectInput | AgendaDayUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgendaDayScalarWhereInput | AgendaDayScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutStatsInput = {
    create?: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStatsInput
    connect?: ProjectWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutStatsInput
    upsert?: ProjectUpsertWithoutStatsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutStatsInput, ProjectUpdateWithoutStatsInput>, ProjectUncheckedUpdateWithoutStatsInput>
  }

  export type ProjectCreateNestedOneWithoutAttendeesInput = {
    create?: XOR<ProjectCreateWithoutAttendeesInput, ProjectUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAttendeesInput
    connect?: ProjectWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProjectUpdateOneRequiredWithoutAttendeesNestedInput = {
    create?: XOR<ProjectCreateWithoutAttendeesInput, ProjectUncheckedCreateWithoutAttendeesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAttendeesInput
    upsert?: ProjectUpsertWithoutAttendeesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAttendeesInput, ProjectUpdateWithoutAttendeesInput>, ProjectUncheckedUpdateWithoutAttendeesInput>
  }

  export type ProjectCreateNestedOneWithoutDelegatesInput = {
    create?: XOR<ProjectCreateWithoutDelegatesInput, ProjectUncheckedCreateWithoutDelegatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDelegatesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutDelegatesNestedInput = {
    create?: XOR<ProjectCreateWithoutDelegatesInput, ProjectUncheckedCreateWithoutDelegatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDelegatesInput
    upsert?: ProjectUpsertWithoutDelegatesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDelegatesInput, ProjectUpdateWithoutDelegatesInput>, ProjectUncheckedUpdateWithoutDelegatesInput>
  }

  export type ProjectCreateNestedOneWithoutSpeakersInput = {
    create?: XOR<ProjectCreateWithoutSpeakersInput, ProjectUncheckedCreateWithoutSpeakersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSpeakersInput
    connect?: ProjectWhereUniqueInput
  }

  export type AgendaItemSpeakerCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutSpeakerInput, AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput> | AgendaItemSpeakerCreateWithoutSpeakerInput[] | AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput | AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput[]
    createMany?: AgendaItemSpeakerCreateManySpeakerInputEnvelope
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
  }

  export type AgendaItemSpeakerUncheckedCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutSpeakerInput, AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput> | AgendaItemSpeakerCreateWithoutSpeakerInput[] | AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput | AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput[]
    createMany?: AgendaItemSpeakerCreateManySpeakerInputEnvelope
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSpeakersNestedInput = {
    create?: XOR<ProjectCreateWithoutSpeakersInput, ProjectUncheckedCreateWithoutSpeakersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSpeakersInput
    upsert?: ProjectUpsertWithoutSpeakersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSpeakersInput, ProjectUpdateWithoutSpeakersInput>, ProjectUncheckedUpdateWithoutSpeakersInput>
  }

  export type AgendaItemSpeakerUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutSpeakerInput, AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput> | AgendaItemSpeakerCreateWithoutSpeakerInput[] | AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput | AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput[]
    upsert?: AgendaItemSpeakerUpsertWithWhereUniqueWithoutSpeakerInput | AgendaItemSpeakerUpsertWithWhereUniqueWithoutSpeakerInput[]
    createMany?: AgendaItemSpeakerCreateManySpeakerInputEnvelope
    set?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    disconnect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    delete?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    update?: AgendaItemSpeakerUpdateWithWhereUniqueWithoutSpeakerInput | AgendaItemSpeakerUpdateWithWhereUniqueWithoutSpeakerInput[]
    updateMany?: AgendaItemSpeakerUpdateManyWithWhereWithoutSpeakerInput | AgendaItemSpeakerUpdateManyWithWhereWithoutSpeakerInput[]
    deleteMany?: AgendaItemSpeakerScalarWhereInput | AgendaItemSpeakerScalarWhereInput[]
  }

  export type AgendaItemSpeakerUncheckedUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutSpeakerInput, AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput> | AgendaItemSpeakerCreateWithoutSpeakerInput[] | AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput | AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput[]
    upsert?: AgendaItemSpeakerUpsertWithWhereUniqueWithoutSpeakerInput | AgendaItemSpeakerUpsertWithWhereUniqueWithoutSpeakerInput[]
    createMany?: AgendaItemSpeakerCreateManySpeakerInputEnvelope
    set?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    disconnect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    delete?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    update?: AgendaItemSpeakerUpdateWithWhereUniqueWithoutSpeakerInput | AgendaItemSpeakerUpdateWithWhereUniqueWithoutSpeakerInput[]
    updateMany?: AgendaItemSpeakerUpdateManyWithWhereWithoutSpeakerInput | AgendaItemSpeakerUpdateManyWithWhereWithoutSpeakerInput[]
    deleteMany?: AgendaItemSpeakerScalarWhereInput | AgendaItemSpeakerScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMarketingCampaignsInput = {
    create?: XOR<ProjectCreateWithoutMarketingCampaignsInput, ProjectUncheckedCreateWithoutMarketingCampaignsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMarketingCampaignsInput
    connect?: ProjectWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutMarketingCampaignsNestedInput = {
    create?: XOR<ProjectCreateWithoutMarketingCampaignsInput, ProjectUncheckedCreateWithoutMarketingCampaignsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMarketingCampaignsInput
    upsert?: ProjectUpsertWithoutMarketingCampaignsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMarketingCampaignsInput, ProjectUpdateWithoutMarketingCampaignsInput>, ProjectUncheckedUpdateWithoutMarketingCampaignsInput>
  }

  export type ProjectCreateNestedOneWithoutLeadsInput = {
    create?: XOR<ProjectCreateWithoutLeadsInput, ProjectUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<ProjectCreateWithoutLeadsInput, ProjectUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadsInput
    upsert?: ProjectUpsertWithoutLeadsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLeadsInput, ProjectUpdateWithoutLeadsInput>, ProjectUncheckedUpdateWithoutLeadsInput>
  }

  export type ProjectCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSessionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ProjectUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSessionsInput
    upsert?: ProjectUpsertWithoutSessionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSessionsInput, ProjectUpdateWithoutSessionsInput>, ProjectUncheckedUpdateWithoutSessionsInput>
  }

  export type ProjectCreateNestedOneWithoutExhibitorsInput = {
    create?: XOR<ProjectCreateWithoutExhibitorsInput, ProjectUncheckedCreateWithoutExhibitorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutExhibitorsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutExhibitorsNestedInput = {
    create?: XOR<ProjectCreateWithoutExhibitorsInput, ProjectUncheckedCreateWithoutExhibitorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutExhibitorsInput
    upsert?: ProjectUpsertWithoutExhibitorsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutExhibitorsInput, ProjectUpdateWithoutExhibitorsInput>, ProjectUncheckedUpdateWithoutExhibitorsInput>
  }

  export type ProjectCreateNestedOneWithoutSponsorsInput = {
    create?: XOR<ProjectCreateWithoutSponsorsInput, ProjectUncheckedCreateWithoutSponsorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSponsorsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSponsorsNestedInput = {
    create?: XOR<ProjectCreateWithoutSponsorsInput, ProjectUncheckedCreateWithoutSponsorsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSponsorsInput
    upsert?: ProjectUpsertWithoutSponsorsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSponsorsInput, ProjectUpdateWithoutSponsorsInput>, ProjectUncheckedUpdateWithoutSponsorsInput>
  }

  export type ProjectCreateNestedOneWithoutPartnersInput = {
    create?: XOR<ProjectCreateWithoutPartnersInput, ProjectUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPartnersInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPartnersNestedInput = {
    create?: XOR<ProjectCreateWithoutPartnersInput, ProjectUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPartnersInput
    upsert?: ProjectUpsertWithoutPartnersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPartnersInput, ProjectUpdateWithoutPartnersInput>, ProjectUncheckedUpdateWithoutPartnersInput>
  }

  export type ProjectCreateNestedOneWithoutMediaPartnersInput = {
    create?: XOR<ProjectCreateWithoutMediaPartnersInput, ProjectUncheckedCreateWithoutMediaPartnersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaPartnersInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMediaPartnersNestedInput = {
    create?: XOR<ProjectCreateWithoutMediaPartnersInput, ProjectUncheckedCreateWithoutMediaPartnersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMediaPartnersInput
    upsert?: ProjectUpsertWithoutMediaPartnersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMediaPartnersInput, ProjectUpdateWithoutMediaPartnersInput>, ProjectUncheckedUpdateWithoutMediaPartnersInput>
  }

  export type ProjectCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProjectCreateWithoutOrdersInput, ProjectUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOrdersInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ProjectCreateWithoutOrdersInput, ProjectUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOrdersInput
    upsert?: ProjectUpsertWithoutOrdersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOrdersInput, ProjectUpdateWithoutOrdersInput>, ProjectUncheckedUpdateWithoutOrdersInput>
  }

  export type ProjectCreateNestedOneWithoutEnquiriesInput = {
    create?: XOR<ProjectCreateWithoutEnquiriesInput, ProjectUncheckedCreateWithoutEnquiriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEnquiriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutEnquiriesNestedInput = {
    create?: XOR<ProjectCreateWithoutEnquiriesInput, ProjectUncheckedCreateWithoutEnquiriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEnquiriesInput
    upsert?: ProjectUpsertWithoutEnquiriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEnquiriesInput, ProjectUpdateWithoutEnquiriesInput>, ProjectUncheckedUpdateWithoutEnquiriesInput>
  }

  export type ProjectCreateNestedOneWithoutUtmDataInput = {
    create?: XOR<ProjectCreateWithoutUtmDataInput, ProjectUncheckedCreateWithoutUtmDataInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUtmDataInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutUtmDataNestedInput = {
    create?: XOR<ProjectCreateWithoutUtmDataInput, ProjectUncheckedCreateWithoutUtmDataInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUtmDataInput
    upsert?: ProjectUpsertWithoutUtmDataInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUtmDataInput, ProjectUpdateWithoutUtmDataInput>, ProjectUncheckedUpdateWithoutUtmDataInput>
  }

  export type ProjectCreateNestedOneWithoutAgendaDaysInput = {
    create?: XOR<ProjectCreateWithoutAgendaDaysInput, ProjectUncheckedCreateWithoutAgendaDaysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAgendaDaysInput
    connect?: ProjectWhereUniqueInput
  }

  export type AgendaSessionCreateNestedManyWithoutDayInput = {
    create?: XOR<AgendaSessionCreateWithoutDayInput, AgendaSessionUncheckedCreateWithoutDayInput> | AgendaSessionCreateWithoutDayInput[] | AgendaSessionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AgendaSessionCreateOrConnectWithoutDayInput | AgendaSessionCreateOrConnectWithoutDayInput[]
    createMany?: AgendaSessionCreateManyDayInputEnvelope
    connect?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
  }

  export type AgendaSessionUncheckedCreateNestedManyWithoutDayInput = {
    create?: XOR<AgendaSessionCreateWithoutDayInput, AgendaSessionUncheckedCreateWithoutDayInput> | AgendaSessionCreateWithoutDayInput[] | AgendaSessionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AgendaSessionCreateOrConnectWithoutDayInput | AgendaSessionCreateOrConnectWithoutDayInput[]
    createMany?: AgendaSessionCreateManyDayInputEnvelope
    connect?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutAgendaDaysNestedInput = {
    create?: XOR<ProjectCreateWithoutAgendaDaysInput, ProjectUncheckedCreateWithoutAgendaDaysInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAgendaDaysInput
    upsert?: ProjectUpsertWithoutAgendaDaysInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAgendaDaysInput, ProjectUpdateWithoutAgendaDaysInput>, ProjectUncheckedUpdateWithoutAgendaDaysInput>
  }

  export type AgendaSessionUpdateManyWithoutDayNestedInput = {
    create?: XOR<AgendaSessionCreateWithoutDayInput, AgendaSessionUncheckedCreateWithoutDayInput> | AgendaSessionCreateWithoutDayInput[] | AgendaSessionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AgendaSessionCreateOrConnectWithoutDayInput | AgendaSessionCreateOrConnectWithoutDayInput[]
    upsert?: AgendaSessionUpsertWithWhereUniqueWithoutDayInput | AgendaSessionUpsertWithWhereUniqueWithoutDayInput[]
    createMany?: AgendaSessionCreateManyDayInputEnvelope
    set?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    disconnect?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    delete?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    connect?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    update?: AgendaSessionUpdateWithWhereUniqueWithoutDayInput | AgendaSessionUpdateWithWhereUniqueWithoutDayInput[]
    updateMany?: AgendaSessionUpdateManyWithWhereWithoutDayInput | AgendaSessionUpdateManyWithWhereWithoutDayInput[]
    deleteMany?: AgendaSessionScalarWhereInput | AgendaSessionScalarWhereInput[]
  }

  export type AgendaSessionUncheckedUpdateManyWithoutDayNestedInput = {
    create?: XOR<AgendaSessionCreateWithoutDayInput, AgendaSessionUncheckedCreateWithoutDayInput> | AgendaSessionCreateWithoutDayInput[] | AgendaSessionUncheckedCreateWithoutDayInput[]
    connectOrCreate?: AgendaSessionCreateOrConnectWithoutDayInput | AgendaSessionCreateOrConnectWithoutDayInput[]
    upsert?: AgendaSessionUpsertWithWhereUniqueWithoutDayInput | AgendaSessionUpsertWithWhereUniqueWithoutDayInput[]
    createMany?: AgendaSessionCreateManyDayInputEnvelope
    set?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    disconnect?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    delete?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    connect?: AgendaSessionWhereUniqueInput | AgendaSessionWhereUniqueInput[]
    update?: AgendaSessionUpdateWithWhereUniqueWithoutDayInput | AgendaSessionUpdateWithWhereUniqueWithoutDayInput[]
    updateMany?: AgendaSessionUpdateManyWithWhereWithoutDayInput | AgendaSessionUpdateManyWithWhereWithoutDayInput[]
    deleteMany?: AgendaSessionScalarWhereInput | AgendaSessionScalarWhereInput[]
  }

  export type AgendaDayCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AgendaDayCreateWithoutSessionsInput, AgendaDayUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AgendaDayCreateOrConnectWithoutSessionsInput
    connect?: AgendaDayWhereUniqueInput
  }

  export type AgendaItemCreateNestedManyWithoutSessionInput = {
    create?: XOR<AgendaItemCreateWithoutSessionInput, AgendaItemUncheckedCreateWithoutSessionInput> | AgendaItemCreateWithoutSessionInput[] | AgendaItemUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AgendaItemCreateOrConnectWithoutSessionInput | AgendaItemCreateOrConnectWithoutSessionInput[]
    createMany?: AgendaItemCreateManySessionInputEnvelope
    connect?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
  }

  export type AgendaItemUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AgendaItemCreateWithoutSessionInput, AgendaItemUncheckedCreateWithoutSessionInput> | AgendaItemCreateWithoutSessionInput[] | AgendaItemUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AgendaItemCreateOrConnectWithoutSessionInput | AgendaItemCreateOrConnectWithoutSessionInput[]
    createMany?: AgendaItemCreateManySessionInputEnvelope
    connect?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
  }

  export type AgendaDayUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AgendaDayCreateWithoutSessionsInput, AgendaDayUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AgendaDayCreateOrConnectWithoutSessionsInput
    upsert?: AgendaDayUpsertWithoutSessionsInput
    connect?: AgendaDayWhereUniqueInput
    update?: XOR<XOR<AgendaDayUpdateToOneWithWhereWithoutSessionsInput, AgendaDayUpdateWithoutSessionsInput>, AgendaDayUncheckedUpdateWithoutSessionsInput>
  }

  export type AgendaItemUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AgendaItemCreateWithoutSessionInput, AgendaItemUncheckedCreateWithoutSessionInput> | AgendaItemCreateWithoutSessionInput[] | AgendaItemUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AgendaItemCreateOrConnectWithoutSessionInput | AgendaItemCreateOrConnectWithoutSessionInput[]
    upsert?: AgendaItemUpsertWithWhereUniqueWithoutSessionInput | AgendaItemUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AgendaItemCreateManySessionInputEnvelope
    set?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    disconnect?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    delete?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    connect?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    update?: AgendaItemUpdateWithWhereUniqueWithoutSessionInput | AgendaItemUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AgendaItemUpdateManyWithWhereWithoutSessionInput | AgendaItemUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AgendaItemScalarWhereInput | AgendaItemScalarWhereInput[]
  }

  export type AgendaItemUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AgendaItemCreateWithoutSessionInput, AgendaItemUncheckedCreateWithoutSessionInput> | AgendaItemCreateWithoutSessionInput[] | AgendaItemUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AgendaItemCreateOrConnectWithoutSessionInput | AgendaItemCreateOrConnectWithoutSessionInput[]
    upsert?: AgendaItemUpsertWithWhereUniqueWithoutSessionInput | AgendaItemUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AgendaItemCreateManySessionInputEnvelope
    set?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    disconnect?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    delete?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    connect?: AgendaItemWhereUniqueInput | AgendaItemWhereUniqueInput[]
    update?: AgendaItemUpdateWithWhereUniqueWithoutSessionInput | AgendaItemUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AgendaItemUpdateManyWithWhereWithoutSessionInput | AgendaItemUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AgendaItemScalarWhereInput | AgendaItemScalarWhereInput[]
  }

  export type AgendaSessionCreateNestedOneWithoutItemsInput = {
    create?: XOR<AgendaSessionCreateWithoutItemsInput, AgendaSessionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AgendaSessionCreateOrConnectWithoutItemsInput
    connect?: AgendaSessionWhereUniqueInput
  }

  export type AgendaItemSpeakerCreateNestedManyWithoutAgendaItemInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput> | AgendaItemSpeakerCreateWithoutAgendaItemInput[] | AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput | AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput[]
    createMany?: AgendaItemSpeakerCreateManyAgendaItemInputEnvelope
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
  }

  export type AgendaItemSpeakerUncheckedCreateNestedManyWithoutAgendaItemInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput> | AgendaItemSpeakerCreateWithoutAgendaItemInput[] | AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput | AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput[]
    createMany?: AgendaItemSpeakerCreateManyAgendaItemInputEnvelope
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
  }

  export type AgendaSessionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AgendaSessionCreateWithoutItemsInput, AgendaSessionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AgendaSessionCreateOrConnectWithoutItemsInput
    upsert?: AgendaSessionUpsertWithoutItemsInput
    connect?: AgendaSessionWhereUniqueInput
    update?: XOR<XOR<AgendaSessionUpdateToOneWithWhereWithoutItemsInput, AgendaSessionUpdateWithoutItemsInput>, AgendaSessionUncheckedUpdateWithoutItemsInput>
  }

  export type AgendaItemSpeakerUpdateManyWithoutAgendaItemNestedInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput> | AgendaItemSpeakerCreateWithoutAgendaItemInput[] | AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput | AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput[]
    upsert?: AgendaItemSpeakerUpsertWithWhereUniqueWithoutAgendaItemInput | AgendaItemSpeakerUpsertWithWhereUniqueWithoutAgendaItemInput[]
    createMany?: AgendaItemSpeakerCreateManyAgendaItemInputEnvelope
    set?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    disconnect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    delete?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    update?: AgendaItemSpeakerUpdateWithWhereUniqueWithoutAgendaItemInput | AgendaItemSpeakerUpdateWithWhereUniqueWithoutAgendaItemInput[]
    updateMany?: AgendaItemSpeakerUpdateManyWithWhereWithoutAgendaItemInput | AgendaItemSpeakerUpdateManyWithWhereWithoutAgendaItemInput[]
    deleteMany?: AgendaItemSpeakerScalarWhereInput | AgendaItemSpeakerScalarWhereInput[]
  }

  export type AgendaItemSpeakerUncheckedUpdateManyWithoutAgendaItemNestedInput = {
    create?: XOR<AgendaItemSpeakerCreateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput> | AgendaItemSpeakerCreateWithoutAgendaItemInput[] | AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput[]
    connectOrCreate?: AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput | AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput[]
    upsert?: AgendaItemSpeakerUpsertWithWhereUniqueWithoutAgendaItemInput | AgendaItemSpeakerUpsertWithWhereUniqueWithoutAgendaItemInput[]
    createMany?: AgendaItemSpeakerCreateManyAgendaItemInputEnvelope
    set?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    disconnect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    delete?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    connect?: AgendaItemSpeakerWhereUniqueInput | AgendaItemSpeakerWhereUniqueInput[]
    update?: AgendaItemSpeakerUpdateWithWhereUniqueWithoutAgendaItemInput | AgendaItemSpeakerUpdateWithWhereUniqueWithoutAgendaItemInput[]
    updateMany?: AgendaItemSpeakerUpdateManyWithWhereWithoutAgendaItemInput | AgendaItemSpeakerUpdateManyWithWhereWithoutAgendaItemInput[]
    deleteMany?: AgendaItemSpeakerScalarWhereInput | AgendaItemSpeakerScalarWhereInput[]
  }

  export type AgendaItemCreateNestedOneWithoutSpeakersInput = {
    create?: XOR<AgendaItemCreateWithoutSpeakersInput, AgendaItemUncheckedCreateWithoutSpeakersInput>
    connectOrCreate?: AgendaItemCreateOrConnectWithoutSpeakersInput
    connect?: AgendaItemWhereUniqueInput
  }

  export type SpeakerCreateNestedOneWithoutAgendaItemsInput = {
    create?: XOR<SpeakerCreateWithoutAgendaItemsInput, SpeakerUncheckedCreateWithoutAgendaItemsInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutAgendaItemsInput
    connect?: SpeakerWhereUniqueInput
  }

  export type AgendaItemUpdateOneRequiredWithoutSpeakersNestedInput = {
    create?: XOR<AgendaItemCreateWithoutSpeakersInput, AgendaItemUncheckedCreateWithoutSpeakersInput>
    connectOrCreate?: AgendaItemCreateOrConnectWithoutSpeakersInput
    upsert?: AgendaItemUpsertWithoutSpeakersInput
    connect?: AgendaItemWhereUniqueInput
    update?: XOR<XOR<AgendaItemUpdateToOneWithWhereWithoutSpeakersInput, AgendaItemUpdateWithoutSpeakersInput>, AgendaItemUncheckedUpdateWithoutSpeakersInput>
  }

  export type SpeakerUpdateOneRequiredWithoutAgendaItemsNestedInput = {
    create?: XOR<SpeakerCreateWithoutAgendaItemsInput, SpeakerUncheckedCreateWithoutAgendaItemsInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutAgendaItemsInput
    upsert?: SpeakerUpsertWithoutAgendaItemsInput
    connect?: SpeakerWhereUniqueInput
    update?: XOR<XOR<SpeakerUpdateToOneWithWhereWithoutAgendaItemsInput, SpeakerUpdateWithoutAgendaItemsInput>, SpeakerUncheckedUpdateWithoutAgendaItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type ProjectStatsCreateWithoutProjectInput = {
    id?: string
    speakers?: number
    partners?: number
    mediaPartners?: number
    sponsors?: number
    exhibitors?: number
    delegates?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStatsUncheckedCreateWithoutProjectInput = {
    id?: string
    speakers?: number
    partners?: number
    mediaPartners?: number
    sponsors?: number
    exhibitors?: number
    delegates?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStatsCreateOrConnectWithoutProjectInput = {
    where: ProjectStatsWhereUniqueInput
    create: XOR<ProjectStatsCreateWithoutProjectInput, ProjectStatsUncheckedCreateWithoutProjectInput>
  }

  export type AttendeeCreateWithoutProjectInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    checkedIn?: boolean
    checkinTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendeeUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    checkedIn?: boolean
    checkinTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendeeCreateOrConnectWithoutProjectInput = {
    where: AttendeeWhereUniqueInput
    create: XOR<AttendeeCreateWithoutProjectInput, AttendeeUncheckedCreateWithoutProjectInput>
  }

  export type AttendeeCreateManyProjectInputEnvelope = {
    data: AttendeeCreateManyProjectInput | AttendeeCreateManyProjectInput[]
  }

  export type DelegateCreateWithoutProjectInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    booth?: string | null
    status?: string | null
    description?: string | null
    priority?: number
    featured?: boolean
    type: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DelegateUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    booth?: string | null
    status?: string | null
    description?: string | null
    priority?: number
    featured?: boolean
    type: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DelegateCreateOrConnectWithoutProjectInput = {
    where: DelegateWhereUniqueInput
    create: XOR<DelegateCreateWithoutProjectInput, DelegateUncheckedCreateWithoutProjectInput>
  }

  export type DelegateCreateManyProjectInputEnvelope = {
    data: DelegateCreateManyProjectInput | DelegateCreateManyProjectInput[]
  }

  export type SpeakerCreateWithoutProjectInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agendaItems?: AgendaItemSpeakerCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agendaItems?: AgendaItemSpeakerUncheckedCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerCreateOrConnectWithoutProjectInput = {
    where: SpeakerWhereUniqueInput
    create: XOR<SpeakerCreateWithoutProjectInput, SpeakerUncheckedCreateWithoutProjectInput>
  }

  export type SpeakerCreateManyProjectInputEnvelope = {
    data: SpeakerCreateManyProjectInput | SpeakerCreateManyProjectInput[]
  }

  export type MarketingCampaignCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    total?: number
    revenue?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingCampaignUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    total?: number
    revenue?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingCampaignCreateOrConnectWithoutProjectInput = {
    where: MarketingCampaignWhereUniqueInput
    create: XOR<MarketingCampaignCreateWithoutProjectInput, MarketingCampaignUncheckedCreateWithoutProjectInput>
  }

  export type MarketingCampaignCreateManyProjectInputEnvelope = {
    data: MarketingCampaignCreateManyProjectInput | MarketingCampaignCreateManyProjectInput[]
  }

  export type LeadCreateWithoutProjectInput = {
    id?: string
    name: string
    email: string
    contact?: string | null
    company?: string | null
    type?: string | null
    date?: Date | string | null
    qualifyStatus?: string | null
    salesStatus?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    email: string
    contact?: string | null
    company?: string | null
    type?: string | null
    date?: Date | string | null
    qualifyStatus?: string | null
    salesStatus?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateOrConnectWithoutProjectInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput>
  }

  export type LeadCreateManyProjectInputEnvelope = {
    data: LeadCreateManyProjectInput | LeadCreateManyProjectInput[]
  }

  export type SessionCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    startTime: string
    endTime: string
    date?: Date | string | null
    venue?: string | null
    day?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    startTime: string
    endTime: string
    date?: Date | string | null
    venue?: string | null
    day?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutProjectInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput>
  }

  export type SessionCreateManyProjectInputEnvelope = {
    data: SessionCreateManyProjectInput | SessionCreateManyProjectInput[]
  }

  export type ExhibitorCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    boothNumber?: string | null
    category?: string | null
    status?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExhibitorUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    boothNumber?: string | null
    category?: string | null
    status?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExhibitorCreateOrConnectWithoutProjectInput = {
    where: ExhibitorWhereUniqueInput
    create: XOR<ExhibitorCreateWithoutProjectInput, ExhibitorUncheckedCreateWithoutProjectInput>
  }

  export type ExhibitorCreateManyProjectInputEnvelope = {
    data: ExhibitorCreateManyProjectInput | ExhibitorCreateManyProjectInput[]
  }

  export type SponsorCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    level: string
    amount?: string | null
    status?: string | null
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsorUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    level: string
    amount?: string | null
    status?: string | null
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsorCreateOrConnectWithoutProjectInput = {
    where: SponsorWhereUniqueInput
    create: XOR<SponsorCreateWithoutProjectInput, SponsorUncheckedCreateWithoutProjectInput>
  }

  export type SponsorCreateManyProjectInputEnvelope = {
    data: SponsorCreateManyProjectInput | SponsorCreateManyProjectInput[]
  }

  export type PartnerCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    type?: string | null
    website?: string | null
    status?: string | null
    contribution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    type?: string | null
    website?: string | null
    status?: string | null
    contribution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCreateOrConnectWithoutProjectInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutProjectInput, PartnerUncheckedCreateWithoutProjectInput>
  }

  export type PartnerCreateManyProjectInputEnvelope = {
    data: PartnerCreateManyProjectInput | PartnerCreateManyProjectInput[]
  }

  export type MediaPartnerCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    website?: string | null
    type?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaPartnerUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    image?: string | null
    website?: string | null
    type?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaPartnerCreateOrConnectWithoutProjectInput = {
    where: MediaPartnerWhereUniqueInput
    create: XOR<MediaPartnerCreateWithoutProjectInput, MediaPartnerUncheckedCreateWithoutProjectInput>
  }

  export type MediaPartnerCreateManyProjectInputEnvelope = {
    data: MediaPartnerCreateManyProjectInput | MediaPartnerCreateManyProjectInput[]
  }

  export type OrderCreateWithoutProjectInput = {
    id?: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutProjectInput = {
    id?: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutProjectInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput>
  }

  export type OrderCreateManyProjectInputEnvelope = {
    data: OrderCreateManyProjectInput | OrderCreateManyProjectInput[]
  }

  export type EnquiryCreateWithoutProjectInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnquiryUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnquiryCreateOrConnectWithoutProjectInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutProjectInput, EnquiryUncheckedCreateWithoutProjectInput>
  }

  export type EnquiryCreateManyProjectInputEnvelope = {
    data: EnquiryCreateManyProjectInput | EnquiryCreateManyProjectInput[]
  }

  export type UtmDataCreateWithoutProjectInput = {
    id?: string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    term?: string | null
    content?: string | null
    visits?: number
    conversions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtmDataUncheckedCreateWithoutProjectInput = {
    id?: string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    term?: string | null
    content?: string | null
    visits?: number
    conversions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtmDataCreateOrConnectWithoutProjectInput = {
    where: UtmDataWhereUniqueInput
    create: XOR<UtmDataCreateWithoutProjectInput, UtmDataUncheckedCreateWithoutProjectInput>
  }

  export type UtmDataCreateManyProjectInputEnvelope = {
    data: UtmDataCreateManyProjectInput | UtmDataCreateManyProjectInput[]
  }

  export type AgendaDayCreateWithoutProjectInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AgendaSessionCreateNestedManyWithoutDayInput
  }

  export type AgendaDayUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AgendaSessionUncheckedCreateNestedManyWithoutDayInput
  }

  export type AgendaDayCreateOrConnectWithoutProjectInput = {
    where: AgendaDayWhereUniqueInput
    create: XOR<AgendaDayCreateWithoutProjectInput, AgendaDayUncheckedCreateWithoutProjectInput>
  }

  export type AgendaDayCreateManyProjectInputEnvelope = {
    data: AgendaDayCreateManyProjectInput | AgendaDayCreateManyProjectInput[]
  }

  export type ProjectStatsUpsertWithoutProjectInput = {
    update: XOR<ProjectStatsUpdateWithoutProjectInput, ProjectStatsUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectStatsCreateWithoutProjectInput, ProjectStatsUncheckedCreateWithoutProjectInput>
    where?: ProjectStatsWhereInput
  }

  export type ProjectStatsUpdateToOneWithWhereWithoutProjectInput = {
    where?: ProjectStatsWhereInput
    data: XOR<ProjectStatsUpdateWithoutProjectInput, ProjectStatsUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectStatsUpdateWithoutProjectInput = {
    speakers?: IntFieldUpdateOperationsInput | number
    partners?: IntFieldUpdateOperationsInput | number
    mediaPartners?: IntFieldUpdateOperationsInput | number
    sponsors?: IntFieldUpdateOperationsInput | number
    exhibitors?: IntFieldUpdateOperationsInput | number
    delegates?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatsUncheckedUpdateWithoutProjectInput = {
    speakers?: IntFieldUpdateOperationsInput | number
    partners?: IntFieldUpdateOperationsInput | number
    mediaPartners?: IntFieldUpdateOperationsInput | number
    sponsors?: IntFieldUpdateOperationsInput | number
    exhibitors?: IntFieldUpdateOperationsInput | number
    delegates?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeUpsertWithWhereUniqueWithoutProjectInput = {
    where: AttendeeWhereUniqueInput
    update: XOR<AttendeeUpdateWithoutProjectInput, AttendeeUncheckedUpdateWithoutProjectInput>
    create: XOR<AttendeeCreateWithoutProjectInput, AttendeeUncheckedCreateWithoutProjectInput>
  }

  export type AttendeeUpdateWithWhereUniqueWithoutProjectInput = {
    where: AttendeeWhereUniqueInput
    data: XOR<AttendeeUpdateWithoutProjectInput, AttendeeUncheckedUpdateWithoutProjectInput>
  }

  export type AttendeeUpdateManyWithWhereWithoutProjectInput = {
    where: AttendeeScalarWhereInput
    data: XOR<AttendeeUpdateManyMutationInput, AttendeeUncheckedUpdateManyWithoutProjectInput>
  }

  export type AttendeeScalarWhereInput = {
    AND?: AttendeeScalarWhereInput | AttendeeScalarWhereInput[]
    OR?: AttendeeScalarWhereInput[]
    NOT?: AttendeeScalarWhereInput | AttendeeScalarWhereInput[]
    id?: StringFilter<"Attendee"> | string
    name?: StringFilter<"Attendee"> | string
    email?: StringFilter<"Attendee"> | string
    phone?: StringNullableFilter<"Attendee"> | string | null
    company?: StringNullableFilter<"Attendee"> | string | null
    jobTitle?: StringNullableFilter<"Attendee"> | string | null
    checkedIn?: BoolFilter<"Attendee"> | boolean
    checkinTime?: DateTimeNullableFilter<"Attendee"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendee"> | Date | string
    updatedAt?: DateTimeFilter<"Attendee"> | Date | string
    projectId?: StringFilter<"Attendee"> | string
  }

  export type DelegateUpsertWithWhereUniqueWithoutProjectInput = {
    where: DelegateWhereUniqueInput
    update: XOR<DelegateUpdateWithoutProjectInput, DelegateUncheckedUpdateWithoutProjectInput>
    create: XOR<DelegateCreateWithoutProjectInput, DelegateUncheckedCreateWithoutProjectInput>
  }

  export type DelegateUpdateWithWhereUniqueWithoutProjectInput = {
    where: DelegateWhereUniqueInput
    data: XOR<DelegateUpdateWithoutProjectInput, DelegateUncheckedUpdateWithoutProjectInput>
  }

  export type DelegateUpdateManyWithWhereWithoutProjectInput = {
    where: DelegateScalarWhereInput
    data: XOR<DelegateUpdateManyMutationInput, DelegateUncheckedUpdateManyWithoutProjectInput>
  }

  export type DelegateScalarWhereInput = {
    AND?: DelegateScalarWhereInput | DelegateScalarWhereInput[]
    OR?: DelegateScalarWhereInput[]
    NOT?: DelegateScalarWhereInput | DelegateScalarWhereInput[]
    id?: StringFilter<"Delegate"> | string
    name?: StringFilter<"Delegate"> | string
    email?: StringNullableFilter<"Delegate"> | string | null
    phone?: StringNullableFilter<"Delegate"> | string | null
    company?: StringNullableFilter<"Delegate"> | string | null
    jobTitle?: StringNullableFilter<"Delegate"> | string | null
    address?: StringNullableFilter<"Delegate"> | string | null
    booth?: StringNullableFilter<"Delegate"> | string | null
    status?: StringNullableFilter<"Delegate"> | string | null
    description?: StringNullableFilter<"Delegate"> | string | null
    priority?: IntFilter<"Delegate"> | number
    featured?: BoolFilter<"Delegate"> | boolean
    type?: StringFilter<"Delegate"> | string
    image?: StringNullableFilter<"Delegate"> | string | null
    createdAt?: DateTimeFilter<"Delegate"> | Date | string
    updatedAt?: DateTimeFilter<"Delegate"> | Date | string
    projectId?: StringFilter<"Delegate"> | string
  }

  export type SpeakerUpsertWithWhereUniqueWithoutProjectInput = {
    where: SpeakerWhereUniqueInput
    update: XOR<SpeakerUpdateWithoutProjectInput, SpeakerUncheckedUpdateWithoutProjectInput>
    create: XOR<SpeakerCreateWithoutProjectInput, SpeakerUncheckedCreateWithoutProjectInput>
  }

  export type SpeakerUpdateWithWhereUniqueWithoutProjectInput = {
    where: SpeakerWhereUniqueInput
    data: XOR<SpeakerUpdateWithoutProjectInput, SpeakerUncheckedUpdateWithoutProjectInput>
  }

  export type SpeakerUpdateManyWithWhereWithoutProjectInput = {
    where: SpeakerScalarWhereInput
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyWithoutProjectInput>
  }

  export type SpeakerScalarWhereInput = {
    AND?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[]
    OR?: SpeakerScalarWhereInput[]
    NOT?: SpeakerScalarWhereInput | SpeakerScalarWhereInput[]
    id?: StringFilter<"Speaker"> | string
    name?: StringFilter<"Speaker"> | string
    email?: StringNullableFilter<"Speaker"> | string | null
    phone?: StringNullableFilter<"Speaker"> | string | null
    company?: StringNullableFilter<"Speaker"> | string | null
    position?: StringNullableFilter<"Speaker"> | string | null
    bio?: StringNullableFilter<"Speaker"> | string | null
    featured?: BoolFilter<"Speaker"> | boolean
    image?: StringNullableFilter<"Speaker"> | string | null
    createdAt?: DateTimeFilter<"Speaker"> | Date | string
    updatedAt?: DateTimeFilter<"Speaker"> | Date | string
    projectId?: StringFilter<"Speaker"> | string
  }

  export type MarketingCampaignUpsertWithWhereUniqueWithoutProjectInput = {
    where: MarketingCampaignWhereUniqueInput
    update: XOR<MarketingCampaignUpdateWithoutProjectInput, MarketingCampaignUncheckedUpdateWithoutProjectInput>
    create: XOR<MarketingCampaignCreateWithoutProjectInput, MarketingCampaignUncheckedCreateWithoutProjectInput>
  }

  export type MarketingCampaignUpdateWithWhereUniqueWithoutProjectInput = {
    where: MarketingCampaignWhereUniqueInput
    data: XOR<MarketingCampaignUpdateWithoutProjectInput, MarketingCampaignUncheckedUpdateWithoutProjectInput>
  }

  export type MarketingCampaignUpdateManyWithWhereWithoutProjectInput = {
    where: MarketingCampaignScalarWhereInput
    data: XOR<MarketingCampaignUpdateManyMutationInput, MarketingCampaignUncheckedUpdateManyWithoutProjectInput>
  }

  export type MarketingCampaignScalarWhereInput = {
    AND?: MarketingCampaignScalarWhereInput | MarketingCampaignScalarWhereInput[]
    OR?: MarketingCampaignScalarWhereInput[]
    NOT?: MarketingCampaignScalarWhereInput | MarketingCampaignScalarWhereInput[]
    id?: StringFilter<"MarketingCampaign"> | string
    name?: StringFilter<"MarketingCampaign"> | string
    type?: StringFilter<"MarketingCampaign"> | string
    total?: IntFilter<"MarketingCampaign"> | number
    revenue?: FloatFilter<"MarketingCampaign"> | number
    startDate?: DateTimeNullableFilter<"MarketingCampaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"MarketingCampaign"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketingCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingCampaign"> | Date | string
    projectId?: StringFilter<"MarketingCampaign"> | string
  }

  export type LeadUpsertWithWhereUniqueWithoutProjectInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutProjectInput, LeadUncheckedUpdateWithoutProjectInput>
    create: XOR<LeadCreateWithoutProjectInput, LeadUncheckedCreateWithoutProjectInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutProjectInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutProjectInput, LeadUncheckedUpdateWithoutProjectInput>
  }

  export type LeadUpdateManyWithWhereWithoutProjectInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutProjectInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    contact?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    type?: StringNullableFilter<"Lead"> | string | null
    date?: DateTimeNullableFilter<"Lead"> | Date | string | null
    qualifyStatus?: StringNullableFilter<"Lead"> | string | null
    salesStatus?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    projectId?: StringFilter<"Lead"> | string
  }

  export type SessionUpsertWithWhereUniqueWithoutProjectInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutProjectInput, SessionUncheckedUpdateWithoutProjectInput>
    create: XOR<SessionCreateWithoutProjectInput, SessionUncheckedCreateWithoutProjectInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutProjectInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutProjectInput, SessionUncheckedUpdateWithoutProjectInput>
  }

  export type SessionUpdateManyWithWhereWithoutProjectInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutProjectInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    title?: StringFilter<"Session"> | string
    description?: StringNullableFilter<"Session"> | string | null
    startTime?: StringFilter<"Session"> | string
    endTime?: StringFilter<"Session"> | string
    date?: DateTimeNullableFilter<"Session"> | Date | string | null
    venue?: StringNullableFilter<"Session"> | string | null
    day?: IntNullableFilter<"Session"> | number | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    projectId?: StringFilter<"Session"> | string
  }

  export type ExhibitorUpsertWithWhereUniqueWithoutProjectInput = {
    where: ExhibitorWhereUniqueInput
    update: XOR<ExhibitorUpdateWithoutProjectInput, ExhibitorUncheckedUpdateWithoutProjectInput>
    create: XOR<ExhibitorCreateWithoutProjectInput, ExhibitorUncheckedCreateWithoutProjectInput>
  }

  export type ExhibitorUpdateWithWhereUniqueWithoutProjectInput = {
    where: ExhibitorWhereUniqueInput
    data: XOR<ExhibitorUpdateWithoutProjectInput, ExhibitorUncheckedUpdateWithoutProjectInput>
  }

  export type ExhibitorUpdateManyWithWhereWithoutProjectInput = {
    where: ExhibitorScalarWhereInput
    data: XOR<ExhibitorUpdateManyMutationInput, ExhibitorUncheckedUpdateManyWithoutProjectInput>
  }

  export type ExhibitorScalarWhereInput = {
    AND?: ExhibitorScalarWhereInput | ExhibitorScalarWhereInput[]
    OR?: ExhibitorScalarWhereInput[]
    NOT?: ExhibitorScalarWhereInput | ExhibitorScalarWhereInput[]
    id?: StringFilter<"Exhibitor"> | string
    name?: StringFilter<"Exhibitor"> | string
    image?: StringNullableFilter<"Exhibitor"> | string | null
    boothNumber?: StringNullableFilter<"Exhibitor"> | string | null
    category?: StringNullableFilter<"Exhibitor"> | string | null
    status?: StringNullableFilter<"Exhibitor"> | string | null
    size?: StringNullableFilter<"Exhibitor"> | string | null
    createdAt?: DateTimeFilter<"Exhibitor"> | Date | string
    updatedAt?: DateTimeFilter<"Exhibitor"> | Date | string
    projectId?: StringFilter<"Exhibitor"> | string
  }

  export type SponsorUpsertWithWhereUniqueWithoutProjectInput = {
    where: SponsorWhereUniqueInput
    update: XOR<SponsorUpdateWithoutProjectInput, SponsorUncheckedUpdateWithoutProjectInput>
    create: XOR<SponsorCreateWithoutProjectInput, SponsorUncheckedCreateWithoutProjectInput>
  }

  export type SponsorUpdateWithWhereUniqueWithoutProjectInput = {
    where: SponsorWhereUniqueInput
    data: XOR<SponsorUpdateWithoutProjectInput, SponsorUncheckedUpdateWithoutProjectInput>
  }

  export type SponsorUpdateManyWithWhereWithoutProjectInput = {
    where: SponsorScalarWhereInput
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyWithoutProjectInput>
  }

  export type SponsorScalarWhereInput = {
    AND?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
    OR?: SponsorScalarWhereInput[]
    NOT?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
    id?: StringFilter<"Sponsor"> | string
    name?: StringFilter<"Sponsor"> | string
    image?: StringNullableFilter<"Sponsor"> | string | null
    level?: StringFilter<"Sponsor"> | string
    amount?: StringNullableFilter<"Sponsor"> | string | null
    status?: StringNullableFilter<"Sponsor"> | string | null
    benefits?: StringNullableFilter<"Sponsor"> | string | null
    createdAt?: DateTimeFilter<"Sponsor"> | Date | string
    updatedAt?: DateTimeFilter<"Sponsor"> | Date | string
    projectId?: StringFilter<"Sponsor"> | string
  }

  export type PartnerUpsertWithWhereUniqueWithoutProjectInput = {
    where: PartnerWhereUniqueInput
    update: XOR<PartnerUpdateWithoutProjectInput, PartnerUncheckedUpdateWithoutProjectInput>
    create: XOR<PartnerCreateWithoutProjectInput, PartnerUncheckedCreateWithoutProjectInput>
  }

  export type PartnerUpdateWithWhereUniqueWithoutProjectInput = {
    where: PartnerWhereUniqueInput
    data: XOR<PartnerUpdateWithoutProjectInput, PartnerUncheckedUpdateWithoutProjectInput>
  }

  export type PartnerUpdateManyWithWhereWithoutProjectInput = {
    where: PartnerScalarWhereInput
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyWithoutProjectInput>
  }

  export type PartnerScalarWhereInput = {
    AND?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
    OR?: PartnerScalarWhereInput[]
    NOT?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
    id?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    image?: StringNullableFilter<"Partner"> | string | null
    type?: StringNullableFilter<"Partner"> | string | null
    website?: StringNullableFilter<"Partner"> | string | null
    status?: StringNullableFilter<"Partner"> | string | null
    contribution?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    projectId?: StringFilter<"Partner"> | string
  }

  export type MediaPartnerUpsertWithWhereUniqueWithoutProjectInput = {
    where: MediaPartnerWhereUniqueInput
    update: XOR<MediaPartnerUpdateWithoutProjectInput, MediaPartnerUncheckedUpdateWithoutProjectInput>
    create: XOR<MediaPartnerCreateWithoutProjectInput, MediaPartnerUncheckedCreateWithoutProjectInput>
  }

  export type MediaPartnerUpdateWithWhereUniqueWithoutProjectInput = {
    where: MediaPartnerWhereUniqueInput
    data: XOR<MediaPartnerUpdateWithoutProjectInput, MediaPartnerUncheckedUpdateWithoutProjectInput>
  }

  export type MediaPartnerUpdateManyWithWhereWithoutProjectInput = {
    where: MediaPartnerScalarWhereInput
    data: XOR<MediaPartnerUpdateManyMutationInput, MediaPartnerUncheckedUpdateManyWithoutProjectInput>
  }

  export type MediaPartnerScalarWhereInput = {
    AND?: MediaPartnerScalarWhereInput | MediaPartnerScalarWhereInput[]
    OR?: MediaPartnerScalarWhereInput[]
    NOT?: MediaPartnerScalarWhereInput | MediaPartnerScalarWhereInput[]
    id?: StringFilter<"MediaPartner"> | string
    name?: StringFilter<"MediaPartner"> | string
    image?: StringNullableFilter<"MediaPartner"> | string | null
    website?: StringNullableFilter<"MediaPartner"> | string | null
    type?: StringNullableFilter<"MediaPartner"> | string | null
    priority?: IntFilter<"MediaPartner"> | number
    createdAt?: DateTimeFilter<"MediaPartner"> | Date | string
    updatedAt?: DateTimeFilter<"MediaPartner"> | Date | string
    projectId?: StringFilter<"MediaPartner"> | string
  }

  export type OrderUpsertWithWhereUniqueWithoutProjectInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProjectInput, OrderUncheckedUpdateWithoutProjectInput>
    create: XOR<OrderCreateWithoutProjectInput, OrderUncheckedCreateWithoutProjectInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProjectInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProjectInput, OrderUncheckedUpdateWithoutProjectInput>
  }

  export type OrderUpdateManyWithWhereWithoutProjectInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutProjectInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    customerName?: StringFilter<"Order"> | string
    customerEmail?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    status?: StringFilter<"Order"> | string
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    projectId?: StringFilter<"Order"> | string
  }

  export type EnquiryUpsertWithWhereUniqueWithoutProjectInput = {
    where: EnquiryWhereUniqueInput
    update: XOR<EnquiryUpdateWithoutProjectInput, EnquiryUncheckedUpdateWithoutProjectInput>
    create: XOR<EnquiryCreateWithoutProjectInput, EnquiryUncheckedCreateWithoutProjectInput>
  }

  export type EnquiryUpdateWithWhereUniqueWithoutProjectInput = {
    where: EnquiryWhereUniqueInput
    data: XOR<EnquiryUpdateWithoutProjectInput, EnquiryUncheckedUpdateWithoutProjectInput>
  }

  export type EnquiryUpdateManyWithWhereWithoutProjectInput = {
    where: EnquiryScalarWhereInput
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyWithoutProjectInput>
  }

  export type EnquiryScalarWhereInput = {
    AND?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
    OR?: EnquiryScalarWhereInput[]
    NOT?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
    id?: StringFilter<"Enquiry"> | string
    name?: StringFilter<"Enquiry"> | string
    email?: StringFilter<"Enquiry"> | string
    phone?: StringNullableFilter<"Enquiry"> | string | null
    subject?: StringNullableFilter<"Enquiry"> | string | null
    message?: StringFilter<"Enquiry"> | string
    status?: StringFilter<"Enquiry"> | string
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    projectId?: StringFilter<"Enquiry"> | string
  }

  export type UtmDataUpsertWithWhereUniqueWithoutProjectInput = {
    where: UtmDataWhereUniqueInput
    update: XOR<UtmDataUpdateWithoutProjectInput, UtmDataUncheckedUpdateWithoutProjectInput>
    create: XOR<UtmDataCreateWithoutProjectInput, UtmDataUncheckedCreateWithoutProjectInput>
  }

  export type UtmDataUpdateWithWhereUniqueWithoutProjectInput = {
    where: UtmDataWhereUniqueInput
    data: XOR<UtmDataUpdateWithoutProjectInput, UtmDataUncheckedUpdateWithoutProjectInput>
  }

  export type UtmDataUpdateManyWithWhereWithoutProjectInput = {
    where: UtmDataScalarWhereInput
    data: XOR<UtmDataUpdateManyMutationInput, UtmDataUncheckedUpdateManyWithoutProjectInput>
  }

  export type UtmDataScalarWhereInput = {
    AND?: UtmDataScalarWhereInput | UtmDataScalarWhereInput[]
    OR?: UtmDataScalarWhereInput[]
    NOT?: UtmDataScalarWhereInput | UtmDataScalarWhereInput[]
    id?: StringFilter<"UtmData"> | string
    source?: StringNullableFilter<"UtmData"> | string | null
    medium?: StringNullableFilter<"UtmData"> | string | null
    campaign?: StringNullableFilter<"UtmData"> | string | null
    term?: StringNullableFilter<"UtmData"> | string | null
    content?: StringNullableFilter<"UtmData"> | string | null
    visits?: IntFilter<"UtmData"> | number
    conversions?: IntFilter<"UtmData"> | number
    createdAt?: DateTimeFilter<"UtmData"> | Date | string
    updatedAt?: DateTimeFilter<"UtmData"> | Date | string
    projectId?: StringFilter<"UtmData"> | string
  }

  export type AgendaDayUpsertWithWhereUniqueWithoutProjectInput = {
    where: AgendaDayWhereUniqueInput
    update: XOR<AgendaDayUpdateWithoutProjectInput, AgendaDayUncheckedUpdateWithoutProjectInput>
    create: XOR<AgendaDayCreateWithoutProjectInput, AgendaDayUncheckedCreateWithoutProjectInput>
  }

  export type AgendaDayUpdateWithWhereUniqueWithoutProjectInput = {
    where: AgendaDayWhereUniqueInput
    data: XOR<AgendaDayUpdateWithoutProjectInput, AgendaDayUncheckedUpdateWithoutProjectInput>
  }

  export type AgendaDayUpdateManyWithWhereWithoutProjectInput = {
    where: AgendaDayScalarWhereInput
    data: XOR<AgendaDayUpdateManyMutationInput, AgendaDayUncheckedUpdateManyWithoutProjectInput>
  }

  export type AgendaDayScalarWhereInput = {
    AND?: AgendaDayScalarWhereInput | AgendaDayScalarWhereInput[]
    OR?: AgendaDayScalarWhereInput[]
    NOT?: AgendaDayScalarWhereInput | AgendaDayScalarWhereInput[]
    id?: StringFilter<"AgendaDay"> | string
    name?: StringFilter<"AgendaDay"> | string
    date?: DateTimeFilter<"AgendaDay"> | Date | string
    dayNumber?: IntFilter<"AgendaDay"> | number
    createdAt?: DateTimeFilter<"AgendaDay"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaDay"> | Date | string
    projectId?: StringFilter<"AgendaDay"> | string
  }

  export type ProjectCreateWithoutStatsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutStatsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutStatsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
  }

  export type ProjectUpsertWithoutStatsInput = {
    update: XOR<ProjectUpdateWithoutStatsInput, ProjectUncheckedUpdateWithoutStatsInput>
    create: XOR<ProjectCreateWithoutStatsInput, ProjectUncheckedCreateWithoutStatsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutStatsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutStatsInput, ProjectUncheckedUpdateWithoutStatsInput>
  }

  export type ProjectUpdateWithoutStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutAttendeesInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAttendeesInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAttendeesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAttendeesInput, ProjectUncheckedCreateWithoutAttendeesInput>
  }

  export type ProjectUpsertWithoutAttendeesInput = {
    update: XOR<ProjectUpdateWithoutAttendeesInput, ProjectUncheckedUpdateWithoutAttendeesInput>
    create: XOR<ProjectCreateWithoutAttendeesInput, ProjectUncheckedCreateWithoutAttendeesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAttendeesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAttendeesInput, ProjectUncheckedUpdateWithoutAttendeesInput>
  }

  export type ProjectUpdateWithoutAttendeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAttendeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutDelegatesInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDelegatesInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDelegatesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDelegatesInput, ProjectUncheckedCreateWithoutDelegatesInput>
  }

  export type ProjectUpsertWithoutDelegatesInput = {
    update: XOR<ProjectUpdateWithoutDelegatesInput, ProjectUncheckedUpdateWithoutDelegatesInput>
    create: XOR<ProjectCreateWithoutDelegatesInput, ProjectUncheckedCreateWithoutDelegatesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDelegatesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDelegatesInput, ProjectUncheckedUpdateWithoutDelegatesInput>
  }

  export type ProjectUpdateWithoutDelegatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDelegatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSpeakersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSpeakersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSpeakersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSpeakersInput, ProjectUncheckedCreateWithoutSpeakersInput>
  }

  export type AgendaItemSpeakerCreateWithoutSpeakerInput = {
    id?: string
    createdAt?: Date | string
    agendaItem: AgendaItemCreateNestedOneWithoutSpeakersInput
  }

  export type AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput = {
    id?: string
    createdAt?: Date | string
    agendaItemId: string
  }

  export type AgendaItemSpeakerCreateOrConnectWithoutSpeakerInput = {
    where: AgendaItemSpeakerWhereUniqueInput
    create: XOR<AgendaItemSpeakerCreateWithoutSpeakerInput, AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput>
  }

  export type AgendaItemSpeakerCreateManySpeakerInputEnvelope = {
    data: AgendaItemSpeakerCreateManySpeakerInput | AgendaItemSpeakerCreateManySpeakerInput[]
  }

  export type ProjectUpsertWithoutSpeakersInput = {
    update: XOR<ProjectUpdateWithoutSpeakersInput, ProjectUncheckedUpdateWithoutSpeakersInput>
    create: XOR<ProjectCreateWithoutSpeakersInput, ProjectUncheckedCreateWithoutSpeakersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSpeakersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSpeakersInput, ProjectUncheckedUpdateWithoutSpeakersInput>
  }

  export type ProjectUpdateWithoutSpeakersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSpeakersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AgendaItemSpeakerUpsertWithWhereUniqueWithoutSpeakerInput = {
    where: AgendaItemSpeakerWhereUniqueInput
    update: XOR<AgendaItemSpeakerUpdateWithoutSpeakerInput, AgendaItemSpeakerUncheckedUpdateWithoutSpeakerInput>
    create: XOR<AgendaItemSpeakerCreateWithoutSpeakerInput, AgendaItemSpeakerUncheckedCreateWithoutSpeakerInput>
  }

  export type AgendaItemSpeakerUpdateWithWhereUniqueWithoutSpeakerInput = {
    where: AgendaItemSpeakerWhereUniqueInput
    data: XOR<AgendaItemSpeakerUpdateWithoutSpeakerInput, AgendaItemSpeakerUncheckedUpdateWithoutSpeakerInput>
  }

  export type AgendaItemSpeakerUpdateManyWithWhereWithoutSpeakerInput = {
    where: AgendaItemSpeakerScalarWhereInput
    data: XOR<AgendaItemSpeakerUpdateManyMutationInput, AgendaItemSpeakerUncheckedUpdateManyWithoutSpeakerInput>
  }

  export type AgendaItemSpeakerScalarWhereInput = {
    AND?: AgendaItemSpeakerScalarWhereInput | AgendaItemSpeakerScalarWhereInput[]
    OR?: AgendaItemSpeakerScalarWhereInput[]
    NOT?: AgendaItemSpeakerScalarWhereInput | AgendaItemSpeakerScalarWhereInput[]
    id?: StringFilter<"AgendaItemSpeaker"> | string
    createdAt?: DateTimeFilter<"AgendaItemSpeaker"> | Date | string
    agendaItemId?: StringFilter<"AgendaItemSpeaker"> | string
    speakerId?: StringFilter<"AgendaItemSpeaker"> | string
  }

  export type ProjectCreateWithoutMarketingCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMarketingCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMarketingCampaignsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMarketingCampaignsInput, ProjectUncheckedCreateWithoutMarketingCampaignsInput>
  }

  export type ProjectUpsertWithoutMarketingCampaignsInput = {
    update: XOR<ProjectUpdateWithoutMarketingCampaignsInput, ProjectUncheckedUpdateWithoutMarketingCampaignsInput>
    create: XOR<ProjectCreateWithoutMarketingCampaignsInput, ProjectUncheckedCreateWithoutMarketingCampaignsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMarketingCampaignsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMarketingCampaignsInput, ProjectUncheckedUpdateWithoutMarketingCampaignsInput>
  }

  export type ProjectUpdateWithoutMarketingCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMarketingCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutLeadsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLeadsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLeadsInput, ProjectUncheckedCreateWithoutLeadsInput>
  }

  export type ProjectUpsertWithoutLeadsInput = {
    update: XOR<ProjectUpdateWithoutLeadsInput, ProjectUncheckedUpdateWithoutLeadsInput>
    create: XOR<ProjectCreateWithoutLeadsInput, ProjectUncheckedCreateWithoutLeadsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLeadsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLeadsInput, ProjectUncheckedUpdateWithoutLeadsInput>
  }

  export type ProjectUpdateWithoutLeadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLeadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSessionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
  }

  export type ProjectUpsertWithoutSessionsInput = {
    update: XOR<ProjectUpdateWithoutSessionsInput, ProjectUncheckedUpdateWithoutSessionsInput>
    create: XOR<ProjectCreateWithoutSessionsInput, ProjectUncheckedCreateWithoutSessionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSessionsInput, ProjectUncheckedUpdateWithoutSessionsInput>
  }

  export type ProjectUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutExhibitorsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutExhibitorsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutExhibitorsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutExhibitorsInput, ProjectUncheckedCreateWithoutExhibitorsInput>
  }

  export type ProjectUpsertWithoutExhibitorsInput = {
    update: XOR<ProjectUpdateWithoutExhibitorsInput, ProjectUncheckedUpdateWithoutExhibitorsInput>
    create: XOR<ProjectCreateWithoutExhibitorsInput, ProjectUncheckedCreateWithoutExhibitorsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutExhibitorsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutExhibitorsInput, ProjectUncheckedUpdateWithoutExhibitorsInput>
  }

  export type ProjectUpdateWithoutExhibitorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutExhibitorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutSponsorsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSponsorsInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSponsorsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSponsorsInput, ProjectUncheckedCreateWithoutSponsorsInput>
  }

  export type ProjectUpsertWithoutSponsorsInput = {
    update: XOR<ProjectUpdateWithoutSponsorsInput, ProjectUncheckedUpdateWithoutSponsorsInput>
    create: XOR<ProjectCreateWithoutSponsorsInput, ProjectUncheckedCreateWithoutSponsorsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSponsorsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSponsorsInput, ProjectUncheckedUpdateWithoutSponsorsInput>
  }

  export type ProjectUpdateWithoutSponsorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSponsorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPartnersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPartnersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPartnersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPartnersInput, ProjectUncheckedCreateWithoutPartnersInput>
  }

  export type ProjectUpsertWithoutPartnersInput = {
    update: XOR<ProjectUpdateWithoutPartnersInput, ProjectUncheckedUpdateWithoutPartnersInput>
    create: XOR<ProjectCreateWithoutPartnersInput, ProjectUncheckedCreateWithoutPartnersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPartnersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPartnersInput, ProjectUncheckedUpdateWithoutPartnersInput>
  }

  export type ProjectUpdateWithoutPartnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPartnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutMediaPartnersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMediaPartnersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMediaPartnersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMediaPartnersInput, ProjectUncheckedCreateWithoutMediaPartnersInput>
  }

  export type ProjectUpsertWithoutMediaPartnersInput = {
    update: XOR<ProjectUpdateWithoutMediaPartnersInput, ProjectUncheckedUpdateWithoutMediaPartnersInput>
    create: XOR<ProjectCreateWithoutMediaPartnersInput, ProjectUncheckedCreateWithoutMediaPartnersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMediaPartnersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMediaPartnersInput, ProjectUncheckedUpdateWithoutMediaPartnersInput>
  }

  export type ProjectUpdateWithoutMediaPartnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMediaPartnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrdersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrdersInput, ProjectUncheckedCreateWithoutOrdersInput>
  }

  export type ProjectUpsertWithoutOrdersInput = {
    update: XOR<ProjectUpdateWithoutOrdersInput, ProjectUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProjectCreateWithoutOrdersInput, ProjectUncheckedCreateWithoutOrdersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutOrdersInput, ProjectUncheckedUpdateWithoutOrdersInput>
  }

  export type ProjectUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutEnquiriesInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEnquiriesInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEnquiriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEnquiriesInput, ProjectUncheckedCreateWithoutEnquiriesInput>
  }

  export type ProjectUpsertWithoutEnquiriesInput = {
    update: XOR<ProjectUpdateWithoutEnquiriesInput, ProjectUncheckedUpdateWithoutEnquiriesInput>
    create: XOR<ProjectCreateWithoutEnquiriesInput, ProjectUncheckedCreateWithoutEnquiriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEnquiriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEnquiriesInput, ProjectUncheckedUpdateWithoutEnquiriesInput>
  }

  export type ProjectUpdateWithoutEnquiriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEnquiriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutUtmDataInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUtmDataInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    agendaDays?: AgendaDayUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUtmDataInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUtmDataInput, ProjectUncheckedCreateWithoutUtmDataInput>
  }

  export type ProjectUpsertWithoutUtmDataInput = {
    update: XOR<ProjectUpdateWithoutUtmDataInput, ProjectUncheckedUpdateWithoutUtmDataInput>
    create: XOR<ProjectCreateWithoutUtmDataInput, ProjectUncheckedCreateWithoutUtmDataInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUtmDataInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUtmDataInput, ProjectUncheckedUpdateWithoutUtmDataInput>
  }

  export type ProjectUpdateWithoutUtmDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUtmDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    agendaDays?: AgendaDayUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutAgendaDaysInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsCreateNestedOneWithoutProjectInput
    attendees?: AttendeeCreateNestedManyWithoutProjectInput
    delegates?: DelegateCreateNestedManyWithoutProjectInput
    speakers?: SpeakerCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignCreateNestedManyWithoutProjectInput
    leads?: LeadCreateNestedManyWithoutProjectInput
    sessions?: SessionCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorCreateNestedManyWithoutProjectInput
    sponsors?: SponsorCreateNestedManyWithoutProjectInput
    partners?: PartnerCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerCreateNestedManyWithoutProjectInput
    orders?: OrderCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryCreateNestedManyWithoutProjectInput
    utmData?: UtmDataCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAgendaDaysInput = {
    id?: string
    name: string
    description?: string | null
    venue?: string | null
    website?: string | null
    image?: string | null
    year: string
    currency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: ProjectStatsUncheckedCreateNestedOneWithoutProjectInput
    attendees?: AttendeeUncheckedCreateNestedManyWithoutProjectInput
    delegates?: DelegateUncheckedCreateNestedManyWithoutProjectInput
    speakers?: SpeakerUncheckedCreateNestedManyWithoutProjectInput
    marketingCampaigns?: MarketingCampaignUncheckedCreateNestedManyWithoutProjectInput
    leads?: LeadUncheckedCreateNestedManyWithoutProjectInput
    sessions?: SessionUncheckedCreateNestedManyWithoutProjectInput
    exhibitors?: ExhibitorUncheckedCreateNestedManyWithoutProjectInput
    sponsors?: SponsorUncheckedCreateNestedManyWithoutProjectInput
    partners?: PartnerUncheckedCreateNestedManyWithoutProjectInput
    mediaPartners?: MediaPartnerUncheckedCreateNestedManyWithoutProjectInput
    orders?: OrderUncheckedCreateNestedManyWithoutProjectInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutProjectInput
    utmData?: UtmDataUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAgendaDaysInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAgendaDaysInput, ProjectUncheckedCreateWithoutAgendaDaysInput>
  }

  export type AgendaSessionCreateWithoutDayInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AgendaItemCreateNestedManyWithoutSessionInput
  }

  export type AgendaSessionUncheckedCreateWithoutDayInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AgendaItemUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AgendaSessionCreateOrConnectWithoutDayInput = {
    where: AgendaSessionWhereUniqueInput
    create: XOR<AgendaSessionCreateWithoutDayInput, AgendaSessionUncheckedCreateWithoutDayInput>
  }

  export type AgendaSessionCreateManyDayInputEnvelope = {
    data: AgendaSessionCreateManyDayInput | AgendaSessionCreateManyDayInput[]
  }

  export type ProjectUpsertWithoutAgendaDaysInput = {
    update: XOR<ProjectUpdateWithoutAgendaDaysInput, ProjectUncheckedUpdateWithoutAgendaDaysInput>
    create: XOR<ProjectCreateWithoutAgendaDaysInput, ProjectUncheckedCreateWithoutAgendaDaysInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAgendaDaysInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAgendaDaysInput, ProjectUncheckedUpdateWithoutAgendaDaysInput>
  }

  export type ProjectUpdateWithoutAgendaDaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUpdateManyWithoutProjectNestedInput
    leads?: LeadUpdateManyWithoutProjectNestedInput
    sessions?: SessionUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUpdateManyWithoutProjectNestedInput
    partners?: PartnerUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUpdateManyWithoutProjectNestedInput
    orders?: OrderUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAgendaDaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    year?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: ProjectStatsUncheckedUpdateOneWithoutProjectNestedInput
    attendees?: AttendeeUncheckedUpdateManyWithoutProjectNestedInput
    delegates?: DelegateUncheckedUpdateManyWithoutProjectNestedInput
    speakers?: SpeakerUncheckedUpdateManyWithoutProjectNestedInput
    marketingCampaigns?: MarketingCampaignUncheckedUpdateManyWithoutProjectNestedInput
    leads?: LeadUncheckedUpdateManyWithoutProjectNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutProjectNestedInput
    exhibitors?: ExhibitorUncheckedUpdateManyWithoutProjectNestedInput
    sponsors?: SponsorUncheckedUpdateManyWithoutProjectNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutProjectNestedInput
    mediaPartners?: MediaPartnerUncheckedUpdateManyWithoutProjectNestedInput
    orders?: OrderUncheckedUpdateManyWithoutProjectNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutProjectNestedInput
    utmData?: UtmDataUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AgendaSessionUpsertWithWhereUniqueWithoutDayInput = {
    where: AgendaSessionWhereUniqueInput
    update: XOR<AgendaSessionUpdateWithoutDayInput, AgendaSessionUncheckedUpdateWithoutDayInput>
    create: XOR<AgendaSessionCreateWithoutDayInput, AgendaSessionUncheckedCreateWithoutDayInput>
  }

  export type AgendaSessionUpdateWithWhereUniqueWithoutDayInput = {
    where: AgendaSessionWhereUniqueInput
    data: XOR<AgendaSessionUpdateWithoutDayInput, AgendaSessionUncheckedUpdateWithoutDayInput>
  }

  export type AgendaSessionUpdateManyWithWhereWithoutDayInput = {
    where: AgendaSessionScalarWhereInput
    data: XOR<AgendaSessionUpdateManyMutationInput, AgendaSessionUncheckedUpdateManyWithoutDayInput>
  }

  export type AgendaSessionScalarWhereInput = {
    AND?: AgendaSessionScalarWhereInput | AgendaSessionScalarWhereInput[]
    OR?: AgendaSessionScalarWhereInput[]
    NOT?: AgendaSessionScalarWhereInput | AgendaSessionScalarWhereInput[]
    id?: StringFilter<"AgendaSession"> | string
    title?: StringFilter<"AgendaSession"> | string
    startTime?: StringFilter<"AgendaSession"> | string
    endTime?: StringFilter<"AgendaSession"> | string
    color?: StringNullableFilter<"AgendaSession"> | string | null
    venue?: StringNullableFilter<"AgendaSession"> | string | null
    createdAt?: DateTimeFilter<"AgendaSession"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaSession"> | Date | string
    dayId?: StringFilter<"AgendaSession"> | string
  }

  export type AgendaDayCreateWithoutSessionsInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgendaDaysInput
  }

  export type AgendaDayUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type AgendaDayCreateOrConnectWithoutSessionsInput = {
    where: AgendaDayWhereUniqueInput
    create: XOR<AgendaDayCreateWithoutSessionsInput, AgendaDayUncheckedCreateWithoutSessionsInput>
  }

  export type AgendaItemCreateWithoutSessionInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    speakers?: AgendaItemSpeakerCreateNestedManyWithoutAgendaItemInput
  }

  export type AgendaItemUncheckedCreateWithoutSessionInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    speakers?: AgendaItemSpeakerUncheckedCreateNestedManyWithoutAgendaItemInput
  }

  export type AgendaItemCreateOrConnectWithoutSessionInput = {
    where: AgendaItemWhereUniqueInput
    create: XOR<AgendaItemCreateWithoutSessionInput, AgendaItemUncheckedCreateWithoutSessionInput>
  }

  export type AgendaItemCreateManySessionInputEnvelope = {
    data: AgendaItemCreateManySessionInput | AgendaItemCreateManySessionInput[]
  }

  export type AgendaDayUpsertWithoutSessionsInput = {
    update: XOR<AgendaDayUpdateWithoutSessionsInput, AgendaDayUncheckedUpdateWithoutSessionsInput>
    create: XOR<AgendaDayCreateWithoutSessionsInput, AgendaDayUncheckedCreateWithoutSessionsInput>
    where?: AgendaDayWhereInput
  }

  export type AgendaDayUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AgendaDayWhereInput
    data: XOR<AgendaDayUpdateWithoutSessionsInput, AgendaDayUncheckedUpdateWithoutSessionsInput>
  }

  export type AgendaDayUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgendaDaysNestedInput
  }

  export type AgendaDayUncheckedUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemUpsertWithWhereUniqueWithoutSessionInput = {
    where: AgendaItemWhereUniqueInput
    update: XOR<AgendaItemUpdateWithoutSessionInput, AgendaItemUncheckedUpdateWithoutSessionInput>
    create: XOR<AgendaItemCreateWithoutSessionInput, AgendaItemUncheckedCreateWithoutSessionInput>
  }

  export type AgendaItemUpdateWithWhereUniqueWithoutSessionInput = {
    where: AgendaItemWhereUniqueInput
    data: XOR<AgendaItemUpdateWithoutSessionInput, AgendaItemUncheckedUpdateWithoutSessionInput>
  }

  export type AgendaItemUpdateManyWithWhereWithoutSessionInput = {
    where: AgendaItemScalarWhereInput
    data: XOR<AgendaItemUpdateManyMutationInput, AgendaItemUncheckedUpdateManyWithoutSessionInput>
  }

  export type AgendaItemScalarWhereInput = {
    AND?: AgendaItemScalarWhereInput | AgendaItemScalarWhereInput[]
    OR?: AgendaItemScalarWhereInput[]
    NOT?: AgendaItemScalarWhereInput | AgendaItemScalarWhereInput[]
    id?: StringFilter<"AgendaItem"> | string
    title?: StringFilter<"AgendaItem"> | string
    startTime?: StringFilter<"AgendaItem"> | string
    endTime?: StringFilter<"AgendaItem"> | string
    type?: StringFilter<"AgendaItem"> | string
    description?: StringNullableFilter<"AgendaItem"> | string | null
    createdAt?: DateTimeFilter<"AgendaItem"> | Date | string
    updatedAt?: DateTimeFilter<"AgendaItem"> | Date | string
    sessionId?: StringFilter<"AgendaItem"> | string
  }

  export type AgendaSessionCreateWithoutItemsInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    day: AgendaDayCreateNestedOneWithoutSessionsInput
  }

  export type AgendaSessionUncheckedCreateWithoutItemsInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dayId: string
  }

  export type AgendaSessionCreateOrConnectWithoutItemsInput = {
    where: AgendaSessionWhereUniqueInput
    create: XOR<AgendaSessionCreateWithoutItemsInput, AgendaSessionUncheckedCreateWithoutItemsInput>
  }

  export type AgendaItemSpeakerCreateWithoutAgendaItemInput = {
    id?: string
    createdAt?: Date | string
    speaker: SpeakerCreateNestedOneWithoutAgendaItemsInput
  }

  export type AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput = {
    id?: string
    createdAt?: Date | string
    speakerId: string
  }

  export type AgendaItemSpeakerCreateOrConnectWithoutAgendaItemInput = {
    where: AgendaItemSpeakerWhereUniqueInput
    create: XOR<AgendaItemSpeakerCreateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput>
  }

  export type AgendaItemSpeakerCreateManyAgendaItemInputEnvelope = {
    data: AgendaItemSpeakerCreateManyAgendaItemInput | AgendaItemSpeakerCreateManyAgendaItemInput[]
  }

  export type AgendaSessionUpsertWithoutItemsInput = {
    update: XOR<AgendaSessionUpdateWithoutItemsInput, AgendaSessionUncheckedUpdateWithoutItemsInput>
    create: XOR<AgendaSessionCreateWithoutItemsInput, AgendaSessionUncheckedCreateWithoutItemsInput>
    where?: AgendaSessionWhereInput
  }

  export type AgendaSessionUpdateToOneWithWhereWithoutItemsInput = {
    where?: AgendaSessionWhereInput
    data: XOR<AgendaSessionUpdateWithoutItemsInput, AgendaSessionUncheckedUpdateWithoutItemsInput>
  }

  export type AgendaSessionUpdateWithoutItemsInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    day?: AgendaDayUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type AgendaSessionUncheckedUpdateWithoutItemsInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemSpeakerUpsertWithWhereUniqueWithoutAgendaItemInput = {
    where: AgendaItemSpeakerWhereUniqueInput
    update: XOR<AgendaItemSpeakerUpdateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedUpdateWithoutAgendaItemInput>
    create: XOR<AgendaItemSpeakerCreateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedCreateWithoutAgendaItemInput>
  }

  export type AgendaItemSpeakerUpdateWithWhereUniqueWithoutAgendaItemInput = {
    where: AgendaItemSpeakerWhereUniqueInput
    data: XOR<AgendaItemSpeakerUpdateWithoutAgendaItemInput, AgendaItemSpeakerUncheckedUpdateWithoutAgendaItemInput>
  }

  export type AgendaItemSpeakerUpdateManyWithWhereWithoutAgendaItemInput = {
    where: AgendaItemSpeakerScalarWhereInput
    data: XOR<AgendaItemSpeakerUpdateManyMutationInput, AgendaItemSpeakerUncheckedUpdateManyWithoutAgendaItemInput>
  }

  export type AgendaItemCreateWithoutSpeakersInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AgendaSessionCreateNestedOneWithoutItemsInput
  }

  export type AgendaItemUncheckedCreateWithoutSpeakersInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionId: string
  }

  export type AgendaItemCreateOrConnectWithoutSpeakersInput = {
    where: AgendaItemWhereUniqueInput
    create: XOR<AgendaItemCreateWithoutSpeakersInput, AgendaItemUncheckedCreateWithoutSpeakersInput>
  }

  export type SpeakerCreateWithoutAgendaItemsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSpeakersInput
  }

  export type SpeakerUncheckedCreateWithoutAgendaItemsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SpeakerCreateOrConnectWithoutAgendaItemsInput = {
    where: SpeakerWhereUniqueInput
    create: XOR<SpeakerCreateWithoutAgendaItemsInput, SpeakerUncheckedCreateWithoutAgendaItemsInput>
  }

  export type AgendaItemUpsertWithoutSpeakersInput = {
    update: XOR<AgendaItemUpdateWithoutSpeakersInput, AgendaItemUncheckedUpdateWithoutSpeakersInput>
    create: XOR<AgendaItemCreateWithoutSpeakersInput, AgendaItemUncheckedCreateWithoutSpeakersInput>
    where?: AgendaItemWhereInput
  }

  export type AgendaItemUpdateToOneWithWhereWithoutSpeakersInput = {
    where?: AgendaItemWhereInput
    data: XOR<AgendaItemUpdateWithoutSpeakersInput, AgendaItemUncheckedUpdateWithoutSpeakersInput>
  }

  export type AgendaItemUpdateWithoutSpeakersInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AgendaSessionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type AgendaItemUncheckedUpdateWithoutSpeakersInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakerUpsertWithoutAgendaItemsInput = {
    update: XOR<SpeakerUpdateWithoutAgendaItemsInput, SpeakerUncheckedUpdateWithoutAgendaItemsInput>
    create: XOR<SpeakerCreateWithoutAgendaItemsInput, SpeakerUncheckedCreateWithoutAgendaItemsInput>
    where?: SpeakerWhereInput
  }

  export type SpeakerUpdateToOneWithWhereWithoutAgendaItemsInput = {
    where?: SpeakerWhereInput
    data: XOR<SpeakerUpdateWithoutAgendaItemsInput, SpeakerUncheckedUpdateWithoutAgendaItemsInput>
  }

  export type SpeakerUpdateWithoutAgendaItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSpeakersNestedInput
  }

  export type SpeakerUncheckedUpdateWithoutAgendaItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendeeCreateManyProjectInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    checkedIn?: boolean
    checkinTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DelegateCreateManyProjectInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    address?: string | null
    booth?: string | null
    status?: string | null
    description?: string | null
    priority?: number
    featured?: boolean
    type: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpeakerCreateManyProjectInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    position?: string | null
    bio?: string | null
    featured?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingCampaignCreateManyProjectInput = {
    id?: string
    name: string
    type: string
    total?: number
    revenue?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyProjectInput = {
    id?: string
    name: string
    email: string
    contact?: string | null
    company?: string | null
    type?: string | null
    date?: Date | string | null
    qualifyStatus?: string | null
    salesStatus?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    startTime: string
    endTime: string
    date?: Date | string | null
    venue?: string | null
    day?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExhibitorCreateManyProjectInput = {
    id?: string
    name: string
    image?: string | null
    boothNumber?: string | null
    category?: string | null
    status?: string | null
    size?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SponsorCreateManyProjectInput = {
    id?: string
    name: string
    image?: string | null
    level: string
    amount?: string | null
    status?: string | null
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCreateManyProjectInput = {
    id?: string
    name: string
    image?: string | null
    type?: string | null
    website?: string | null
    status?: string | null
    contribution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaPartnerCreateManyProjectInput = {
    id?: string
    name: string
    image?: string | null
    website?: string | null
    type?: string | null
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyProjectInput = {
    id?: string
    orderNumber: string
    customerName: string
    customerEmail: string
    amount: number
    status: string
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnquiryCreateManyProjectInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    subject?: string | null
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtmDataCreateManyProjectInput = {
    id?: string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    term?: string | null
    content?: string | null
    visits?: number
    conversions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgendaDayCreateManyProjectInput = {
    id?: string
    name: string
    date: Date | string
    dayNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendeeUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    booth?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItems?: AgendaItemSpeakerUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItems?: AgendaItemSpeakerUncheckedUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingCampaignUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingCampaignUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingCampaignUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    total?: IntFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualifyStatus?: NullableStringFieldUpdateOperationsInput | string | null
    salesStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    day?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    boothNumber?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SponsorUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    contribution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPartnerUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPartnerUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaPartnerUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutProjectInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutProjectInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutProjectInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnquiryUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnquiryUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnquiryUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtmDataUpdateWithoutProjectInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtmDataUncheckedUpdateWithoutProjectInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtmDataUncheckedUpdateManyWithoutProjectInput = {
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visits?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaDayUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AgendaSessionUpdateManyWithoutDayNestedInput
  }

  export type AgendaDayUncheckedUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AgendaSessionUncheckedUpdateManyWithoutDayNestedInput
  }

  export type AgendaDayUncheckedUpdateManyWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemSpeakerCreateManySpeakerInput = {
    id?: string
    createdAt?: Date | string
    agendaItemId: string
  }

  export type AgendaItemSpeakerUpdateWithoutSpeakerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItem?: AgendaItemUpdateOneRequiredWithoutSpeakersNestedInput
  }

  export type AgendaItemSpeakerUncheckedUpdateWithoutSpeakerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItemId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemSpeakerUncheckedUpdateManyWithoutSpeakerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaItemId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaSessionCreateManyDayInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    color?: string | null
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgendaSessionUpdateWithoutDayInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AgendaItemUpdateManyWithoutSessionNestedInput
  }

  export type AgendaSessionUncheckedUpdateWithoutDayInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AgendaItemUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AgendaSessionUncheckedUpdateManyWithoutDayInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemCreateManySessionInput = {
    id?: string
    title: string
    startTime: string
    endTime: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgendaItemUpdateWithoutSessionInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speakers?: AgendaItemSpeakerUpdateManyWithoutAgendaItemNestedInput
  }

  export type AgendaItemUncheckedUpdateWithoutSessionInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speakers?: AgendaItemSpeakerUncheckedUpdateManyWithoutAgendaItemNestedInput
  }

  export type AgendaItemUncheckedUpdateManyWithoutSessionInput = {
    title?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemSpeakerCreateManyAgendaItemInput = {
    id?: string
    createdAt?: Date | string
    speakerId: string
  }

  export type AgendaItemSpeakerUpdateWithoutAgendaItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: SpeakerUpdateOneRequiredWithoutAgendaItemsNestedInput
  }

  export type AgendaItemSpeakerUncheckedUpdateWithoutAgendaItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaItemSpeakerUncheckedUpdateManyWithoutAgendaItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speakerId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}